<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Course Planner</title>
    <style>
        
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #313331;
            color: rgb(13, 14, 11);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 1000;
            transition: transform 1s ease, opacity 1s ease;
        }

        #splash-content {
            text-align: center;
            font-family: Arial, sans-serif;
        }

        #enter-course-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            color: #4CAF50;
            background-color: rgb(5, 5, 5);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }

        #enter-course-btn:hover {
            background-color: #45a049;
            color: rgb(59, 56, 56);
        }


        body {
            font-family: Arial, sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333335;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            background-color: rgb(78, 76, 76);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 20px;
        }
        .dropdown {
            margin: 20px 0;
        }
        .dropdown button {
            width: 100%;
            text-align: left;
            padding: 15px;
            font-size: 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
        }
        .dropdown button:hover {
            background-color: #45a049;
        }
        .dropdown-content {
            display: none;
            margin-top: 5px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #b9b7b7;
            color: #000;
        }
        .day-title {
            font-size: 22px;
            font-weight: bold;
            color: #030303;
            margin-bottom: 10px;
        }
        .day-info {
            font-size: 18px;
            line-height: 1.8;
            color: #000;
            text-align: justify;
        }
        .day-info ul {
            margin: 10px 0 10px 20px;
            padding: 0;
            list-style-type: disc;
        }
        .day-info p {
            margin: 10px 0;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 30px;
            color: #333;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <div id="splash-content">
            <p>Welcome to the Course</p>
            <button id="enter-course-btn">Enter Now</button>
        </div>
    </div>
    <div class="container">
        <h1>Linux Course For Beginners</h1>
        <div class="dropdown">
            <button onclick="toggleDropdown('introduction')">Introduction</button>
            <div id="introduction" class="dropdown-content">
                <div class="day-title">Course Introduction</div>
                <div class="day-info">
                    <p>Welcome to the Linux Fundamentals course! Whether you are new to Linux or looking to deepen your knowledge, this course will guide you through essential concepts and practical skills to equip you with the tools necessary to become proficient in Linux system administration.</p>
                    <p>Linux is one of the most widely used operating systems in the world, powering everything from personal computers and web servers to embedded systems and smartphones. Its open-source nature, robust performance, and flexibility make it the preferred choice for developers, system administrators, and IT professionals. Learning Linux can open the door to many career opportunities in software development, system administration, cloud computing, and cybersecurity.</p>

                    <b>What Will You Learn?</b>
                    <p>We’ll start by introducing you to Linux and its distributions, the installation process, and the Linux file system structure. You’ll also get hands-on practice with essential commands and text editors to help you navigate and manage your system effectively.</p>
                    <p>Once you’re comfortable with the basics, we’ll dive into file operations, search techniques, shell scripting, process management, and networking. You’ll learn to automate tasks, manage processes, and troubleshoot network issues.</p>
                    <p>As you move forward, you’ll learn key concepts around system security, managing users and groups, backups and recovery strategies, and automation. You’ll also develop shell scripting skills and apply them to real-world administration tasks.</p>
                    <p>In the final phase of the course, we explore the cloud environment, containerization with Docker, virtualization, and DevOps tools like Kubernetes, Jenkins, and Ansible. You’ll also learn how to customize your shell environment and work with advanced tools that are vital in today’s IT landscape.</p>

                    <b>Course Structure</b>
                    <h3>Linux Courses Outline</h3>

                    <h3>Week 1: Introduction to Linux</h3>
                        
                    <b>Day 1: History of Linux and its Distros</b>
                    <ul>
                        <li>Overview of Linux</li>
                        <li>Popular distributions (Ubuntu, Fedora, CentOS, etc.)</li>
                        <li>Open-source philosophy</li>
                    </ul>

                    <p><b>Day 2: Installation and Setup</b></p>
                    <ul>
                        <li>Installing Linux (Virtual Machine, Dual Boot, Live USB)</li>
                        <li>Basic system setup and configuration</li>
                    </ul>

                    <p><b>Day 3: Linux File System Structure</b></p>
                    <ul>
                        <li>Understanding the directory structure</li>
                        <li>Common directories (/home, /etc, /var, /usr, /bin, /sbin, /lib)</li>
                    </ul>

                    <b>Day 4: Basic Commands</b>
                    <ul>
                        <li>Navigation (cd, ls, pwd)</li>
                        <li>File operations (cp, mv, rm, touch, mkdir)</li>
                    </ul>

                    <b>Day 5: Basic Text Editors</b>
                    <ul>
                        <li>Introduction to nano and vim</li>
                        <li>Basic file editing</li>
                    </ul>

                    <h3>Week 2: Command Line Usage</h3>

                    <p><b>Day 1: Advanced File Operations</b></p>
                    <ul>
                        <li>Permissions and ownership (chmod, chown)</li>
                        <li>Links (hard and symbolic links)</li>
                    </ul>

                    <b>Day 2: Searching and Finding Files</b>
                    <ul>
                        <li>find, locate, grep, and other search tools</li>
                    </ul>

                    <b>Day 3: Introduction to Shell Scripting</b>
                    <ul>
                        <li>Basic shell script syntax</li>
                        <li>Creating and running simple scripts</li>
                    </ul>

                    <b>Day 4: Process Management</b>
                    <ul>
                        <li>Understanding processes and jobs</li>
                        <li>Commands: ps, top, kill, bg, fg, jobs</li>
                        <li>Daemons, child, parent,  Init Process</li>
                    </ul>

                    <b>Day 5: Networking Basics</b>
                    <ul>
                        <li>Basic network configuration</li>
                        <li>Common networking commands (ping, ifconfig/ip, netstat, ssh)</li>
                    </ul>

                    <h3>Week 3: System Topics</h3>
                    
                    <b>Day 1: Package Management</b>
                    <ul>
                        <li>Using package managers (apt, yum, dnf, pacman)</li>
                        <li>Installing, updating, and removing software</li>
                        <li>DKPG, RPM</li>
                    </ul>

                    <b>Day 2: User and Group Management</b>
                    <ul>
                        <li>Creating and managing users and groups</li>
                        <li>Understanding and configuring sudo</li>
                    </ul>

                    <b>Day 3: Disk Management</b>
                    <ul>
                        <li>Disk partitions and filesystems</li>
                        <li>Using fdisk, mkfs, mount, and other disk utilities</li>
                    </ul>

                    <b>Day 4: System Monitoring and Performance</b>
                    <ul>
                        <li>Monitoring system performance (top, htop, iostat, vmstat)</li>
                        <li>Log files and system logging</li>
                    </ul>

                    <b>Day 5: Introduction to Kernel</b>
                    <ul>
                        <li>What is the kernel and its role</li>
                        <li>Basic kernel modules and configuration</li>
                    </ul>

                    <h3>Week 4: Security and Advanced Administration</h3>

                    <b>Day 1: Basic Security Concepts</b>
                    <ul>
                        <li>Firewalls (ufw, iptables)</li>
                        <li>Basic security practices</li>
                    </ul>

                    <b>Day 2: Backup and Recovery</b>
                    <ul>
                        <li>Backup strategies and tools (rsync, tar)</li>
                        <li>Creating and restoring backups</li>
                    </ul>

                    <b>Day 3: Automating Tasks</b>
                    <ul>
                        <li>Using cron and anacron</li>
                        <li>Scheduling tasks</li>
                    </ul>

                    <b>Day 4: Shell Scripting</b>
                    <ul>
                        <li>scripting techniques</li>
                        <li>Script debugging and optimization</li>
                    </ul>

                    <b>Day 5: Practical Projects</b>
                    <ul>
                        <li>Set up a personal project (e.g., web server, file server)</li>
                        <li>Hands-on lab to apply learned concepts</li>
                    </ul>

                    <h3>Week 5: Specialized Topics</h3>
                    
                    <b>Day 1: Linux in the Cloud</b>
                    <ul>
                        <li>Introduction to cloud services (AWS, Azure, Google Cloud)</li>
                        <li>Deploying Linux instances in the cloud</li>
                    </ul>

                    <b>Day 2: Containers and Virtualization</b>
                    <ul>
                        <li>Introduction to Docker and containerization</li>
                        <li>Basic usage of virtualization tools (VirtualBox, KVM)</li>
                    </ul>

                    <b>Day 3: Customizing the Shell</b>
                    <ul>
                        <li>Shell customization (bashrc, zsh, oh-my-zsh)</li>
                        <li>Creating aliases and functions</li>
                    </ul>

                    <b>Day 4: Introduction to DevOps Tools</b>
                    <ul>
                        <li>Overview of CI/CD</li>
                        <li>Introduction to tools like Ansible, Jenkins, Kubernetes</li>
                    </ul>

                    <p>I am excited to have you on this learning journey. Each week, you’ll have exercises, quizzes, and real-world projects to practice and reinforce your learning. Whether you're aiming to get better at linux for a hobby or start a career in this area. this course will equip you with the skills you need to succeed.</p>
                    <p>Throughout the course there are exercises to complete, with some i have given step by step on how to complete with others i have not because i think doing research on the internet is good practice. Along with exercises there are quiz's to complete and there is a section for the answers. I have added laymen's terms for some of the subjects matters. I have done this for the sections i think are harder to understand.</p>
                    <p>I have also got some videos for some of the topics in the course i will leave the link for my youtube channal here: https://www.youtube.com/watch?v=bGfrM7kuO-0&list=PLcHMVqvFpPegTIQSAoqTUpn-mJUS-igT6</p>
                    <p>Ready to dive into Linux? Let’s get started!</p>   
                </div>
            </div>
        </div>
      

         <!-- Week 1 -->
    <div class="dropdown">
        <button onclick="toggleDropdown('week1')">Week 1</button>
        <div id="week1" class="dropdown-content">
            <!-- Days -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week1day1')">Day 1</button>
                <div id="week1day1" class="dropdown-content">
                    <div class="day-title">The History of Linux: The Origins and Early Development</div>
                    <div class="day-info">
                        <p>The history of Linux begins with the creation of Unix in the late 1960s and early 1970s at AT&T's Bell Labs. Unix was a pioneering operating system, emphasizing simplicity, portability, and multi-user capabilities. Its design and source code greatly influenced the development of many subsequent operating systems.</p>
                        <p>In 1983, Richard Stallman initiated the GNU Project, aiming to create a free Unix-like operating system. The GNU Project successfully developed many crucial components, including compilers, libraries, and utilities. However, it lacked a working kernel.</p>

                        <h3>Linus Torvalds and the Linux Kernel</h3>
                        <p>In 1991, Linus Torvalds, a Finnish computer science student, started a personal project to create a free operating system kernel. On August 25, 1991, he announced his project on the MINIX newsgroup, seeking collaboration and feedback. Torvalds released the first version of the Linux kernel (version 0.01) on September 17, 1991. Initially, it was just a hobby, but the project quickly gained attention and support from developers worldwide.</p>
                        <p>By 1992, the Linux kernel was licensed under the GNU General Public License (GPL), which facilitated its growth as developers could freely use, modify, and distribute the code. This combination of the Linux kernel and GNU components formed a complete, functional operating system.</p>
                        <p>In 1993, Ian Murdock founded the Debian Project, which aimed to create a robust and stable Linux distribution. Debian's commitment to free software and its democratic governance model made it a significant and influential project.</p>
                        <h3>Key Concepts in Linux History</h3>
                        <ul>
                            <li>Open Source Movement: The philosophy of sharing and collaborative development, which has been central to Linux's evolution.</li>
                            <li>GPL (General Public License): The license under which Linux is distributed, ensuring that it remains free and open-source.</li>
                            <li>Desktop Environments: KDE, GNOME, and other desktop environments have made Linux accessible to non-technical users.</li>
                            <li>Enterprise Adoption: Companies like Red Hat, SUSE, and Canonical have tailored Linux distributions for enterprise use, offering support and services.</li>
                        </ul>
                        <h3>General Purpose Distributions</h3>
                        <h4>Ubuntu</h4>
                        <ul>
                            <li>Based on Debian</li>
                            <li>User-friendly, regular releases</li>
                            <li>Popular for desktops, servers, and cloud</li>
                        </ul>
                        <h4>Debian</h4>
                        <ul>
                            <li>Known for stability and extensive software repositories</li>
                            <li>Basis for many other distributions</li>
                        </ul>
                        <h4>Fedora</h4>
                        <ul>
                            <li>Sponsored by Red Hat</li>
                            <li>Focus on innovation and integrating new technologies</li>
                        </ul>
                        <h4>OpenSUSE</h4>
                        <ul>
                            <li>Sponsored by SUSE</li>
                            <li>Two versions: Leap (stable) and Tumbleweed (rolling release)</li>
                        </ul>
                        <h4>Linux Mint</h4>
                        <ul>
                            <li>Based on Ubuntu</li>
                            <li>User-friendly, comes with codecs and proprietary drivers pre-installed</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week1day2')">Day 2</button>
                <div id="week1day2" class="dropdown-content">
                    <div class="day-title">Installation and Setup</div>
                    <div class="day-info">
                        <p><b>sudo apt update</b></p>
                        <p>This command updates the list of available packages and their versions. It doesn't install or upgrade any packages; it just fetches information about the latest versions of the packages from the repositories that are configured on your system.</p>
                        <p>When you run sudo apt update, the package manager checks the URLs listed in the sources (e.g., /etc/apt/sources.list) and downloads the latest package lists from the repositories. This ensures that your system is aware of the latest versions of the software that is available.</p>
                        <b>sudo apt upgrade</b>
                        <p>This command upgrades all the installed packages on your system to the newest available versions, based on the package lists retrieved by sudo apt update. When you run sudo apt upgrade, the package manager compares the versions of the installed packages with the versions available in the updated package lists. If newer versions are found, the package manager will download and install them. This is done without removing any packages or installing new ones, unless necessary to satisfy dependencies.</p>
                        <p>You can run these commands togeather: <b>sudo apt update && sudo apt upgrade</b>. A reboot may be necessary after after updates and upgrade.</p>
                        <h3>Repositories</h3>
                        <p>Repositories (or "repos") are storage locations where software packages are stored and maintained. Think of them as online warehouses that contain a large collection of software that can be installed on your system. Each repository typically holds packages for a specific distribution or version of a Linux operating system.</p>
                        <h3>How Repositories Work</h3>
                        <p>When you install or update software on a Linux system using a package manager (like apt on Debian-based systems), the package manager downloads the necessary files from these repositories. Repositories are defined in the system’s configuration files (usually located in /etc/apt/sources.list or /etc/apt/sources.list.d/ for Debian-based systems). These files tell the package manager where to look for software packages.</p>
                        <h3>Types of Repositories</h3>
                        <ul>
                            <li><b>Official Repositories:</b> Provided by the Linux distribution itself, containing stable, tested software.</li>
                            <li><b>Third-Party Repositories:</b> Maintained by other organizations or individuals, offering software not available in the official repos.</li>
                            <li><b>PPA (Personal Package Archives):</b> A type of third-party repository used in Ubuntu, where developers can distribute software directly to users.</li>
                        </ul>
                        <h3>Dependencies</h3>
                        <p>Dependencies are libraries or packages that a piece of software requires to function properly. For example, if you want to install a program, it might depend on certain libraries being present on your system. When you install software using a package manager, it automatically checks for these dependencies and installs them if they are not already present.</p>
                        <h3>How Dependencies Work</h3>
                        <p>Dependencies ensure that the software you install runs smoothly by having all the necessary components in place. For example, a photo-editing program might depend on certain image processing libraries. The package manager resolves these dependencies by installing the required packages. If there’s a conflict or a missing dependency, the installation might fail, or the software might not work correctly.</p>
                        <h3>Dependency Chains</h3>
                        <p>Sometimes, dependencies have their own dependencies. This creates a dependency chain. The package manager takes care of these chains, ensuring all necessary components are installed.</p>
                        <h3>Examples</h3>
                        <ul>
                            <li><b>Repositories:</b> Imagine you want to install a web browser. You would use a command like <b>sudo apt install firefox</b>. Your system will check the repositories listed in your sources list to find the firefox package.</li>
                            <li><b>Dependencies:</b> If the firefox package requires certain libraries to function, the package manager will automatically check for those dependencies. If they are not already installed, it will download and install them from the repository before installing firefox.</li>
                        </ul>
                        <h3>Navigating The Desktop</h3>
                        <p>Top right you have internet, sound and power buttons. Click on this and you will bring up a box with more options, you have the option of dark and light mode. Power balance or power saver. Internet button, you can turn this on or off or enter more options. The sound bar can be adjusted left for down and right for up. Top left, screen recorder and screen shots. On the right to this is the settings button this will bring a whole host of settings we will go over this in a moment. Over to the right of the settings we have the lock screen button, this will lock the screen, to get back in enter your password. To the right of this we have the power button you can logout, suspend, restart or shutdown. </p>
                        <h3>Settings </h3>
                        <h3>1. Networking</h3>
                        <p>Manages wireless and wired network connections. Here, you can connect to available Wi-Fi networks, view saved networks, and configure network settings like IP addresses (static or DHCP). It also allows you to toggle Wi-Fi on or off.</p>
                        <h3>2. Bluetooth</h3>
                        <p>Controls Bluetooth settings for connecting to Bluetooth devices such as headphones, speakers, keyboards, mice, and other peripherals. You can pair new devices, manage paired devices, and toggle Bluetooth on or off.</p>
                        <h3>3. Displays</h3>
                        <p>Manages display settings for monitors and screens. You can adjust screen resolution, orientation, and refresh rate. It also includes options for configuring multiple monitors, screen scaling, and display arrangement.</p>
                        <h3>4. Sound</h3>
                        <p>Manages sound settings, including output devices (speakers, headphones), input devices (microphones), and system volume. It also allows you to configure sound effects, input/output levels, and manage audio profiles.</p>
                        <h3>5. Power</h3>
                        <p>Configures power management settings, including screen brightness, screen dimming, sleep, and suspend options. It also allows you to manage power settings for battery and plugged-in modes, and control the behavior when the lid is closed.</p>
                        <h3>6. Multitasking</h3>
                        <p>Manages multitasking and window management settings. You can configure how workspaces are used, enable or disable hot corners, and adjust window snapping behavior.</p>
                        <h3>7. Appearance</h3>
                        <p>Allows you to change the desktop wallpaper and lock screen background. You can choose from pre-installed backgrounds or set a custom image.</p>
                        <h3>8. Applications</h3>
                        <p>Manages installed applications. You can control application permissions, set default applications for different file types, and configure startup applications.</p>
                        <h3>9. Notifications</h3>
                        <p>Manages system notifications. You can control how and when notifications are displayed for different applications and system events. It allows you to enable or disable notifications for specific apps.</p>
                        <h3>10. Search</h3>
                        <p>Configures the behavior of the system search function. You can select which applications and file types are included in search results, and toggle the search feature on or off for certain categories.</p>
                        <h3>11. Online Accounts</h3>
                        <p>Allows you to add and manage online accounts (e.g., Google, Microsoft, Nextcloud) that integrate with your system. These accounts can be used for email, calendar, contacts, file storage, and other services.</p>
                        <h3>12. Sharing</h3>
                        <p>Configures sharing options for your system, such as enabling screen sharing, file sharing, and remote login. You can set up and manage services that allow others to access your system or shared resources.</p>
                        <h3>13. Mouse & Touchpad</h3>
                        <p>Configures mouse and touchpad settings, such as pointer speed, button configuration (left or right-handed), touchpad gestures, and tap-to-click options.</p>
                        <h3>14. Keyboard</h3>
                        <p>Manages keyboard settings, including layout, shortcuts, repeat rate, and delay. You can configure keyboard layouts for different languages and set custom shortcuts for various system actions.</p>
                        <h3>15. Colour</h3>
                        <p>Manages color profiles for connected displays and printers. This setting is useful for color calibration and ensuring accurate color reproduction on your monitor and in printed materials.</p>
                        <h3>16. Printers</h3>
                        <p>Manages connected printers. You can add new printers, remove existing ones, and configure printer settings such as default paper size and print quality.</p>
                        <h3>19. Accessibility</h3>
                        <p>Provides settings to assist users with disabilities. It includes options for screen readers, magnification, high contrast themes, on-screen keyboard, and other assistive technologies.</p>
                        <h3>20. Privacy</h3>
                        <p>Controls privacy settings such as location services, usage history, screen lock settings, and data collection preferences. It also includes options to clear recent files and other sensitive data.</p>
                        <h3>21. System</h3>
                        <h3>About</h3>
                        <p>Displays system information, including the Ubuntu version, device name, hardware specifications, and available updates. It also provides links for system support and legal information.</p>
                        <h3>Date & Time</h3>
                        <p>Configures date and time settings. You can set the time zone, enable or disable automatic time synchronization, and manually adjust the date and time.</p>
                        <h3>Users</h3>
                        <p>Manages user accounts on the system. You can add, remove, and modify user accounts, change passwords, and configure user permissions (e.g., administrator vs. standard user).</p>
                        <h3>Remote Desktop</h3>
                        <p>Allow for remote access. Use a remote desktop app to connect using the RDP protocol. You will need to provide additional information to connect.</p>
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week1day2vmware')">VMware Install</button>
                            <div id="week1day2vmware" class="dropdown-content">
                                <div class="day-title">VMware Installation</div>
                                <div class="day-info">
                                    <h3>Ubuntu On Vmware</h3>
                                    <p>First go to https://ubuntu.com/download. Here You will download the ubuntu desktop version. When the download is finished you will have it in your downloads as an ios file.</p>
                                    <p>In order for me to get vmware i had to sign up to a website called Broadcom, you may have to do this too or use virtualbox. At the top once you are signed in next to your name click on the drop down menu, Vmware Cloud Foundation. This should take you to a dashboard. On the left click on My Downloads, you should find vmware workstation 17 pro here. Then download the correct one for your machine, this should be the one for personal use.</p>
                                    <p>In the directory where you vmware download is you need to give it permissions, we will go over permissions later on in the course, for now follow along by typing:</p>
                                    <ul>
                                        <li>sudo apt update</li>
                                        <li>sudo chmod +x VMware-Workstation-Full-17.5.2-23775571.x86_64.bundle. Your version may be different.</li>
                                        <li>sudo ./VMware-Workstation Full-17.5.2-23775571.x86_64.bundle. This will install vmware.</li>
                                    </ul>
                                    <p>When i installed vmware i did come across some issues with <b>VMMON</b> AND <b>VMNET</b>. If you also have issues with these follow along with this.</p>
                                    <p>Download vmware-host-modules-workstation-17.5.1 from github. Even thought i have vmware 17.5.2 only 17.5.1 was available on github, but this still worked. Type:</p>
                                    <ul>
                                        <li>tar -xzf workstation-17.5.1.tar.gz</li>
                                        <li>cd vmware-host-modules-workstation-17.5.2</li>
                                        <li>tar -cf vmmon.tar vmmon-only/</li>
                                        <li>tar -cf vmnet.tar vmnet-only/</li>
                                        <li>sudo cp -v vmmon.tar vmnet.tar /usr/lib/vmware/modules/source/</li>
                                        <li>sudo vmware-modconfig --console --install-all</li>
                                    </ul>
                                    <p>If you have this issue, this should fix it.</p>
                                    <p>Now to power on vmware <b>sudo vmware</b>. If you find vmware in your programs and you start it up by clicking on the vmware player it may not work after you set up your machine so i recommend typing <b>sudo vmware</b>.</p>
                                    <p>You can follow these steps:</p>
                                    <ul>
                                        <li>Open VMware and click on the option Create a New Virtual Machine.</li>
                                        <li>Select the first checkbox called Typical (recommended) and click on the Next button.</li>
                                        <li>Installer disc image(iso)  browse for your ubuntu.iso that you downloaded earlier.</li>
                                        <li>Choose  Linux as a Guest Operating System, and after that select Ubuntu 64-bit in the version option.</li>
                                        <li>At this moment, assign a Virtual Machine Name and hit the Next button.</li>
                                        <li>Set 20 GB at least as the maximum disk size (recommended) and also select the option “Store virtual desk as a single file”. Then click on Next.</li>
                                        <li>Click finish.</li>
                                    </ul>
                                    <p>The ubuntu virtual machine should start.</p>
                                    <ul>
                                        <li>Select the language you prefer. Then click on Next.</li>
                                        <li>Select “Install Ubuntu” and click on Next.</li>
                                        <li>Select your keyboard layout and go to Next.</li>
                                        <li>Choose the Use wired connection from the Connect to a Network Window and click on Next.</li>
                                        <li>Choose the Normal installation option.</li>
                                        <li>Select the Erase disk and install the Ubuntu.</li>
                                        <li>Finally, Click on the Install button to begin the Ubuntu installation.</li>
                                        <li>Choose your timezone and go to Next.</li>
                                        <li>To set up your account, provide your name, and computer’s name and pick a password at your convenience. Then click on the Next.</li>
                                        <li>As the installation completes, Click on the Restart Now button.</li>
                                        <li>After the restart of the VM, a Login screen will appear with the previously created username.</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="dropdown">
                                <button onclick="toggleDropdown('week1day2usbinstall')">USB Install</button>
                                <div id="week1day2usbinstall" class="dropdown-content">
                                    <div class="day-title">USB Installation</div>
                                    <div class="day-info">
                                        <p>Installing Ubuntu on a USB Drive using balenaEtcher</p>
                                        <h3>Download Ubuntu ISO</h3>
                                        <ul>
                                            <li>Visit the Ubuntu official website to download the latest Ubuntu ISO file.</li>
                                            <li>Choose the appropriate version (e.g., Ubuntu Desktop or Ubuntu Server) and click on the download link.</li>
                                        </ul>
                                        <h3>Download and Install balenaEtcher</h3>
                                        <ul>
                                            <li>Visit the balenaEtcher website and download the version compatible with your operating system (Windows, macOS, or Linux).</li>
                                            <li>Install balenaEtcher by following the on-screen instructions.</li>
                                        </ul>
                                        <h3>Prepare Your USB Drive</h3>
                                        <ul>
                                            <li>Insert your USB drive into an available USB port on your computer.</li>
                                            <li>Ensure the USB drive is at least 8GB in size (for Ubuntu Desktop) or larger, depending on your needs.</li>
                                            <li>Warning: All data on the USB drive will be erased during the flashing process. Back up any important data.</li>
                                        </ul>
                                        <h3>Launch balenaEtcher</h3>
                                        <p>Open balenaEtcher on your computer after installation.</p>
                                        <p>You will see a simple interface with three main steps:</p>
                                        <ul>
                                            <li>Select Image</li>
                                            <li>Select Target</li>
                                            <li>Flash!</li>
                                        </ul>
                                        <h3>Select the Ubuntu ISO Image</h3>
                                        <ul>
                                            <li>Click the "Flash from file" button in balenaEtcher.</li>
                                            <li>Navigate to the location where you downloaded the Ubuntu ISO file.</li>
                                            <li>Select the ISO file and click Open.</li>
                                        </ul>
                                        <h3>Select the Target USB Drive</h3>
                                        <ul>
                                            <li>Click the "Select target" button.</li>
                                            <li>balenaEtcher will list all connected storage devices. Make sure to carefully select your USB drive (double-check the drive name and size to avoid accidentally selecting your internal hard drive or other devices).</li>
                                            <li>Click on the USB drive to select it, and then click Select.</li>
                                        </ul>
                                        <h3>Flash the Ubuntu ISO to the USB Drive</h3>
                                        <ul>
                                            <li>Once the image and target are selected, click the "Flash!" button.</li>
                                            <li>balenaEtcher will begin flashing the Ubuntu ISO to the USB drive. This process may take several minutes, depending on the speed of your USB drive and computer.</li>
                                            <li>During the flashing process, balenaEtcher will display a progress bar. Wait until the process is complete.</li>
                                        </ul>
                                        <h3>Eject the USB Drive Safely</h3>
                                        <p>Once the flashing and verification process is complete, balenaEtcher will notify you that the process has finished successfully. Safely eject your USB drive from your computer.</p>
                                        <ul>
                                            <li>On Windows: Right-click the USB drive in File Explorer and select "Eject".</li>
                                            <li>n macOS: Drag the USB drive icon to the Trash (which will change to an Eject icon).</li>
                                            <li>On Linux: Use your file manager to unmount and safely remove the USB drive.</li>
                                        </ul>
                                        <h3>Boot from the USB Drive</h3>
                                        <ul>
                                            <li>Insert the USB drive into the computer where you want to install Ubuntu.</li>
                                            <li>Restart the computer and enter the BIOS/UEFI settings (usually by pressing a key like F2, F10, F12, Esc, or Del during startup, depending on the manufacturer). Set the USB drive as the primary boot device.</li>
                                            <li>Save the BIOS/UEFI settings and exit.</li>
                                            <li>Computer should now boot from the USB drive, presenting you with the Ubuntu installation screen.</li>
                                        </ul>
                                        <h3>Install Ubuntu</h3>
                                        <ul>
                                            <li>Follow the on-screen instructions to install Ubuntu on your computer or use it in live mode (try it without installing).</li>
                                            <li>If you choose to install Ubuntu, follow the guided installation steps, including selecting your language, partitioning the disk, and setting up your user account.</li>
                                        </ul>
                                            
                            
                                    </div>
                                </div>
                            </div>
                            
                            

                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week1day3')">Day 3</button>
                <div id="week1day3" class="dropdown-content">
                    <div class="day-title">Linux File System Structure</div>
                    <div class="day-info">
                        <h3>Root Directory: /</h3>
                        <p>Understanding the directory structure of Ubuntu (and Linux in general) is key to navigating and managing the system. The Linux filesystem follows the Filesystem Hierarchy Standard (FHS), which defines the locations of important directories and their contents. The root directory (/) is the base of the entire filesystem. All other directories and files branch off from this root. It is owned by the root user, and only administrators (via sudo) can make changes to this directory.</p>
                    
                        <h3>/bin (Essential User Binaries)</h3>
                        <p>Essential command binaries (executables) required for the system to operate in single-user mode and to boot. These commands are accessible to all users. These commands are for the basic functionality of the system, and they are used early during the boot process. These binaries are necessary for both the system administrator and regular users to perform fundamental tasks.</p>
                        <p><b>Examples:</b>Basic commands like ls, cp, mv, rm, cat, bash.</p>
                        

                        <h3>/boot (Boot Loader Files)</h3>
                        <p>Files required to boot the system, including the kernel (vmlinuz), the initial ramdisk image (initrd.img), and the boot loader configuration files (like GRUB). This directory holds everything needed to load the Linux kernel and start the boot process.</p>
                        <p><b>Examples:</b>System.map-<version>: Kernel symbol map. Config-<version>: Kernel configuration file.</p>

                        <h3>/dev (Device Files)</h3>
                        <p>Files that represent hardware devices. These are not actual files but special files that act as interfaces to hardware (e.g., hard drives, USB devices, input devices). Provides access to hardware devices through the filesystem.</p>
                        <p><b>Examples:</b>sda (hard drive), tty (terminal devices), null, random, zero.</p>
                        

                        <h3>/etc (Configuration Files)</h3>
                        <p>System-wide configuration files and shell scripts that are used during startup and by different services.</p>
                        <p><b>Examples:</b>Network configuration files (/etc/network/interfaces), user account and password files (/etc/passwd, /etc/shadow), service startup scripts (/etc/init.d/).</p>
                      

                        <h3>/home (User Home Directories)</h3>
                        <p>This stores personal directories for each user on the system.</p>
                        <p><b>Examples:</b>/home/john, /home/sarah, etc. Each user has their own directory where they store personal files, settings, and data.</p>

                        <h3>/lib (Shared Libraries)</h3>
                        <p>Essential shared libraries (similar to Windows DLLs) needed by binaries in /bin and /sbin. Provides essential library files required for system programs to run.</p>
                        <p><b>Examples:</b>libc.so, libm.so, and kernel modules in /lib/modules/.</p>

                        <h3>/lost+found (Recovered Files)</h3>
                        <p>Every Linux file system includes a lost+found directory. In the event of a file system crash, a file system check is performed during the next boot. Any corrupted files detected are placed in the lost+found directory, allowing you to attempt data recovery.</p>  

                        <h3>/media (Removable Media Mount Points)</h3>
                        <p>Mount points for removable media like USB drives, CDs, and external hard drives. Temporarily mounts removable media when connected to the system.</p>
                        <p><b>Examples:</b>If you insert a USB drive, it might get mounted to /media/username/usbname.</p>

                        <h3>/mnt (Temporary Mount Points)</h3>
                        <p> Empty directory used for temporarily mounting filesystems, often used by system administrators. Provides a standard location for temporarily mounting external filesystems for system maintenance.</p>

                        <h3>/opt (Optional Application Software)</h3>
                        <p>Third-party or optional software that is not part of the standard Linux package management system. On install it may place files into /opt/application folder.</p>
                        <p><b>Examples:</b>Proprietary software or packages installed outside of the package manager, like Google Chrome or Oracle Java.</p>

                        <h3>/proc (Process Information)</h3>
                        <p>Virtual filesystem that provides an interface to kernel data structures. It contains information about the system and running processes. The /proc directory is similar to the /dev directory in that it doesn’t contain standard files. Instead, it holds special files that represent system and process information.</p>
                        <p><b>Examples:</b>/proc/cpuinfo (CPU information), /proc/meminfo (memory usage), /proc/<PID> (process-specific directories).</p>

                        <h3>/root (Root User’s Home Directory)</h3>
                        <p>The home directory for the root user. Provides a separate home directory for the root user, as they don't use the /home directory like normal users.</p>

                        <h3>/run (Runtime Data)</h3>
                        <p>Data that is used by applications and services during runtime. This directory is typically cleared during boot. Stores volatile runtime data for processes that need to communicate with one another. These files can't be stored in /tmp because files in /tmp may be deleted.</p>
                        <p><b>Examples:</b>Process IDs (PID files), lock files, socket files.</p>

                        <h3>13. /sbin (System Binaries)</h3>
                        <p>Essential system binaries, similar to /bin, but primarily for system administration tasks that require superuser (root) privileges. Provides essential binaries for system maintenance and administrative tasks.</p>
                        <p><b>Examples:</b>fsck, reboot, shutdown, mkfs.</p>

                        <h3>/srv (Service Data)</h3>
                        <p>Data used by services offered by the system, such as web servers or FTP servers. </p>
                        <p><b>Examples:</b>Web server data (/srv/www), FTP data (/srv/ftp).</p>

                        <h3>/sys (System Information)</h3>
                        <p>Provides a virtual filesystem for exposing kernel and device data. Similar to /proc, it allows access to kernel information. Access to information about hardware devices, kernel modules, and system settings.</p>
                        <p><b>Examples:</b>/sys/class/, /sys/devices/.</p>

                        <h3>/tmp (Temporary Files)</h3>
                        <p>Applications save temporary files in the /tmp directory. These files are typically removed when the system is rebooted and can also be deleted at any time by utilities like systemd-tmpfiles.</p>
                        
                        <h3>/snap Storage for Snap Packages</h3>
                        <p>Another directory that isn’t part of the Filesystem Hierarchy Standard (FHS) but is commonly found in todays system is /snap. It stores installed Snap packages and related files associated with Snap. While Ubuntu uses Snaps by default, this directory may not be present on distributions that do not support or use Snap packages.</p>

                        <h3>/usr (User Binaries and Read-Only Data)</h3>
                        <p>The /usr directory houses applications and files intended for user use, as opposed to those used by the system. For instance, non-essential applications are stored in the /usr/bin directory rather than /bin, and non-essential system administration binaries are placed in /usr/sbin instead of /sbin. Corresponding libraries are located in the /usr/lib directory. Additionally, the /usr directory includes other subdirectories, such as /usr/share, which contains architecture-independent files like graphics. The /usr/local directory is the default installation location for locally compiled applications. This separation helps prevent these applications from interfering with the rest of the system.</p>
                        <ul>
                            <li>/usr/bin: Non-essential user binaries (commands) for all users.</li>
                            <li>/usr/sbin: Non-essential system binaries for root or administrators.</li>
                            <li>/usr/lib: Shared libraries for the binaries in /usr/bin and /usr/sbin.</li>
                            <li>/usr/local: Locally compiled or installed software that’s not managed by the system’s package manager.</li>
                        </ul>

                        <h3>/var (Variable Data)</h3>
                        <p>/var stands for "variable" and is a directory in the Linux file system where variable data is stored. Variable data refers to data that changes frequently, such as logs, caches, and temporary files. /var is designed to store data that is written to by the system or applications, and is therefore subject to change.</p>
                        <ul>
                            <li>/var/log: System and application logs.</li>
                            <li>/var/spool: Print jobs and mail queues.</li>
                            <li>/var/cache: Cached data from applications.</li>
                        </ul>

                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week1day4')">Day 4</button>
                <div id="week1day4" class="dropdown-content">
                    <div class="day-title">Basic Commands</div>
                    <div class="day-info">
                        <p>In this section we will cover some of the basic commands used throughout of the linux system.</p>

                        <h3>cd (Change Directory)</h3>

                        <p>This linux command is used to change the current directory you are in.</p>

                        <b>Usage:</b>
                        <ul>
                            <li>cd /path/to/directory: Move to a specific directory.</li>
                            <li><b>cd ~ :</b> Move to the home directory.</li>
                            <li><b>cd .. :</b> Move up one directory (to the parent directory).</li>
                            <li><b>cd - :</b> Move to the previous directory you were in.</li>
                            <li><b>cd Documents:</b> Moves into the Documents folder</li>
                        </ul>

                        <h3>ls (List Files)</h3>

                        <p>Lists the contents of a directory.</p>

                        <b>Usage:</b>
                        <ul>
                            <li><b>ls:</b> List files in the current directory.</li>
                            <li><b>ls /path/to/directory:</b> List files in a specific directory.</li>
                            <li><b>ls -l:</b> Long listing format (shows file permissions, owner, size, and modification date).</li>
                            <li><b>ls -a:</b> List all files, including hidden files (files starting with a dot .).</li>
                            <li><b>ls -lh:</b> List files in human-readable format, with file sizes in KB, MB, etc.</li>
                        </ul>    
                        
                        <h3>pwd (Print Working Directory)</h3>

                        <p>Displays the full path of the current directory you are in.</p>

                        <p><b>Usage:</b> pwd</p>

                        <h3>File Operations</h3>

                        <h3>cp (Copy Files/Directories)</h3>

                        <p>Copies files or directories from one location to another.</p>
                        <b>Usage:</b>
                        <ul>
                            <li><b>cp source destination:</b> Copy a file from source to destination.</li>
                            <li><b>cp -r source destination:</b> Copy a directory recursively.</li>
                        </ul>
                        <b>Examples:</b>
                        <ul>
                            <li><b>cp file.txt /tmp/ :</b> Copy file.txt to the /tmp/ directory</li>
                            <li><b>cp -r mydir /backup/ :</b> Copy the directory mydir and its contents to /backup</li>
                        </ul>

                        <h3>mv (Move or Rename Files/Directories)</h3>

                        <p>Moves or renames files or directories.</p>

                        <b>Usage:</b>
                        <p>mv source destination: Move a file or directory to another location or rename it.</p>

                        <b>Examples:</b>
                        <ul>
                            <li><b>mv file.txt /tmp/ :</b> Move file.txt to the /tmp/ directory</li>
                            <li><b>mv oldname.txt newname.txt :</b> Rename oldname.txt to newname.txt</li>
                        </ul>

                        <h3>rm (Remove Files/Directories)</h3>
                        <p>Deletes files or directories.</p>
                        <b>Usage:</b>
                        <ul>
                            <li><b>rm filename:</b> Deletes a file.</li>
                            <li><b>rm -r directory:</b> Deletes a directory and its contents recursively.</li>
                            <li><b>rm -f filename:</b> Forces the removal without prompting for confirmation.</li>
                        </ul>

                        <b>Examples:</b>
                        <ul>
                            <li><b>rm file.txt:</b> Delete file.txt</li>
                            <li><b>rm -r mydir:</b> Delete the directory mydir and its contents</li>
                            <li><b>rm -rf /path/to/directory:</b> Force delete a directory and its contents without confirmation</li>
                        </ul>

                        <h3>touch (Create an Empty File)</h3>
                        <p>Creates an empty file or updates the timestamp of an existing file.</p>

                        <b>Usage: touch newfilename</b>

                        <b>Examples:</b>
                        <ul>
                            <li><b>touch newfile.txt:</b> Create a new empty file called newfile.txt</li>
                            <li><b>touch existingfile.txt:</b> Update the modification date of existingfile.txt</li>
                        </ul>

                        <h3>mkdir (Make Directory)</h3>
                        <p>Creates a new directory.</p>

                        <b>Usage:</b>
                        <ul>
                            <li><b>mkdir directoryname:</b> Creates a new directory.</li>
                            <li><b>mkdir -p /path/to/newdir:</b> Creates parent directories if they don’t exist.</li>
                        </ul>

                        <b>Examples:</b>
                        <ul>
                            <li><b>mkdir myfolder:</b> Create a directory called myfolder</li>
                            <li><b>mkdir -p /home/user/projects/mydir:</b> Create the directory mydir along with any necessary parent directories</li>
                        </ul>

                        <h3>cat, less, more, tail</h3>
                        <b>Usage:</b>
                        <ul>
                            <li><b>cat:</b> Displays the entire content of the file.</li>
                            <li><b>less:</b> Displays the file content in pages, allowing forward and backward navigation.</li>
                            <li><b>more:</b> Similar to less, but with fewer features.</li>
                            <li><b>tail:</b> shows the last ten lines of a file.</li>
                            <li><b>grep:</b> search for a string within a file</li>
                        </ul>
                        <b>Examples:</b>
                        <ul>
                            <li><b>cat:</b> students.txt</li>
                            <li><b>less:</b> students.txt</li>
                            <li><b>more:</b> students.txt</li>
                            <li><b>tail:</b> students.txt</li>
                            <li><b>grep</b> bob /home/students.txt</li>
                        </ul>

                        <h3>Using Wildcards for Batch Operations</h3>
                        <p>Wildcards can help manage multiple files efficiently:</p>
                        <ul>
                            <li><b>* :</b> Matches any number of characters.</li>
                            <li><b>? :</b> Matches a single character.</li>
                        </ul>
                        <b>Usage:</b>
                        <p>Copy all .txt files from one directory to another: cp *.txt /path/to/destination/</p>
                        <b>Example:</b>
                        <p>cp *.txt /home/john/Documents</p>
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week1day4exercises')">Exercises</button>
                            <div id="week1day4exercises" class="dropdown-content">
                                <p>Here are 10 exercises that you can do to practice navigating the file system and performing file operations in Linux:</p>
                                <h3>Exercise 1: Navigating Directories</h3>
                                <p>Practice moving between directories.</p>
                                <b>Steps:</b>
                                <ul>
                                    <li>Open the terminal.</li>
                                    <li>Navigate to the /etc directory.</li>
                                    <li>From there, move into the apt subdirectory.</li>
                                    <li>Go back to the parent /etc directory.</li>
                                    <li>Finally, return to your home directory.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>cd</li>
                                    <li><b>cd .. :</b> parent directory</li>
                                    <li><b>cd ~ :</b> home directory</li>
                                </ul>

                                <h3>Exercise 2: Creating and Navigating Directories</h3>
                                <p>Create directories and practice navigating them.</p>
                                <b>Steps:</b>
                                <ul>
                                    <li>In your home directory, create a folder called practice.</li>
                                    <li>Inside practice, create a folder called test1.</li>
                                    <li>Inside test1, create a folder called test2.</li>
                                    <li>Navigate to test2 and then back to the practice directory.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>mkdir</li>
                                    <li>cd</li>
                                </ul>

                                <h3>Exercise 3: Listing and Understanding Directory Contents</h3>
                                <p>Use different options of the ls command to view directory contents.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>Navigate to /var/log.</li>
                                    <li>List the contents of the directory in long format.</li>
                                    <li>List all files, including hidden ones, in the /home directory.</li>
                                    <li>List files in the /bin directory in human-readable format.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>ls</li>
                                    <li>ls -l</li>
                                    <li>ls -a</li>
                                    <li>ls -lh</li>
                                </ul>

                                <h3>Exercise 4: Creating Empty Files</h3>
                                <p>Practice creating files.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>In your practice directory, create three empty files: file1.txt, file2.txt, and file3.txt.</li>
                                    <li>Verify that they were created by listing the contents of the directory.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>touch</li>
                                    <li>ls</li>
                                </ul>

                                <h3>Exercise 5: Copying Files</h3>
                                <p>Copy files from one location to another.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>Copy the file1.txt you created in the previous exercise to your home directory.</li>
                                    <li>In your practice directory, create a folder called backup.</li>
                                    <li>Copy all .txt files from the practice directory into the backup folder.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>cp</li>
                                    <li>cp *.txt /path/to/destination</li>
                                </ul>

                                <h3>Exercise 6: Moving and Renaming Files</h3>
                                <p>Move and rename files.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>In your practice directory, rename file2.txt to renamed_file.txt.</li>
                                    <li>Move file3.txt into the backup folder.</li>
                                    <li>Verify that the move was successful by listing the contents of backup.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>mv</li>
                                    <li>ls</li>
                                </ul>

                                <h3>Exercise 7: Removing Files and Directories</h3>
                                <p>Remove files and directories.</p>
                                <b>Steps:</b>
                                <ul>
                                    <li>In your practice directory, delete the file renamed_file.txt.</li>
                                    <li>Delete the entire backup directory and all its contents.</li>
                                    <li>Confirm that the files and directory have been removed by listing the contents of practice.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>rm</li>
                                    <li>rm -r</li>
                                </ul>

                                <h3>Exercise 8: Viewing the Current Directory</h3>
                                <p>Practice using pwd to find out where you are in the filesystem.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>Navigate to /usr/bin.</li>
                                    <li>Use pwd to display your current location.</li>
                                    <li>Move to /var and again use pwd to verify your location.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>cd</li>
                                    <li>pwd</li>
                                </ul>

                                <h3>Exercise 9: Working with Hidden Files</h3>
                                <p>Create, view, and remove hidden files.</p>

                                <b> Steps:</b>
                                <ul>
                                    <li>In your home directory, create a hidden file called .hiddenfile.</li>
                                    <li>List all files in the home directory, including hidden ones.</li>
                                    <li>Delete .hiddenfile.</li>
                                </ul>
                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>touch .hiddenfile</li>
                                    <li>ls -a</li>
                                    <li>rm</li>
                                </ul>

                                <h3>Exercise 10: Working with Nested Directories</h3>
                                <p>Create and manipulate nested directories.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>In your home directory, create a nested directory structure: parent/child/grandchild.</li>
                                    <li>Navigate into grandchild.</li>
                                    <li>Use a single command to delete the entire parent directory and all its subdirectories.</li>
                                    <li>Verify that the directories were deleted.</li>
                                </ul>

                                <b>Commands you'll need:</b>
                                <ul>
                                    <li>mkdir -p</li>
                                    <li>cd</li>
                                    <li>rm -r</li>
                                </ul>
                                <p>These exercises will help you build confidence in navigating directories and performing common file operations on a Linux system.</p>

                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week1day5')">Day 5</button>
                <div id="week1day5" class="dropdown-content">
                    <div class="day-title">Basic Text Editors in Linux</div>
                    <div class="day-info">
                        <p>Linux comes with several text editors that allow users to create and edit text files directly from the command line. The two most popular ones are nano and vim. Each editor has its own strengths, and learning how to use them will greatly improve your ability to manage configuration files and scripts.</p>
                        <b>1. Nano: A Beginner-Friendly Text Editor</b>
                        <p>Nano is a simple, easy-to-use text editor that is ideal for beginners.
                        It provides a user-friendly interface with a helpful command list at the bottom of the screen.
                        You can edit configuration files, scripts, or write documents without needing to learn complex commands.</p>

                        <h3>Install:</h3>
                        <ul>
                            <li><b>sudo apt install nano:</b> Debian/Ubuntu</li>
                            <li><b>sudo yum install nano:</b>  CentOS/Fedora</li>
                        </ul>

                        <b>How to Start Nano</b>
                        <ul>
                            <li>nano filename.txt</li>
                            <li>If the file exists, it will be opened for editing.</li>
                            <li>If the file doesn’t exist, it will be created and opened.</li>
                        </ul>
                        <b>Basic Commands in Nano</b>
                        <ul>
                            <li>Use the arrow keys to move around the file.</li>
                            <li>Start typing! There’s no separate "edit mode."</li>
                            <li>Press Ctrl + O (for “Output”) to save the file.</li>
                            <li>Press Enter to confirm the file name.</li>
                            <li>Press Ctrl + X to exit.</li>
                            <li>If there are unsaved changes, nano will prompt you to save before exiting.</li>
                        </ul>
                        <b>Search for Text:</b>
                        <ul>
                            <li>Press Ctrl + W, then type the search term and hit Enter.</li>
                            <li>Common Nano Commands (found at the bottom of the editor):</li>
                        </ul>
                        <b>Command	Functions:</b>
                        <ul>
                            <li><b>Ctrl + O:</b> Save (Write out) the file</li>
                            <li><b>Ctrl + X:</b> Exit nano</li>
                            <li><b>Ctrl + K:</b> Cut a line</li>
                            <li><b>Ctrl + U:</b> Paste a line</li>
                            <li><b>Ctrl + W:</b> Search for a string in the text</li>
                        </ul>

                        <h3>2. Vim: A Powerful, Advanced Text Editor</h3>
                        <p>Vim is a highly configurable and powerful text editor. It has a steeper learning curve compared to nano, but it provides advanced functionality for efficient text manipulation.
                            Vim operates in different modes:</p>
                        <ul>
                            <li><b>Normal mode:</b> Default mode for navigation and executing commands.</li>
                            <li><b>Insert mode:</b> For typing and editing text.</li>
                            <li><b>Command-line mode:</b> For saving, quitting, and executing other commands.</li>
                        </ul>

                        <b>How to Start Vim</b>
                        <p>This is similer to nano type: vim filename.txt</p>

                        <h3>Install:</h3>
                        <ul>
                            <li><b>sudo apt-get install vim:</b> Most Linux distributions</li>
                            <li><b>sudo pacman -S vim:</b> For arch-based distros</li>
                        </ul>


                        <h3>Basic Vim Commands</h3>

                        <h3>Switch to Insert Mode:</h3>
                        <ul>
                            <li>Press i to start editing (you’ll see -- INSERT -- at the bottom).</li>
                        </ul>

                        <h3>Switch to Normal Mode:</h3>
                        <ul>
                            <li>Press Esc to return to Normal Mode.</li>
                        </ul>

                        <h3>Saving and Quitting:</h3>
                        <ul>
                            <li>In Normal Mode, type :w to save the file (write).</li>
                            <li>Type :q to quit Vim.</li>
                            <li>To save and quit at the same time: :wq.</li>
                            <li>To quit without saving: :q!.</li>
                        </ul>

                        <h3>Navigating in Normal Mode:</h3>
                        <ul>
                            <li>Move the cursor with h (left), j (down), k (up), l (right).</li>
                            <li>Move to the beginning of a line with 0.</li>
                            <li>Move to the end of a line with $.</li>
                            <li>Move to the top of the file with gg and to the bottom with G.</li>
                        </ul>

                        <h3>Common Vim Commands:</h3>
                        <ul>
                            <li><b>i :</b> Switch to Insert mode</li>
                            <li><b>Esc :</b> Switch back to Normal mode</li>
                            <li><b>:w :</b> Save the file</li>
                            <li><b>:q :</b> Quit Vim</li>
                            <li><b>:wq :</b> Save and quit</li>
                            <li><b>:q! :</b> Quit without saving</li>
                            <li><b>x :</b> Delete the character under the cursor</li>
                            <li><b>dw :</b> Delete the word under the cursor</li>
                            <li><b>u :</b> Undo the last change</li>
                            <li><b>/</b> Search for text</li>
                            <li><b>dd :</b> Delete the current line</li>
                            <li><b>p :</b> Paste the last deleted text</li>
                        </ul>

                        <h3>Choosing Between Nano and Vim</h3>
                        <p>I personally use nano when using editors, it is easy to use, but i think vim can be easy once you start using it. Vim is considered more advanced then nano. By practicing with both editors, you'll become comfortable with editing files in a variety of environments and workflows.</p>


                        <div class="dropdown">
                            <button onclick="toggleDropdown('week1day5exercises')">Exercises</button>
                            <div id="week1day5exercises" class="dropdown-content">
                                <h3>Nano Exercises</h3>
                                <h3>Nano Exercise 1: Basic Text Editing</h3>
                                <p>Learn to create, edit, and save files using Nano.</p>
                                <h3>Steps:</h3>
                                <ul>
                                    <li>Open a new file called notes.txt using Nano</li>
                                </ul>
                                <h4>In the file type the following content:</h4>
                                <ul>
                                    <li>Nano is a simple text editor.</li>
                                    <li>It is easy to use.</li>
                                    <li>This is a practice exercise.</li>
                                </ul>

                                <h4>After typing the text, save the file:</h4>
                                <ul>
                                    <li>Press Ctrl + O (to save) and then Enter to confirm the file name.</li>
                                    <li>Press Ctrl + X.</li>
                                </ul>

                                <h3>Nano Exercise 2: Searching, Cutting, and Pasting Text</h3>
                                <p>Practice searching, cutting, and pasting text within a file.</p>

                                <h3>Steps:</h3>
                                <ul>
                                    <li>Open the file notes.txt:</li>
                                </ul>

                                <p>Search for the word "practice":</p>
                                <ul>
                                    <li>Press Ctrl + W, type "practice", and press Enter.</li>
                                </ul>

                                <p>Once you've found the word, cut the entire line containing "This is a practice exercise.":</p>
                                <ul>
                                    <li>Press Ctrl + K to cut the line.</li>
                                </ul>

                                <p>Move to the top of the file (using the arrow keys) and paste the line at the top:</p>
                                <ul>
                                    <li>Press Ctrl + U to paste.</li>
                                </ul>

                                <p>Save and exit the file:</p>
                                <ul>
                                    <li>Press Ctrl + O, Enter, and then Ctrl + X.</li>
                                </ul>

                                <h3>Vim Exercises</h3>

                                <h3>Vim Exercise 1: Basic Navigation and Editing</h3>

                                <p>Get familiar with navigating and editing a file in Vim.</p>

                                <b>Steps:</b>
                                <ul>
                                    <li>Open a new file called todo.txt using Vim</li>
                                </ul>
                                <p>Press i to enter Insert Mode, then type the following tasks:</p>
                                <ul>
                                    <li>Buy groceries</li>
                                    <li>Complete Linux homework</li>
                                    <li>Call mom</li>
                                    <li>Exercise for 30 minutes</li>
                                </ul>
                                <p>Press Esc to return to Normal Mode.</p>
                                <b>Save the file and exit Vim:</b>
                                <ul>
                                    <li>Type :wq and press Enter.</li>
                                </ul>

                                <h3>Vim Exercise 2: Delete, Undo, and Search</h3>
                                <p>Practice using deletion, undo, and search features in Vim.</p>
                                <h3>Steps:</h3>
                                <ul>
                                    <li>Open the file todo.txt</li>
                                </ul>

                                <p>In Normal Mode, delete the second line (the one that says "Complete Linux homework"):</p>
                                <ul>
                                    <li>Move the cursor to the second line and type dd.</li>
                                </ul>

                                <p>Undo the deletion:</p>
                                <ul>
                                    <li>Type u to undo.</li>
                                </ul>
                                <p>Search for the word "Exercise":</p>
                                <ul>
                                    <li>Type /Exercise and press Enter.</li>
                                </ul>

                                <p>Once you've found the word, move to Insert Mode (press i) and add "outdoors" after "Exercise". Save and exit:</p>
                                <ul>
                                    <li>Press Esc, then type :wq and hit Enter.</li>
                                </ul>
                                <p>These exercises will help you get comfortable with both nano and vim, building skills for basic text editing, navigation, and file manipulation in the Linux environment.</p>

                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Exercises, Quiz, and Answers -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week1review')">Week Review</button>
                <div id="week1review" class="dropdown-content">
                    <div class="day-title">Week 1 Review</div>
                    <div class="day-info">
                        <h3>Week One Review: Introduction to Linux Fundamentals</h3>
                        <p>Week one of our Linux course covers essential concepts and skills to build a solid foundation in Linux. Let’s recap each major topic and review the key takeaways:</p>

                        <h3>1. History of Linux and Its Distributions</h3>
                        <p>Background: Linux, created by Linus Torvalds in 1991, was inspired by Unix, a powerful operating system used in academic and corporate settings. Linux grew with the help of the open-source community, evolving into a robust OS for servers, desktops, and embedded systems.</p>

                        <p>Distributions (Distros): Linux comes in different flavors (distributions) like Ubuntu, Fedora, Debian, CentOS, and Arch Linux. Each has unique features, package managers, and use cases:</p>
                        <ul>
                            <li><b>Ubuntu:</b> User-friendly, great for beginners and widely supported.</li>
                            <li><b>Fedora:</b> Often on the cutting edge with the latest software.</li>
                            <li><b>Debian:</b> Known for stability, often used as a base for other distros (like Ubuntu).</li>
                            <li><b>CentOS:</b> A stable choice for servers, based on Red Hat Enterprise Linux.</li>
                            <li><b>Arch Linux:</b> Highly customizable, appealing to advanced users.</li>
                        </ul>
                        <p>Linux's open-source nature led to a wide variety of distributions tailored for different users and needs.</p>

                        <h3>2. Installation and Setup</h3>
                        <p>Setting up Linux involves choosing a distribution, creating installation media, and configuring the system.</p>

                        <p>Creating Installation Media: You can use tools like Balena Etcher to make a bootable USB drive from an ISO file.
                        Installation Process: This involves selecting disk partitions, choosing a username, password, and configuring system settings.</p>
                        
                        <h3>First Boot and Basic Setup:</h3>
                        <ul>
                            <li>Update your system for the latest patches and packages.</li>
                            <li>Configure essential settings like network, users, and time zone.</li>
                        </ul>
                        <p>Installing Linux is straightforward with tools and guided installers, allowing you to personalize your setup for optimal performance.</p>

                        <h3>3. Linux File System Structure</h3>
                        <p>The Linux file system is organized in a hierarchical directory structure, beginning from the root directory (/). Key directories include:</p>
                        <ul>
                            <li><b>/home:</b> Stores user files and personal configurations.</li>
                            <li><b>/bin and /sbin:</b> Contain essential system binaries (programs).</li>
                            <li><b>/etc:</b> Holds configuration files for system-wide settings.</li>
                            <li><b>/var:</b> Stores log files and variable data.</li>
                            <li><b>/usr:</b> Contains user applications and files.</li>
                            <li><b>/tmp:</b> Temporary files are stored here, and they are often cleared on reboot.</li>
                        </ul>
                        <p>Understanding the Linux directory structure is crucial for navigating and managing files effectively.</p>

                        <h3>4. Basic Commands</h3>

                        <p>Learning a few core commands helps you navigate and manipulate files in Linux:</p>
                        <h3>Navigation:</h3>
                        <ul>
                            <li><b>cd:</b> Change directory.</li>
                            <li><b>ls:</b> List files and directories.</li>
                            <li><b>pwd:</b> Print the working directory.</li>
                        </ul>
                        <h3>File Operations:</h3>
                        <ul>
                            <li><b>cp:</b> Copy files.</li>
                            <li><b>mv:</b> Move (or rename) files.</li>
                            <li><b>rm:</b> Delete files.</li>
                            <li><b>mkdir:</b> Create a new directory.</li>
                            <li><b>touch:</b> Create a new, empty file.</li>
                        </ul>

                    <p>Familiarity with basic commands helps you perform day-to-day tasks and manage the file system from the command line.</p>

                    <h3>5. Basic Text Editors: Introduction to Nano and Vim</h3>

                    <p>Text editors in Linux allow you to create and edit files directly from the terminal. Two popular editors are:</p>
                    <b>Nano:</b>
                    <ul>
                        <li>User-friendly, suitable for beginners with simple navigation using on-screen prompts.</li>
                        <li>Key shortcuts: O to save, X to exit.</li>
                    </ul>

                    <b>Vim:</b>
                    <ul>
                        <li>A more advanced, modal editor with powerful features for efficient text manipulation.</li>
                        <li>Modes: i for Insert Mode, Esc to return to Command Mode.</li>
                        <li>Key commands: :w to save, :q to quit, :wq to save and quit.</li>
                    </ul>
                    <p>Nano and Vim gives you flexibility in editing system files and scripts, an essential skill for Linux administration.</p>

                    </div>
                </div>
            </div>
            
            <div class="dropdown">
                <button onclick="toggleDropdown('week1quiz')">Quiz</button>
                <div id="week1quiz" class="dropdown-content">
                    <div class="day-title">Week 1 Quiz: Introduction to Linux Fundamentals</div>
                    <div class="day-info">
                        <p>Below is a 10-question quiz to test knowledge from Week 1 of the course. Each question has 4 multiple-choice options, with the correct answer in the answers section.</p>

                        <h3>1. What is Linux?</h3>
                        <ul>
                            <li>a) A type of software application</li>
                            <li>b) An operating system kernel</li>
                            <li>c) A programming language</li>
                            <li>d) A file manager</li>
                        </ul>

                        <h3>2. Which of the following is NOT a Linux distribution?</h3>
                        <ul>
                            <li>a) Ubuntu</li>
                            <li>b) CentOS</li>
                            <li>c) Windows</li>
                            <li>d) Fedora</li>
                        </ul>

                        <h3>3. What does the /etc directory typically contain?</h3>
                        <ul>
                            <li>a) User home directories</li>
                            <li>b) Temporary files</li>
                            <li>c) System configuration files</li>
                            <li>d) Kernel modules</li>
                        </ul>

                        <h3>4. Which command is used to display the current working directory?</h3>
                        <ul>
                            <li>a) pwd</li>
                            <li>b) ls</li>
                            <li>c) cd</li>
                            <li>d) touch</li>
                        </ul>

                        <h3>5. What does the ls command do?</h3>
                        <ul>
                            <li>a) Displays the current directory path</li>
                            <li>b) Creates a new file</li>
                            <li>c) Lists the contents of a directory</li>
                            <li>d) Changes to a new directory</li>
                        </ul>

                        <h3>6. What is the default text editor in most Linux distributions?</h3>
                        <ul>
                            <li>a) nano</li>
                            <li>b) vim</li>
                            <li>c) emacs</li>
                            <li>d) It varies depending on the distribution</li>
                        </ul>

                        <h3>7. What does the chmod command do?</h3>
                        <ul>
                            <li>a) Changes ownership of a file</li>
                            <li>b) Changes file permissions</li>
                            <li>c) Moves files between directories</li>
                            <li>d) Deletes files</li>
                        </ul>

                        <h3>8. Which directory is the root of the Linux file system?</h3>
                        <ul>
                            <li>a) /root</li>
                            <li>b) /etc</li>
                            <li>c) /</li>
                            <li>d) /bin</li>
                        </ul>

                        <h3>9. Which command is used to create a new directory?</h3>
                        <ul>
                            <li>a) mkdir</li>
                            <li>b) rmdir</li>
                            <li>c) touch</li>
                            <li>d) cd</li>
                        </ul>

                        <h3>10. What is the purpose of the man command?</h3>
                        <ul>
                            <li>a) To rename files</li>
                            <li>b) To display the manual page for a command</li>
                            <li>c) To search for files</li>
                            <li>d) To create user accounts</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week1answers')">Quiz Answers</button>
                <div id="week1answers" class="dropdown-content">
                    <div class="day-title">Week 1 Quiz Answers: Introduction to Linux Fundamentals</div>
                    <div class="day-info">
                        <p>Answers:</p>

                        <h3>1. What is Linux?</h3>
                        <b>Answer: b) An operating system kernel</b>

                        <h3>2. Which of the following is NOT a Linux distribution?</h3>
                        <b>Answer: c) Windows</b>

                        <h3>3. What does the /etc directory typically contain?</h3>
                        <b>Answer: c) System configuration files</b>

                        <h3>4. Which command is used to display the current working directory?</h3>
                        <b>Answer: a) pwd</b>

                        <h3>5. What does the ls command do?</h3>
                        <b>Answer: c) Lists the contents of a directory</b>

                        <h3>6. What is the default text editor in most Linux distributions?</h3>
                        <b>Answer: d) It varies depending on the distribution</b>

                        <h3>7. What does the chmod command do?</h3>
                        <b>Answer: b) Changes file permissions</b>

                        <h3>8. Which directory is the root of the Linux file system?</h3>
                        <b>Answer: c) /</b>

                        <h3>9. Which command is used to create a new directory?</h3>
                        <b>Answer: a) mkdir</b>

                        <h3>10. What is the purpose of the man command?</h3>
                        <b>Answer: b) To display the manual page for a command</b>
                       
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Week 2 -->
    <div class="dropdown">
        <button onclick="toggleDropdown('week2')">Week 2</button>
        <div id="week2" class="dropdown-content">
            <!-- Days -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week2day1')">Day 1</button>
                <div id="week2day1" class="dropdown-content">
                    <div class="day-title">Advanced File Operations</div>
                    <div class="day-info">
                        <p>Permissions and Ownership (chmod, chown)</p>
                        <p>Linux file types serve not only as classifications but also influence how files function within the system. 
                            Regular files store data, while directories, visually similar to folders, help manage and organize these files. 
                            Symbolic links act as pointers or shortcuts to other files or directories. 
                            Block and character devices correspond to hardware, with block devices allowing random-access I/O operations and character devices supporting sequential-access I/O. 
                            Sockets facilitate communication between processes, and pipes enable sequential data flow between them.</p>

                        <h3>1. Understanding File Permissions</h3>
                        <p>File permissions in Linux are a key security mechanism, providing detailed control over who can access or modify files. 
                            These permissions can be combined to offer different levels of access.
                            For instance, read permission lets a user view the file's content, write permission allows modifications, and execute permission enables the file to be run as a program. 
                            In the case of directories, execute permission permits users to list or access the directory's contents, with slightly different effects than for files.</p>

                        <p>In Linux, ownership plays a key role in resource sharing and managing permissions. 
                            Every file is linked to a user (the owner) and a group. 
                            The user is typically the file's creator or the one who last modified it, while groups consist of multiple users who share access rights. 
                            Knowing how to modify file ownership and group associations using the chown and chgrp commands is essential for controlling access to files and directories effectively.</p>

                        
                        <p>In Linux, every file and directory has three sets of permissions for three categories of users:</p>
                        <ul>
                            <li>Owner: The user who owns the file.</li>
                            <li>Group: The group that owns the file.</li>
                            <li>Others: All other users on the system.</li>
                        </ul>
                        <p>Permissions are represented as:</p>
                        <ul>
                            <li>r: Read (4)</li>
                            <li>w: Write (2)</li>
                            <li>x: Execute (1)</li>
                        </ul>
                        <p>Each file's permissions are shown as a series of 10 characters:</p>
                        <ul>
                            <li>-rwxr-xr--</li>
                        </ul>
                        <p>The first character represents the type of file (- for regular files, d for directories), and the remaining nine characters represent the read, write, and execute permissions for the owner, group, and others.</p>

                        <h3>2. Changing Permissions with chmod</h3>
                        <p>The chmod command is used to change the permissions of a file or directory.</p>

                        <h3>Using Symbolic Notation:</h3>
                        <ul>
                            <li>u: User (owner)</li>
                            <li>g: Group</li>
                            <li>o: Others</li>
                            <li>a: All (user, group, others)</li>
                        </ul>

                        <b>Examples:</b>
                        <p>Give the owner execute permissions:</p>
                        <ul>
                            <li>chmod u+x filename</li>
                        </ul>

                        <p>Remove write permissions for the group:</p>
                        <ul>
                            <li>chmod g-w filename</li>
                        </ul>

                        <b>Using Numeric Notation:</b>
                        <p>Each permission is represented by a number:</p>

                        <p>r = 4, w = 2, x = 1.</p>

                        <p>You can sum these numbers to set permissions:</p>
                        <ul>
                            <li>7 (rwx) = read (4) + write (2) + execute (1).</li>
                            <li>6 (rw-) = read (4) + write (2).</li>
                        </ul>

                        <b>Example:</b>
                        <p>To give the owner full permissions (rwx), group read and execute (r-x), and others read-only (r--):</p>
                        <ul>
                            <li>chmod 754 filename</li>
                        </ul>

                        <h3>3. Changing Ownership with chown</h3>

                        <p>The chown command is used to change the ownership of a file or directory.</p>
                        <ul>
                            <li>Syntax: chown owner:group filename</li>
                        </ul>

                        <b>Examples:</b>
                        <p>Change the owner of file.txt to john:</p>
                        <ul>
                            <li>chown john file.txt</li>
                        </ul>
                        <p>Change both the owner and the group:</p>
                        <ul>
                            <li>chown john:developers file.txt</li>
                        </ul>

                        <h3>4. Changing Group Ownership with chgrp</h3>
                        <p>The chgrp command can be used to change the group ownership of a file:</p>
                        <ul>
                            <li>chgrp group_name filename</li>
                        </ul>

                        <b>layman's Terms</b>

                        <p>Now, imagine there are three groups of people who can come to your house (use your file):</p>
                        <ul>
                            <li>You (the owner): You are the boss of your house!</li>
                            <li>Your friends (the group): These are some friends who can come into your house but might not have full access.</li>
                            <li>Others (everyone else): Strangers who live nearby — they can only do what you allow.</li>
                        </ul>

                        <p>So, when we talk about file permissions, we're talking about who can read, write, or execute files. Each file has permissions set for you (owner), your group of friends, and everyone else.</p>

                        <p>Let’s say you have a file called security.txt. You want:</p>
                        <ul>
                            <li>Only you to be able to write (change) it.</li>
                            <li>Your friends to be able to read it.</li>
                            <li>Strangers not to see it at all.</li>
                        </ul>

                        <p>The permissions could be like this:</p>
                        <ul>
                            <li>-rw-r----- security.txt</li>
                        </ul>
                        
                        <p>-rw-r----- means:</p>
                        <ul>
                            <li>Owner (you): Can read and write (rw-).</li>
                            <li>Group (friends): Can only read (r--).</li>
                            <li>Others (strangers): Cannot do anything (---).</li>
                        </ul>

                        <p>Now, let’s talk about ownership. Just like a house has an owner, every file on your computer has someone who "owns" it. The owner of a file is usually the person who created it, but you can also change who owns a file if you want.</p>

                        <p>There are two parts to ownership:</p>
                        <ul>
                            <li>Owner: Who owns the file.</li>
                            <li>Group: A group of people (friends) who also have some access.</li>
                        </ul>

                        <p>Let’s say you create a file called game.txt, and you’re the owner. But now, you want to let your friend Emma be the new owner. You can do this by changing the ownership using the chown command.</p>

                        <p>Command:</p>
                        <ul>
                            <li>chown emma game.txt</li>
                        </ul>

                        <p>What happens:</p>
                        <ul>
                            <li>Now, Emma is the new owner of the file game.txt!</li>
                        </ul>
                        <p>You can also change the group (your group of friends) who can access the file. Let’s say you have a group called school that can access the file</p>

                        <p>Command:</p>
                        <ul>
                            <li>chown emma:school game.txt</li>
                        </ul>
                        <p>What happens:</p>
                        <ul>
                            <li>Now, Emma owns the file, and the school group is the group that can access it!</li>
                        </ul>
                        <p>Imagine you have a treasure map file, and you want:</p>
                        <ul>
                            <li>Only you (the owner) to see it and edit it.</li>
                            <li>Your friends to only be able to look at it (but not edit).</li>
                            <li>Everyone else to have no access at all.</li>
                        </ul>

                        <p>Here’s how it would look:</p>
                        <ul>
                            <li>chmod 740 treasure_map.txt</li>
                        </ul>

                        <p>This number, 740, breaks down like this:</p>
                        <ul>
                            <li>Owner (7 = rwx): You can read, write, and run the file.</li>
                            <li>Group (4 = r--): Your friends can only read the file.</li>
                            <li>Others (0 = ---): Strangers can’t do anything.</li>
                        </ul>

                        <h3>Links (Hard and Symbolic Links)</h3>

                        <b>1. Hard Links</b>
                        <ul>
                            <li>A hard link is an additional name for an existing file. Multiple hard links can point to the same file on disk, meaning they share the same inode number.</li>
                            <li>If you delete a file with a hard link, the link remains, and the data is not deleted until all hard links to that file are removed.</li>
                            <li>Creating a Hard Link: ln original_file link_name</li>
                        </ul>

                        <b>Example:</b>
                        <ul>
                            <li>ln file1.txt file1_hardlink.txt</li>
                        </ul>
                        <p>Inodes are a distinctive element of the Linux file system, storing metadata about files separately from the actual file data. This metadata includes details such as the file's size, ownership, permissions, and the disk locations of the file’s data blocks.</p>

                        <p>Features of Hard Links:</p>
                        <ul>
                            <li> The file’s contents are accessible via both the original file and the hard link.</li>
                            <li>Hard links cannot span across different file systems or partitions.</li>
                            <li>If the original file is deleted, the hard link still provides access to the file contents.</li>
                        </ul>

                        <h3>2. Symbolic (Soft) Links</h3>
                        <p>A symbolic link (also called a soft link or symlink) is a pointer to another file or directory. Unlike hard links, symlinks can point to files on different file systems, but they break if the target file is deleted.</p>

                        <p>Creating a Symbolic Link:</p>
                        <ul>
                            <li> ln -s original_file link_name</li>
                        </ul>

                        <p>Example:</p>
                        <ul>
                            <li>ln -s /path/to/file1.txt symlink.txt</li>
                        </ul>
                        <p>Features of Symbolic Links:</p>
                        <ul>
                            <li>A symbolic link can point to files or directories across different file systems.</li>
                            <li>If the original file is deleted or moved, the symlink becomes broken (it will still exist, but points to a non-existent file).</li>
                            <li>Symbolic links are indicated with an arrow (->) when listed with ls -l.</li>
                        </ul>
                        <p>Users can effectively manage files, control access, and create links for better file organization in a Linux environment.</p>


                        <h3>Laymen's Terms</h3>
                        <b>Hard Links</b>

                        <p>Imagine you have a watch. Now, let’s say you could duplicate the watch so that there are two identical ones, but both toys are connected. It doesn’t matter which watch you were — they’re exactly the same, and if one gets scratched or broken, the other one does too.</p>

                        <p>This is what a hard link does in the computer! When you create a hard link, you’re making another name for a file, and both names point to the same file data. If you change the file through either name, the changes appear everywhere because it’s really the same file with different names.</p>

                        <b>Example:</b>
                        <p>You have a file called security.txt. Now, you want to make a hard link to this file, so it has a second name, but it’s still the same file.</p>
                        <p>Command:</p>
                        <ul>
                            <li>ln security.txt new_security.txt</li>
                        </ul>

                        <p>Now, both security.txt and new_security.txt are the same file! If you open new_security.txt and make changes, the same changes will show up in security.txt, because they are connected.</p>
                        <p>If you delete security.txt, don’t worry! new_security.txt still works because the actual file data is still there.</p>

                        <h3>Symbolic Links (Symlinks)</h3>
                        <p>Now, imagine you want to give your friend a map to your favorite secret spot in the park (your file). Instead of making another version of the spot (like a hard link), you just give them a shortcut to find it. If the spot moves (or you delete it), your map will lead to nothing because the place is gone.</p>
                        <p>This is what a symbolic link (or symlink) does! It’s like a shortcut on your computer that points to another file or folder. If the original file is deleted or moved, the symlink breaks and no longer works.</p>

                        <p>You have a file called book.txt in your Documents folder, but you want to access it from your Desktop. Instead of moving the file, you can create a symbolic link (a shortcut) on the Desktop that points to the file in Documents.</p>

                        <b>Command:</b>
                        <p>ln -s /home/user/Documents/book.txt /home/user/Desktop/book_link.txt</p>
                        <p>Now, book_link.txt on your Desktop is just a pointer to the real book.txt in your Documents folder. If you open book_link.txt, it takes you to the real book.txt. But if you delete or move book.txt, the shortcut stops working.</p>
                        <p>Comparing Hard Links and Symbolic Links</p>

                        <b>1. Hard Links:</b>
                        <ul>
                            <li>Like a clone of the file — both names point to the same file data.</li>
                            <li>If you delete one of the hard links, the other one still works because the file data is still there.</li>
                            <li>Hard links can’t work across different drives or partitions (like different parts of a computer’s memory).</li>
                        </ul>

                        <p>Hard Link Example:</p>
                        <ul>
                            <li>You create a hard link of security.txt: ln security.txt backup_security.txt</li>
                        </ul>
                        <p>Now, if you open backup_security.txt and write "Done!" in it, you will also see "Done!" in security.txt, because it’s really the same file.</p>

                        <b>2. Symbolic Links (Symlinks):</b>
                        <ul>
                            <li>Like a shortcut that points to another file.</li>
                            <li>If you delete the original file, the symlink becomes broken and doesn’t work anymore.</li>
                            <li>Symlinks can point to files across different drives or locations on your computer.</li>
                        </ul>

                        <p>Symbolic Link Example:</p>
                        <ul>
                            <li>You create a symlink of book.txt: ln -s /home/user/Documents/book.txt /home/user/Desktop/book_link.txt</li>
                            <li>If you delete book.txt, the book_link.txt on your Desktop no longer works because it’s just a pointer to the file that no longer exists.</li>
                        </ul>

                        <p><b>Hard Links</b> are like having multiple names for the same file. If one name is deleted, the file still exists under the other name. Changes made to the file through any link affect the same file data.</p>

                        <p><b>Symbolic Links</b> are like shortcuts that point to a file. If the original file is deleted or moved, the symlink doesn’t work anymore because it’s just a pointer.</p>


                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week2day2')">Day 2</button>
                <div id="week2day2" class="dropdown-content">
                    <div class="day-title">Searching and Finding Files</div>
                    <div class="day-info">
                        <h3>1. find: Search for Files and Directories</h3>
                        <p>The find command is like a treasure hunt! You can use it to search for files and directories based on different criteria like name, size, date modified, etc.</p>
                        <p>find /path/to/search -name "filename"</p>
                        <ul>
                            <li>/path/to/search: Where you want to start searching (e.g., /home/user/).</li>
                            <li>-name: You use this to search by the name of the file.</li>
                            <li>"filename": The file’s name (you can use wildcards like *.txt to find all .txt files).</li>
                        </ul>
                        <p>Find a file by name in your home folder:</p>
                        <ul>
                            <li>find /home/user -name "document.txt"</li>
                        </ul>
                        <p>Find all text files in a folder:</p>
                        <ul>
                            <li>find /home/user/Documents -name "*.txt"</li>
                        </ul>
                        <p>find / -size +50M</p>
                        <ul>
                            <li>This finds all files larger than 50 MB.</li>
                        </ul>
                        <p>Find files modified in the last 7 days:</p>
                        <ul>
                            <li>find /home/user -mtime -7</li>
                        </ul>
                        <p>This finds files that have been changed in the last 7 days.</p>

                        <h3>2. locate: Fast File Search (Database-based)</h3>
                        <p>The locate command is like using a search engine for your files. It works super fast because it searches through a pre-built database of all your files, rather than checking each folder in real-time like find does.</p>
                        <p>Basic Syntax:</p>
                        <ul>
                            <li>locate filename</li>
                            <li>locate homework.txt</li>
                        </ul>

                        <p>Find all .png files:</p>
                        <ul>
                            <li>locate *.png</li>
                        </ul>

                        <p>The locate command depends on a database, so if you’ve added or removed files recently, you might want to update the database with:</p>
                        <ul>
                            <li>sudo updatedb</li>
                        </ul>

                        <h3>3. grep: Search Inside Files</h3>
                        <p>The grep command is like using Ctrl+F in a document, but for your whole system! It searches inside files for specific text or patterns.</p>
                        <p>Basic Syntax:</p>
                        <ul>
                            <li>grep "search_term" filename</li>
                            <li>"search_term": The word or pattern you’re looking for inside the file.</li>
                            <li>filename: The file or files you want to search.</li>
                        </ul>
                        <b>Examples:</b>
                        <p>Find a word inside a specific file:</p>
                        <ul>
                            <li>grep tom /etc/passwd</li>
                            <li>This searches for the word "tom" in /rtc/passwd.</li>
                        </ul>

                        <p>Search through multiple files:</p>
                        <ul>
                            <li>grep "apple" *.txt</li>
                            <li>This searches for the word "apple" in all .txt files in the current directory.</li>
                        </ul>
                        <p>Search recursively through directories:</p>
                        <ul>
                            <li>grep -r "password" /etc/</li>
                            <li>This searches all files in the /etc/ directory for the word "password".</li>
                        </ul>

                        <h3>4. which: Find Executable Files (Programs)</h3>
                        <p>The which command is used to find where a program is installed or located. This is useful if you want to know where the system is keeping your command or program.</p>
                        <p>Basic Syntax:</p>
                        <ul>
                            <li>which program_name</li>
                        </ul>
                        <p>Example:</p>

                        <p>Find where the python3 executable is located:</p>
                        <ul>
                            <li>which python3</li>
                        </ul>
                        <p>This will return something like /usr/bin/python3, showing you where the Python program is located.</p>

                        <h3>5. whereis: Locate Programs and Their Files</h3>
                        <p>The whereis command not only tells you where a program is located but also shows you its manuals and source code (if available).</p>
                        <p>Basic Syntax:</p>
                        <ul>
                            <li>whereis program_name</li>
                        </ul>
                        <p>Example:</p>
                        <p>Find where the bash program and its related files are located:</p>
                        <p>whereis bash</p>
                        <ul>
                            <li>bash: /bin/bash /usr/share/man/man1/bash.1.gz</li>
                        </ul>

                        <div class="dropdown">
                            <button onclick="toggleDropdown('week2day2exercises')">Exercises</button>
                            <div id="week2day2exercises" class="dropdown-content">
                                <h3>Here are some practice exercises</h3>
                                <h3>Exercise 1: Creating and Finding Files</h3>
                                <p>Create a directory called practice_search in your home folder:</p>
                                <ul>
                                    <li>mkdir ~/practice_search</li>
                                </ul>
                                <p>Move into the directory:</p>
                                <ul>
                                    <li>cd ~/practice_search</li>
                                </ul>
                                <p>Create three text files named apple.txt, banana.txt, and cherry.txt using touch:</p>
                                <ul>
                                    <li>touch apple.txt banana.txt cherry.txt</li>
                                </ul>
                                <p>Use find to locate the file banana.txt inside the practice_search directory.</p>
                                <ul>
                                    <li>find . -name "banana.txt"</li>
                                </ul>

                                <h3>Exercise 2: Searching for Files by Pattern</h3>

                                <p>Create two more files: notes1.txt and notes2.txt in the practice_search directory:</p>
                                <ul>
                                    <li>touch notes1.txt notes2.txt</li>
                                </ul>
                                <p>Use find to search for all files that have the word "notes" in their name.</p>
                                <ul>
                                    <li>find . -name "notes*"</li>
                                </ul>

                                <h3>Exercise 3: Finding Files by Size</h3>
                                <p>Create a large file (let’s say 10 MB) inside the practice_search directory:</p>
                                <ul>
                                    <li>fallocate -l 10M largefile.txt</li>
                                </ul>
                                <p>Use find to search for files larger than 1 MB in size inside the practice_search directory.</p>
                                <ul>
                                    <li>find . -size +1M</li>
                                </ul>

                                <h3>Exercise 4: Locating Files Using locate</h3>
                                <p>Install the locate command (if it’s not already installed):</p>
                                <ul>
                                    <li>sudo apt update && sudo apt install mlocate</li>
                                </ul>
                                <p>Update the database:</p>
                                <ul>
                                    <li>sudo updatedb</li>
                                </ul>
                                <p>Use locate to search for files containing the word "apple" anywhere on your system.</p>
                                <ul>
                                    <li>locate apple</li>
                                </ul>

                                <h3>Exercise 5: Using grep to Find Text Inside Files</h3>
                                <p>Add some content to the file apple.txt:</p>
                                <ul>
                                    <li>echo "Apples are red and delicious!" > apple.txt</li>
                                </ul>

                                <p>Add some content to the file banana.txt:</p>
                                <ul>
                                    <li>echo "Bananas are yellow and healthy!" > banana.txt</li>
                                </ul>
                                <p>Use grep to find the word "yellow" in the files inside the practice_search directory.</p>
                                <ul>
                                    <li>grep "yellow" *</li>
                                </ul>

                                <h3>Exercise 6: Searching Recursively Using grep</h3>
                                <p>Inside the practice_search directory, create a subdirectory called subfolder:</p>
                                <ul>
                                    <li>mkdir subfolder</li>
                                </ul>
                                <p>Create a new text file called fruit_info.txt inside subfolder:</p>
                                <ul>
                                    <li>touch subfolder/fruit_info.txt</li>
                                </ul>

                                <p>Add some content to fruit_info.txt:</p>
                                <ul>
                                    <p>echo "Cherries are small and red." > subfolder/fruit_info.txt</p>
                                </ul>

                                <p>Use grep to search for the word "red" in all files within the practice_search directory and its subdirectories:</p>
                                <ul>
                                    <li>grep -r "red" .</li>
                                </ul>

                                <h3>Exercise 7: Combining find and grep</h3>
                                <p>find . -name "*.txt" -exec grep "yellow" {} \;</p>

                                <h3>Exercise 8: Creating and Using Symbolic Links</h3>
                                <p>Create a file called linkfile.txt in the practice_search directory:</p>
                                <ul>
                                    <li>touch linkfile.txt</li>
                                </ul>

                                <p>Create a symbolic link to linkfile.txt inside subfolder:</p>
                                <ul>
                                    <li>ln -s ~/practice_search/linkfile.txt ~/practice_search/subfolder/symlink.txt</li>
                                </ul>

                                <p>Use find to search for symbolic links in the practice_search directory:</p>
                                <ul>
                                    <li>find . -type l</li>
                                </ul>

                                <h3>Exercise 9: Finding Files Modified Recently</h3>
                                <p>Modify the apple.txt file:</p>
                                <ul>
                                    <li>echo "Apples are my favorite!" >> apple.txt</li>
                                </ul>

                                <p>Use find to search for files modified in the last 1 day (24 hours) inside the practice_search directory:</p>
                                <ul>
                                    <li>find . -mtime -1</li>
                                </ul>

                                <h3>Exercise 10: Using which and whereis</h3>
                                <p>Use which to find where the bash shell is installed on your system:</p>
                                <ul>
                                    <li>which bash</li>
                                </ul>

                                <p>Use whereis to find out where the python3 program and its manual are located:</p>
                                <ul>
                                    <li>whereis python3</li>
                                </ul>

                                

                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week2day3')">Day 3</button>
                <div id="week2day3" class="dropdown-content">
                    <div class="day-title">Introduction to Shell Scripting</div>
                    <div class="day-info">
                        <h3>1. Starting a Shell Script: The Shebang</h3>

                        <p>Every shell script starts with a shebang (#!), which tells the system which interpreter (or shell) to use to run the script. Most common shells are bash, sh, and zsh. For bash, the first line of the script should be:</p>
                        <ul>
                            <li>#!/bin/bash</li>
                        </ul>
                        <p>This tells the system to use the bash shell to run the script.</p>

                        <h3>2. Writing Commands in the Script</h3>
                        <p>After the shebang, you can write any normal Linux commands just like you would in the terminal. Each command is written on a new line. For example, a script that prints "Hello, World!" to the terminal and lists files in a directory would look like this:</p>
                        <p><b>#!/bin/bash<br>echo "Hello, World!"<br>ls</b></p>
                        <p>Example:</p>
                        <p><b>echo "Hello, World!": Prints "Hello, World!" to the terminal.<br>ls: Lists the files in the current directory.</b></p>

                        <h3>3. Variables in Shell Scripts</h3>
                        <p>You can define variables in a shell script to store values. Variables don’t need a type declaration, and there should be no spaces around the = sign.</p>
                        <ul>
                            <li><b>variable_name=value</b></li>
                        </ul>
                        <p>To use the value stored in a variable, prefix it with $:</p>
                        <p><b>#!/bin/bash<br>name="John"<br>echo "Hello, $name!"</b></p>
                        <p>Example:</p>
                        <p><b>name="John": Defines a variable called name and sets its value to "John".<br>echo "Hello, $name!": Prints "Hello, John!" to the terminal.</b></p>

                        <h3>4. User Input</h3>
                        <p>You can prompt the user for input using the read command. For example:</p>
                        <p><b>#!/bin/bash<br>echo "What's your name?"<br>read name<br>echo "Hello, $name!"</b></p>
                        <p><b>read name: Takes input from the user and stores it in the variable name.<br>If the user types "Alice", it would print "Hello, Alice!".</b></p>

                        <h3>5. Conditional Statements (if-else)</h3>
                        <p>You can use if-else statements to run code based on conditions. Here’s the syntax:</p>
                        <p><b>if [ condition ]<br>then<br># Commands to run if condition is true<br>else<br># Commands to run if condition is false<br>fi</b></p>
                        <p>Example:</p>
                        <p><b>#!/bin/bash<br><br>echo "Enter a number:"<br>read num<br>if [ $num -gt 10 ]; then<br>echo "Your number is greater than 10!"<br>else<br>echo "Your number is 10 or less."<br>fi</b></p>
                        <p>-gt: Greater than comparison.<br>if [ $num -gt 10 ]: Checks if the value of num is greater than 10.</p>
                        <p>Other comparison operators include:</p>
                        <ul>
                            <li>lt: Less than</li>
                            <li>eq: Equal to</li>
                            <li>ne: Not equal to</li>
                        </ul>

                        <h3>6. Loops</h3>
                        <p>Loops allow you to repeat commands. Two common loops are the for loop and the while loop.</p>
                        <p>For Loop:</p>
                        <p>The for loop runs a set of commands for each item in a list:</p>
                        <p><b>for item in item1 item2 item3<br>do<br>echo "Item: $item"<br>done</b></p>
                        <p>Example:</p>
                        <p><b>#!/bin/bash<br>for fruit in apple banana cherry<br>do<br>echo "I like $fruit!"<br>done</b></p>
                        <p>This script would print:</p>
                        <p><b>I like apple!<br>I like banana!<br>I like cherry!</b></p>
                        <p>While Loop:</p>
                        <p>The while loop runs commands as long as a condition is true:</p>
                        <p><b>#!/bin/bash<br>count=1<br>while [ $count -le 5 ]<br>do<br>echo "Count: $count"<br>count=$((count + 1))<br>done</b></p>
                        <p>This script prints the numbers 1 to 5.</p>

                        <h3>7. Functions</h3>
                        <p>You can define functions in shell scripts to group a set of commands that can be reused. Functions are defined using the following syntax:</p>
                        <p><b>function_name() {<br># Commands<br>}</b></p>
                        <p>Example:</p>
                        <p><b>#!/bin/bash<br>greet() {<br>echo "Hello, $1!"<br>}</b></p>
                        <p><b>greet "John"<br>greet "Alice"</b></p>
                        <p>$1: The first argument passed to the function. In this case, "John" and "Alice" are passed when calling the function.</p>
                        <p>The output will be:</p>
                        <p><b>Hello, John!<br>Hello, Alice!</b></p>

                        <h3>8. Comments</h3>
                        <p>Anything after # on a line is a comment. Comments are ignored by the shell and are useful for explaining your code.</p>
                        <p><b>#!/bin/bash<br># This is a comment<br>echo "This will run"</b></p>

                        <h3>9. File Permissions</h3>
                        <p>Before you can run your script, you need to give it execute permissions using the chmod command:</p>
                        <ul>
                            <li><b>chmod +x script.sh</b></li>
                        </ul>
                        <p>Then, you can run your script like this:</p>
                        <p>./script.sh</p>

                        <h3>10. Exit Status</h3>
                        <p>Every command in a shell script returns an exit status. 0 means success, and any non-zero value means failure. You can check the exit status of the last command with $?:</p>
                        <p><b>#!/bin/bash<br>ls /nonexistent_directory<br>echo "The exit status is $?"</b></p>
                        <p>If the directory doesn’t exist, the exit status will be a non-zero value.</p>


                        <h3>Basic Shell Script Example</h3>
                        <p>Here’s a simple script that puts it all together:</p>
                        <p><b>#!/bin/bash<br># This is a simple shell script example</b></p>
                        <p><b># Ask the user for their name<br>echo "What's your name?"<br>read name</b></p>
                        <p><b># Greet the user<br>echo "Hello, $name!"</b></p>
                        <p><b># Create a new directory and a file<br>mkdir myfolder<br>touch myfolder/myfile.txt</b></p>
                        <p><b># Use a loop to print numbers<br>for i in 1 2 3 4 5<br>do<br>echo "Number: $i"<br>done</b></p>
                        <p><b># Goodbye message<br>echo "Goodbye, $name!"</b></p>
                        <p>Shell scripting is a powerful way to automate tasks, and understanding the basic syntax allows you to create useful scripts for a variety of purposes.</p>




                        <div class="dropdown">
                            <button onclick="toggleDropdown('week2day3exercises')">Exercises</button>
                            <div id="week2day3exercises" class="dropdown-content">
                                <p>Have a go at some of theses exercises. You can use the internet for research.</p>
                                <h3>Exercise 1: Hello User Script</h3>
                                <p>Create a script that:</p>
                                <p>Prompts the user for their name.</p>
                                <p>Prints a message saying "Hello, [name]!".</p>
                                <p>Extra: Modify the script to say "Goodbye, [name]!" before it exits.</p>
                                <p>Hint: Use read to get user input, and echo to display the message.</p>

                                <h3>Exercise 2: Simple Calculator</h3>
                                <p>Write a script that:</p>
                                <p>Asks the user to enter two numbers.</p>
                                <p>Asks the user to choose an operation (+, -, *, /).</p>
                                <p>Performs the chosen operation and displays the result.</p>
                                <p>Hint: Use read to take input, and if statements or case statements to handle different operations.</p>

                                <h3>Exercise 3: Directory and File Manager</h3>
                                <p>Create a script that:</p>
                                <p>Prompts the user to create a directory.</p>
                                <p>Moves into the newly created directory using cd.</p>
                                <p>Creates a file inside the directory with touch and writes some text into the file using echo.</p>
                                <p>Lists all files in the directory using ls.</p>
                                <p>Hint: Use mkdir, cd, touch, and echo to perform operations on directories and files.</p>

                                <h3>Exercise 4: Even or Odd Number Checker</h3>
                                <p>Write a script that:</p>
                                <p>Asks the user to enter a number.</p>
                                <p>Checks whether the number is even or odd.</p>
                                <p>Prints the result.</p>
                                <p>Hint: Use the modulo operator (%) and an if statement to determine if the number is even or odd.</p>

                                <h3>Exercise 5: Countdown Timer</h3>
                                <p>Write a script that:</p>
                                <p>Asks the user to input a number.</p>
                                <p>Counts down from that number to zero, printing each number.</p>
                                <p>When the countdown reaches zero, prints "Time's up!".</p>
                                <p>Hint: Use a while loop to decrement the number until it reaches zero.</p>

                                <h3>Exercise 6: File Searcher Script</h3>
                                <p>Write a script that:</p>
                                <p>Prompts the user for a file extension (e.g., .txt).</p>
                                <p>Searches the current directory and its subdirectories for files with that extension using find.</p>
                                <p>Displays the found files.</p>
                                <p>Hint: Use read to capture the file extension and find . -name "*.extension" to search for files.</p>

                                <h3>Exercise 7: User Greeter with Time</h3>
                                <p>Write a script that:</p>
                                <p>Greets the user with "Good Morning", "Good Afternoon", or "Good Evening" depending on the current time of day.</p>
                                <p>Then prints a message like "Hello, [name]! Have a nice day!" based on the user’s input.</p>
                                <p>Hint: Use the date command to get the current time and if-else to determine the greeting.</p>

                                <h3>Exercise 8: Prime Number Checker</h3>
                                <p>Write a script that:</p>
                                <p>Asks the user to input a number.</p>
                                <p>Checks if the number is prime (i.e., divisible only by 1 and itself).</p>
                                <p>Displays whether the number is prime or not.</p>
                                <p>Hint: Use a for loop to check divisibility from 2 up to the number’s square root.</p>

                                <h3>Exercise 9: Backup Script</h3>
                                <p>Write a script that:</p>
                                <p>Creates a backup of a given directory.</p>
                                <p>Asks the user to input the directory path.</p>
                                <p>Copies the directory to a location called backup_[date], where [date] is the current date.</p>
                                <p>Prints a message indicating the backup was successful.</p>
                                <p>Hint: Use cp -r to copy directories and the date command to append the current date to the backup folder name.</p>

                                <h3>Exercise 10: Function-based Greeting Script</h3>
                                <p>Write a script that:</p>
                                <p>Defines a function called greet that takes a name as an argument and prints "Hello, [name]!".</p>
                                <p>Prompts the user for their name, and then calls the greet function with the user's name as the argument.</p>
                                <p>Hint: Use a function declaration to define the greet function and pass the user’s name as an argument to the function.</p>

                                <h3>Bonus Exercise: Advanced Calculator with Functions</h3>
                                <p>Write a script that:</p>
                                <p>Defines functions for add, subtract, multiply, and divide.</p>
                                <p>Prompts the user for two numbers and an operation.</p>
                                <p>Calls the appropriate function based on the user’s input and displays the result.</p>
                                <p>Hint: Use read for inputs, and create functions for each operation.</p>

                                
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week2day4')">Day 4</button>
                <div id="week2day4" class="dropdown-content">
                    <div class="day-title">Process Management</div>
                    <div class="day-info">
                        <p>Understanding processes and jobs is essential in Linux as it allows you to manage the programs and tasks running on your system. Here’s an explanation of processes, jobs, and key commands like ps, top, kill, bg, fg, and jobs.</p>
                        <h3>What is a Process?</h3>
                        <p>A process is simply an instance of a running program. Every time you execute a command or run an application, it creates a process. Each process has a unique identifier called a PID (Process ID).</p>
                        <p>Processes can be in different states:</p>
                        <ul>
                            <li>Running: The process is actively using the CPU.</li>
                            <li>Sleeping: The process is waiting for some input or event.</li>
                            <li>Stopped: The process has been paused.</li>
                            <li>Zombie: The process has completed but has not been cleaned up by its parent.</li>
                        </ul>

                        <h3>What is a Job?</h3>
                        <p>A job refers to a process that is associated with your current terminal session. Jobs can run in the foreground (actively using the terminal) or in the background (running behind the scenes, allowing you to continue using the terminal).</p>
                        
                        <h3>Commands to Manage Processes and Jobs</h3>
                        <b>1. ps – Process Status</b>
                        <p>The ps command is used to display information about running processes. It shows details such as the PID, terminal, and running time of each process.</p>
                        <ul>
                            <li><b>ps</b></li>
                        </ul>
                        <p>This shows the processes running in your current terminal session.</p>
                        <p>More detailed output:</p>
                        <ul>
                            <li><b>ps aux</b></li>
                        </ul>
                        <p>This shows all processes running on the system, including system-level processes, with details like user, CPU, memory usage, etc.</p>

                        <h3>2. top – Real-Time Process Monitoring</h3>
                        <p>The top command displays a real-time, dynamic view of the system’s processes. It shows which processes are using the most CPU and memory, and it updates live.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>top</b></li>
                        </ul>

                        <p><b>In top, you’ll see columns for:</b></p>
                        <ul>
                            <li><b>PID: Process ID.</b></li>
                            <li><b>USER: User who owns the process.</b></li>
                            <li><b>%CPU: CPU usage by the process.</b></li>
                            <li><b>%MEM: Memory usage by the process.</b></li>
                            <li><b>TIME+: Total CPU time used by the process.</b></li>
                        </ul>
                        <p>You can press:</p>
                        <ul>
                            <li><b>q to quit.</b></li>
                            <li><b>k to kill a process (enter the PID when prompted).</b></li>
                            <li><b>h for help.</b></li>
                        </ul>

                        <h3>3. kill – Terminate a Process</h3>
                        <p>The kill command sends a signal to a process, most often to terminate (kill) it. You use the PID of the process to specify which one to kill.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>kill [PID]</b></li>
                        </ul>
                        <p>You can specify different signals to send:</p>
                        <ul>
                            <li><b>SIGTERM (15): Politely asks the process to terminate (default).</b></li>
                            <li><b>SIGKILL (9): Forcefully kills the process.</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>kill 1234</b></li>
                        </ul>
                        <p>This sends a polite termination signal to the process with PID 1234.</p>
                        <p>If the process doesn’t terminate, you can force it with:</p>
                        <ul>
                            <li><b>kill -9 1234</b></li>
                        </ul>

                        <h3>4. bg – Send a Job to the Background</h3>
                        <p>When you run a command in the terminal, it normally runs in the foreground, meaning you can’t use the terminal for anything else until the command finishes. If you pause a job (using Ctrl+Z), you can resume it in the background using bg.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>bg [job_number]</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>Run a command, for example:</p>
                        <ul>
                            <li><b>sleep 100</b></li>
                        </ul>
                        <p>It will take 100 seconds to complete, and you can’t use the terminal for anything else.</p>
                        <p>Pause it by pressing Ctrl+Z. The terminal will output something like:</p>
                        <ul>
                            <li><b>[1]+  Stopped  sleep 100</b></li>
                        </ul>
                        <p>Send it to the background using:</p>
                        <ul>
                            <li><b>bg 1</b></li>
                        </ul>
                        <p>Now the job will continue running in the background, and you can use the terminal for other tasks.</p>

                        <h3>5. fg – Bring a Job to the Foreground</h3>
                        <p>If you have a job running in the background, you can bring it back to the foreground with the fg command.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>fg [job_number]</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>To bring the background job (e.g., sleep 100) back to the foreground:</p>
                        <ul>
                            <li><b>fg 1</b></li>
                        </ul>
                        <p>If you have only one background job, you can just use:</p>
                        <ul>
                            <li><b>fg</b></li>
                        </ul>

                        <h3>6. jobs – List Active Jobs</h3>
                        <p>The jobs command lists all the jobs associated with your terminal session, both background and stopped jobs.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>jobs</b></li>
                        </ul>
                        <p>This will output something like:</p>
                        <ul>
                            <li><b>[1]-  Running  sleep 100 &</b></li>
                            <li><b>[2]+  Stopped  nano</b></li>
                        </ul>
                        <p>In this case:</p>
                        <ul>
                            <li><b>Job 1 is running in the background.</b></li>
                            <li><b>Job 2 (e.g., nano) is currently stopped.</b></li>
                        </ul>

                        <h3>Scenarios and Examples</h3>

                        <h3>Example 1: Managing a Long-Running Backup Script</h3>
                        <p>You're running a backup script that copies large directories, and it’s taking longer than expected. You need to check its status and continue using the terminal for other tasks while the backup runs.</p>
                        <p>Start the backup script:</p>
                        <ul>
                            <li><b>./backup_script.sh</b></li>
                        </ul>
                        <p>The terminal is now occupied by the script.</p>
                        <p>Pause the backup process (if you realize you need the terminal for something else):</p>
                        <p>Press Ctrl+Z to stop the script temporarily:</p>
                        <ul>
                            <li><b>[1]+  Stopped  ./backup_script.sh</b></li>
                        </ul>
                        <p>Send the script to the background so it continues running while you work on other things:</p>
                        <ul>
                            <li><b>bg 1</b></li>
                        </ul>
                        <p>The job is now running in the background.</p>
                        <p>List the background jobs to check the status:</p>
                        <ul>
                            <li><b>jobs</b></li>
                        </ul>
                        <p>Output:</p>
                        <ul>
                            <li><b>[1]+  Running  ./backup_script.sh &</b></li>
                        </ul>
                        <p>Bring the job back to the foreground if you want to check on the progress:</p>
                        <ul>
                            <li><b>fg 1</b></li>
                        </ul>
                        <p>Now the script is running in the foreground again.</p>

                        <h3>Example 2: Monitoring and Stopping a Resource-Heavy Process</h3>
                        <p>You notice your system has become slow, and you want to find out which process is consuming the most CPU or memory. You might need to terminate that process.</p>
                        <p>Use top to see real-time system resource usage:</p>
                        <ul>
                            <li><b>top</b></li>
                        </ul>
                        <p>In the top output, you see that a process (e.g., myprogram) is using too much CPU.</p>
                        <p>Press k in top to kill the process:</p>
                        <p>Enter the PID (let’s say it's 1234).</p>
                        <p>Use signal 15 to gracefully terminate it, or use 9 to forcefully kill it if it's not responding:</p>
                        <ul>
                            <li><b>kill -9 1234</b></li>
                        </ul>
                        <p>Verify that the process is terminated by using ps:</p>
                        <ul>
                            <li><b>ps aux | grep myprogram</b></li>
                        </ul>
                        <p>If myprogram no longer appears, it’s been successfully terminated.</p>

                        <h3>Example 3: Running Multiple Tasks in the Background</h3>
                        <p>You need to run multiple tasks (like downloading files, running scripts, etc.) simultaneously but don’t want them to block your terminal. You can run them in the background.</p>
                        <p>Start a download using wget:</p>
                        <ul>
                            <li><b>wget http://example.com/largefile.iso</b></li>
                        </ul>
                        <p>Pause the download using Ctrl+Z:</p>
                        <ul>
                            <li><b>[1]+  Stopped  wget http://example.com/largefile.iso</b></li>
                        </ul>
                        <p>Move it to the background so it continues downloading:</p>
                        <ul>
                            <li><b>bg 1</b></li>
                        </ul>
                        <p>Start another task (e.g., copying a large directory):</p>
                        <ul>
                            <li><b>cp -r /home/user/largefolder /backup/largefolder</b></li>
                        </ul>
                        <p>Pause and background this second task using Ctrl+Z and bg:</p>
                        <ul>
                            <li><b>bg 2</b></li>
                        </ul>
                        <p>List the running jobs to see both tasks running in the background:</p>
                        <ul>
                            <li><b>jobs</b></li>
                        </ul>
                        <p>Output:</p>
                        <ul>
                            <li><b>[1]-  Running  wget http://example.com/largefile.iso &</b></li>
                            <li><b>[2]+  Running  cp -r /home/user/largefolder /backup/largefolder &</b></li>
                        </ul>
                        <p>Bring any job back to the foreground when you want to monitor it:</p>
                        <ul>
                            <li><b>fg 1   # To bring wget back</b></li>
                        </ul>

                        <h3>Example 4: Restarting a Stuck Application</h3>
                        <p>A graphical application (e.g., a text editor or browser) has frozen, and you want to kill and restart it.</p>
                        <p>Find the process ID of the frozen application using ps (let's say it's gedit):</p>
                        <ul>
                            <li><b>ps aux | grep gedit</b></li>
                        </ul>
                        <p>Kill the process using the PID:</p>
                        <ul>
                            <li><b>kill 2345</b></li>
                        </ul>
                        <p>If the application doesn’t respond to a normal termination, force kill it:</p>
                        <ul>
                            <li><b>kill -9 2345</b></li>
                        </ul>
                        <p>Restart the application after it’s been terminated:</p>
                        <ul>
                            <li><b>gedit &</b></li>
                        </ul>

                        <h3>Example 5: Searching for and Killing Multiple Instances of a Process</h3>
                        <p>A program you’ve run (myapp) has spawned multiple instances, and you want to kill them all.</p>
                        <p>Use ps to find all instances of myapp:</p>
                        <p>ps aux | grep myapp</p>
                        <p>Output:</p>
                        <ul>
                            <li><b>user     3456  0.5  1.2  54321   1234 ?        S    12:34   0:02 myapp</b></li>
                            <li><b>user     4567  0.5  1.2  54321   1234 ?        S    12:34   0:02 myapp</b></li>
                        </ul>
                        <p>Kill all instances using a loop:</p>
                        <ul>
                            <li><b>kill $(ps aux | grep myapp | awk '{print $2}')</b></li>
                        </ul>
                        <p>This command will kill all processes that match the name myapp.</p>
                        <p>Verify that all instances are terminated using ps:</p>
                        <ul>
                            <li><b>ps aux | grep myapp</b></li>
                        </ul>
                        

                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week2day5')">Day 5</button>
                <div id="week2day5" class="dropdown-content">
                    <div class="day-title">Basic Network Configuration in Linux</div>
                    <div class="day-info">

                        <p>Understanding network configuration is crucial for working with Linux systems, whether you're setting up a home server, connecting to a remote machine, or troubleshooting network issues. This involves configuring network interfaces, IP addresses, gateways, and more. Here’s a brief guide to basic network configuration in Linux and common networking commands.</p>

                        <h3>1. Network Configuration Files</h3>
                        <p>Network configuration on Linux can be handled manually or via tools. Depending on the distribution, configuration files might differ slightly:</p>
                        <b>Debian/Ubuntu:</b>
                        <p>Network interfaces are often defined in /etc/network/interfaces or via the NetworkManager GUI or CLI.</p>
                        <b>Red Hat/CentOS/Fedora:</b>
                        <p>Network configuration can be found in /etc/sysconfig/network-scripts/ and controlled by NetworkManager.</p>
                        <p>Common Networking Commands</p>
                        <p>Let’s dive into some essential networking commands and what they do.</p>

                        <h3>1. ping – Check Connectivity</h3>
                        <p>The ping command tests the network connection between your system and a remote server. It works by sending ICMP (Internet Control Message Protocol) "echo requests" to the target and waiting for a response.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>ping [hostname or IP address]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>ping google.com</b></li>
                        </ul>
                        <p>This sends packets to Google's server to check if it's reachable.</p>
                        <p>Common options:</p>
                        <ul>
                            <li><b>-c to limit the number of packets sent. For example, ping -c 5 google.com sends 5 packets and then stops.</b></li>
                            <li><b>-i to set the interval between pings.</b></li>
                        </ul>

                        <h3>2. ifconfig / ip – View and Configure Network Interfaces</h3>
                        <p>ifconfig is the traditional tool to configure and view network interfaces, though it is being replaced by the more modern ip command.</p>
                        <p>ifconfig (old method):</p>
                        <ul>
                            <li><b>Use ifconfig to check the status of network interfaces (like Ethernet, Wi-Fi).</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>ifconfig</b></li>
                        </ul>
                        <p>This displays all active network interfaces along with their IP addresses, MAC addresses, and network statistics.</p>
                        <p>To bring an interface up (enable it):</p>
                        <ul>
                            <li><b>sudo ifconfig eth0 up</b></li>
                        </ul>
                        <p>To bring an interface down (disable it):</p>
                        <ul>
                            <li><b>sudo ifconfig eth0 down</b></li>
                        </ul>
                        <p>ip (modern method):</p>
                        <ul>
                            <li><b>The ip command is more powerful and is now recommended for managing networking.</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>ip addr</b></li>
                        </ul>
                        <p>This command shows all IP addresses and interfaces.</p>
                        <p>To display only IPv4 addresses:</p>
                        <ul>
                            <li><b>ip -4 addr</b></li>
                        </ul>
                        <p>To bring an interface up or down:</p>
                        <ul>
                            <li><b>sudo ip link set eth0 up    # Enable interface</b></li>
                            <li><b>sudo ip link set eth0 down  # Disable interface</b></li>
                        </ul>
                        <p>To assign a new IP address to an interface:</p>
                        <ul>
                            <li><b>sudo ip addr add 192.168.1.10/24 dev eth0</b></li>
                        </ul>

                        <h3>3. netstat / ss – Network Statistics</h3>
                        <p>netstat shows network connections, routing tables, interface statistics, masquerade connections, and multicast memberships. It's useful for diagnosing network issues and monitoring connections.</p>
                        <p>netstat (old method):</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>netstat -tuln</b></li>
                        </ul>
                        <p>This command shows:</p>
                        <ul>
                            <li><b>t: TCP connections</b></li>
                            <li><b>u: UDP connections</b></li>
                            <li><b>l: Listening ports</b></li>
                            <li><b>n: Numeric addresses (rather than resolving hostnames)</b></li>
                        </ul>
                        <p>ss (modern method):</p>
                        <ul>
                            <li><b>The ss command is faster and more powerful than netstat, and is often used as a replacement.</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>ss -tuln</b></li>
                        </ul>
                        <p>This command works similarly to netstat but with better performance for displaying socket information.</p>

                        <h3>4. ssh – Secure Shell</h3>
                        <p>The ssh command allows you to securely connect to a remote system over the network using the SSH protocol. It’s essential for managing servers or remote machines.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>ssh [username]@[hostname or IP address]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>ssh user@192.168.1.50</b></li>
                        </ul>
                        <p>This connects to the machine at 192.168.1.50 with the username user.</p>
                        <p>To use a custom port:</p>
                        <ul>
                            <li><b>ssh -p 2222 user@192.168.1.50</b></li>
                        </ul>
                        <p>To copy files securely between two machines, you can use scp:</p>
                        <ul>
                            <li><b>scp [source] [destination]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>scp file.txt user@192.168.1.50:/home/user/</b></li>
                        </ul>

                        <h3>5. traceroute – Trace the Network Path</h3>
                        <p>The traceroute command traces the path that packets take from your computer to a destination server. It shows the various routers (hops) the packets pass through.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>traceroute [hostname or IP address]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>traceroute google.com</b></li>
                        </ul>
                        <p>This shows the routers between your machine and Google's server, including their IP addresses and response times.</p>

                        <h3>6. nslookup / dig – DNS Lookup</h3>
                        <p>These commands are used to query DNS (Domain Name System) to resolve domain names into IP addresses or vice versa.</p>
                        <p>Usage:</p>
                        <ul>
                            <li><b>nslookup [hostname]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>nslookup google.com</b></li>
                        </ul>
                        <p>This resolves google.com to its corresponding IP address.</p>
                        <p>dig:</p>
                        <ul>
                            <li><b>dig is a more detailed DNS lookup tool.</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>dig [hostname]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>dig google.com</b></li>
                        </ul>

                        <h3>Networking Commands</h3>
                        <ul>
                            <li><b>ping:</b> Tests network connectivity by sending packets to a host and receiving replies.</li>
                            <li><b>ifconfig:</b> (Deprecated) Views and configures network interfaces (IP addresses, MAC addresses).</li>
                            <li><b>ip:</b> Modern replacement for ifconfig; more powerful for managing interfaces and routing.</li>
                            <li><b>netstat:</b> (Deprecated) Displays network connections, routing tables, and port activity.</li>
                            <li><b>ss:</b> Modern replacement for netstat; faster and more efficient.</li>
                            <li><b>ssh:</b> Securely connects to a remote server over the network.</li>
                            <li><b>traceroute:</b> Shows the route that packets take from your computer to a destination.</li>
                            <li><b>nslookup:</b> Performs DNS lookup for resolving domain names to IP addresses.</li>
                            <li><b>dig	Performs detailed DNS lookup queries.</b></li>
                        </ul>

                        <h3>Basic Networking Example Scenarios</h3>

                        <h3>Example 1: Checking Network Connectivity</h3>
                        <p>You suspect that your internet connection is down. You can use ping to check:</p>
                        <ul>
                            <li><b>ping google.com</b></li>
                        </ul>
                        <p>If you see replies, your internet connection is working. If you don’t, it could be a network issue.</p>

                        <h3>Example 2: Checking Network Interfaces</h3>
                        <p>You need to know the IP address of your machine. Use ip addr to view the IP configuration:</p>
                        <ul>
                            <li><b>ip addr</b></li>
                        </ul>

                        <h3>Example 3: Securely Connecting to a Remote Server</h3>
                        <p>You need to manage a remote server, so you use ssh to connect:</p>
                        <ul>
                            <li><b>ssh user@remote-server.com</b></li>
                        </ul>

                        <h3>Example 4: Monitoring Network Connections</h3>
                        <p>You're troubleshooting network performance issues and want to check which ports are open and listening:</p>
                        <ul>
                            <li><b>ss -tuln</b></li>
                        </ul>

                        <h3>Example 5: Tracing the Route to a Server</h3>
                        <p>You're experiencing slow access to a website and want to see where the delay is happening:</p>
                        <ul>
                            <li><b>traceroute example.com</b></li>
                        </ul>

                        <p>These commands help you diagnose network issues, set up remote access, and configure network interfaces on your machine.</p>

                        <h3>More commands</h3>

                        <h3>Curl</h3>
                        <p>The curl (Client URL) command is primarily used for transferring data across networks and supports multiple protocols like HTTP, FTP, and IMAP, among others. It's often favored in automation tasks because it is designed to operate without user interaction and can be used for endpoint testing, debugging, and error logging.</p>
                        <p>Since curl is not pre-installed on most systems, on Debian-based distributions, you can install it using the following command:</p>
                        <ul>
                            <li><b>sudo apt install curl</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>curl -O [URL]</b></li>
                        </ul>
                        <p>While downloading large files, the progress bar can be used, and you can do the same with curl using -# option.</p>

                        <h3>mtr</h3>
                        <p>mtr combines the functionalities of both ping and traceroute utilities, making it ideal for network diagnostics by providing a real-time view of network response and connectivity. To use mtr, simply append a domain name or IP address, and it will generate a live traceroute report.</p>
                        <ul>
                            <li><b>mtr [URL/IP]</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>mtr -b [URL]</b></li>
                        </ul>

                        <h3>whois</h3>
                        <p>The whois command helps you retrieve information about registered domains, IP addresses, name servers, and more, as it acts as a client for the whois directory service. This utility may not be pre-installed on your system, but on Ubuntu-based distributions, you can install it using the following command:</p>
                        <ul>
                            <li><b>sudo apt install whois</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>whois [DomainName]</b></li>
                        </ul>
                        <p>You can use an ip address instead of hostname.</p>

                        <h3>iftop</h3>
                        <p>iftop (Interface TOP) is commonly used by administrators to monitor bandwidth usage and can also serve as a diagnostic tool for network issues. This utility is not pre-installed and requires manual installation. On Ubuntu systems, you can install it using the following command:</p>
                        <ul>
                            <li><b>sudo apt install iftop</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>sudo iftop -h </b></li>
                        </ul>
                        <p>this will tell you what options you can use with it.</p>

                        <h3>TCPDump</h3>
                        <p>tcpdump is a packet-sniffing and analysis tool used to capture, analyze, and filter network traffic. It can also serve as a security tool by saving captured data in pcap format, which can later be reviewed using Wireshark. Similar to other utilities, tcpdump is not pre-installed. If you're using an Ubuntu-based system, you can install it using the following command:</p>
                        <ul>
                            <li><b>sudo apt install tcpdump</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>sudo tcpdump</b></li>
                        </ul>
                        <p>you can capture packets using this command:</p>
                        <ul>
                            <li><b>sudo tcpdump -w Captured_Packets.pcap -i <networkdevice></networkdevice></b></li>
                        </ul>
                        <p>you can look in the captured packets with -r tag.</p>
                        <ul>
                            <li><b>sudo tcpdump -r Captured_Packets.pcap</b></li>
                        </ul>

                        <h3>ethtool</h3>
                        <p>As the name implies, the ethtool utility is mainly used for managing Ethernet devices. It allows you to adjust settings like network card speed, auto-negotiation, and more. However, it may not come pre-installed on your system. To install it on an Ubuntu-based machine, you can use the following command:</p>
                        <ul>
                            <li><b>sudo apt install ethtool</b></li>
                        </ul>
                        <p>usage:</p>
                        <ul>
                            <li><b>sudo ethtool <InterfaceName></InterfaceName></b></li>
                        </ul>

                        <h3>nmcli</h3>
                        <p>As a straightforward yet powerful network troubleshooting tool, nmcli is often one of the first utilities a sysadmin turns to for diagnosing network issues. It can also be used within scripts for automation. To monitor the connectivity status of devices, you can use the nmcli command as shown:</p>
                        <ul>
                            <li><b>nmcli dev status</b></li>
                        </ul>
                        <p>usage:</p>
                        <ul>
                            <li><b>nmcli</b></li>
                        </ul>

                        <h3>nmap</h3>
                        <p>nmap is a tool used for network exploration and security auditing. It is popular among hackers and security enthusiasts as it provides detailed, real-time information about the network, connected IPs, port scanning, and more. To install the nmap utility on Ubuntu-based distributions, use the following command:</p>
                        <ul>
                            <li><b>sudo apt install nmap</b></li>
                        </ul>
                        <p>usage:</p>
                        <ul>
                            <li><b>nmap itsfoss.com</b></li>
                        </ul>

                        <h3>bmon</h3>
                        <p>bmon is an open-source tool used to monitor real-time bandwidth and debug network issues by displaying statistics in a user-friendly format. One of its standout features is its graphical presentation, and it even allows output in HTML. Installation is easy, as bmon is available in the default repositories of popular Linux distributions, including Ubuntu.</p>
                        <ul>
                            <li><b>sudo apt install bmon</b></li>
                        </ul>
                        <p>usage:</p>
                        <ul>
                            <li><b>bmon</b></li>
                        </ul>

                        <h3>firewalld</h3>
                        <p>Managing firewalls is a critical aspect of network security, and firewalld allows you to add, configure, and remove firewall rules efficiently. However, firewalld is not pre-installed and requires manual installation. On Ubuntu-based distributions, you can install it using the following command:</p>
                        <ul>
                            <li><b>sudo apt install firewalld</b></li>
                        </ul>
                        <p>Usage:</p>
                        <ul>
                            <li><b>sudo firewall-cmd --permanent --zone=public --add-port=80/tcp</b></li>
                            <li><b>sudo firewall-cmd --zone=public --remove-port=80/tcp</b></li>
                        </ul>




                    </div>
                </div>
            </div>

            <div class="dropdown">
                <button onclick="toggleDropdown('week2review')">Week Review</button>
                <div id="week2review" class="dropdown-content">
                    <div class="day-title">Week 2 Review</div>
                    <div class="day-info">
                        <b>Week Two Review: Intermediate Linux Operations and Essentials</b>
                        <p>In week two, we expanded on foundational skills by delving into advanced file operations, powerful search tools, shell scripting basics, process management, and networking essentials. Here’s a summary of what we covered and the main takeaways for each area.</p>
                        <h3>1. Advanced File Operations</h3>
                        <p>Building on basic file manipulation, we explored more complex file operations and tools to manage files efficiently.</p>
                        <p>Permissions and Ownership: Files and directories in Linux have permissions that control who can read, write, and execute them.</p>
                        <ul>
                            <li><b>chmod: Changes permissions. For example, chmod 755 file.txt sets permissions to be readable and executable by all, but writable only by the owner.</b></li>
                            <li><b>chown: Changes ownership. For instance, chown user:group file.txt changes the file’s owner and group.</b></li>
                        </ul>
                        <p>Links:</p>
                        <ul>
                            <li><b>Hard Links: Direct references to the same inode (data). They act as mirrors of a file and continue to work even if the original file is deleted.</b></li>
                            <li><b>Symbolic (Soft) Links: Pointers to another file or directory. These are more flexible but become broken if the target is deleted or moved.</b></li>
                        </ul>
                        <p>Managing file permissions and understanding the difference between hard and soft links is crucial for secure and organized file management.</p>

                        <h3>2. Searching and Finding Files</h3>
                        <p>Linux provides powerful commands for searching files and text patterns across directories.</p>
                        <p>find: Locates files based on criteria like name, type, size, and modification date.</p>
                        <ul>
                            <li><b>Example: find / -name "file.txt" finds a file named "file.txt" anywhere in the root directory.</b></li>
                        </ul>
                        <p>locate: Quickly finds files by name using an indexed database.</p>
                        <ul>
                            <li><b>Example: locate file.txt is faster but may need updatedb to refresh the database.</b></li>
                        </ul>
                        <p>grep: Searches for patterns within files. Supports regular expressions, making it versatile for text search.</p>
                        <ul>
                            <li><b>Example: grep "pattern" file.txt finds all lines containing "pattern" in file.txt.</b></li>
                        </ul>
                        <p>Knowing how to search for files and patterns enables efficient file management, troubleshooting, and data discovery.</p>

                        <h3>3. Introduction to Shell Scripting</h3>
                        <p>Shell scripting is a powerful way to automate tasks and enhance productivity in Linux.</p>
                        <p>Basic Syntax:</p>
                        <ul>
                            <li><b>Comments: Begin with #, e.g., # This is a comment.</b></li>
                            <li><b>Variables: Created and used without a $ when setting, with $ when calling, e.g., var="Hello", echo $var.</b></li>
                            <li><b>Control Statements: Use if, for, while, and case to add logic to scripts.</b></li>
                        </ul>
                        <p>Creating and Running Scripts:</p>
                        <ul>
                            <li><b>Write the script in a text file and make it executable with chmod +x script.sh.</b></li>
                            <li><b>Execute the script with ./script.sh.</b></li>
                        </ul>
                        <p>Shell scripts automate repetitive tasks and simplify complex workflows, a fundamental skill for Linux administrators.</p>

                        <h3>4. Process Management</h3>
                        <p>Processes represent running programs. Knowing how to manage processes is essential for troubleshooting and optimizing system performance.</p>
                        <ul>
                            <li><b>ps: Displays current processes. Adding options like aux shows all processes across users and detailed information.</b></li>
                            <li><b>top and htop: Real-time system monitors that display CPU, memory usage, and running processes. htop offers an interactive interface with more features.</b></li>
                            <li><b>kill: Sends signals to terminate processes. kill -9 <PID> forcefully kills a process.</b></li>
                            <li><b>jobs, bg, and fg: Manage background and foreground processes within a shell session.</b></li>
                            <li><b>jobs lists jobs, bg moves a process to the background, and fg brings it to the foreground.</b></li>
                        </ul>
                        <p>Effective process management is vital for keeping a Linux system running smoothly and responding to issues like unresponsive programs.</p>

                        <h3>5. Networking Basics</h3>
                        <p>Understanding basic networking commands helps you troubleshoot connectivity issues and manage network settings.</p>
                        <ul>
                            <li><b>ping: Tests connectivity between your system and another by sending ICMP packets. Useful for basic network troubleshooting.</b></li>
                            <li><b>ifconfig or ip: Displays network interface information and IP addresses. ifconfig is older; ip is the modern replacement (e.g., ip addr show).</b></li>
                            <li><b>netstat: Lists network connections, routing tables, and interface statistics. Useful for monitoring active connections.</b></li>
                            <li><b>ssh: Securely connects to a remote machine. The command ssh user@host opens an SSH session to another system.</b></li>
                        </ul>
                        <p>With basic networking commands allows you to diagnose network issues, view IP configurations, and securely connect to remote systems.</p>


                    </div>
                </div>
            </div>
            
            <div class="dropdown">
                <button onclick="toggleDropdown('week2quiz')">Quiz</button>
                <div id="week2quiz" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz: Intermediate Linux Operations and Essentials</div>
                    <div class="day-info">
                        <h3>1. Which command is used to copy files or directories?</h3>
                        <p>a) mv<br>b) touch<br>c) cp<br>d) cat</p>

                        <h3>2. What does the find command do?</h3>
                        <p>a) Finds and displays disk usage statistics<br>b) Creates a new directory<br>c) Displays the contents of a file<br>d) Searches for files or directories based on specific criteria</p>

                        <h3>3. What is the purpose of the grep command?</h3>
                        <p>a) To compress files<br>b) To search for patterns in text<br>c) To display memory usage<br>d) To move files</p>

                        <h3>4. In a shell script, which symbol is used to comment out a line?</h3>
                        <p>a) //<br>b) --<br>c) /* */<br>d) #</p>

                        <h3>5. What does the ps command do?</h3>
                        <p>a) Lists running processes<br>b) Displays file permissions<br>c) Moves files between directories<br>d) Displays system memory usage</p>

                        <h3>6. Which of the following commands brings a background job to the foreground?</h3>
                        <p>a) bg<br>b) jobs<br>c) fg<br>d) kill</p>

                        <h3>7. Which of the following is used to view running processes in real-time?</h3>
                        <p>a) top<br>b) ps<br>c) kill<br>d) jobs</p>

                        <h3>8. What does the chmod 755 filename command do?</h3>
                        <p>a) Grants read, write, and execute permissions to everyone<br>b) Grants full permissions to the owner, and read/execute permissions to others<br>c) Deletes the file named filename<br>d) Grants read and execute permissions to the owner only</p>

                        <h3>9. Which networking command is used to check connectivity to another system?</h3>
                        <p>a) ping<br>b) ssh<br>c) ifconfig<br>d) netstat</p>

                        <h3>10. What does the cd ../ command do?</h3>
                        <p>a) Changes to the root directory<br>b) Moves up one directory level (to the parent directory)<br>c) Creates a new directory<br>d) Deletes the current directory</p>

                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week2answers')">Quiz Answers</button>
                <div id="week2answers" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz Answers</div>
                    <div class="day-info">
                        <h3>1. Which command is used to copy files or directories?</h3>
                        <p>Answer: c) cp</p>

                        <h3>2. What does the find command do?</h3>
                        <p>Answer: d) Searches for files or directories based on specific criteria</p>

                        <h3>3. What is the purpose of the grep command?</h3>
                        <p>Answer: b) To search for patterns in text</p>

                        <h3>4. In a shell script, which symbol is used to comment out a line?</h3>
                        <p>Answer: d) #</p>

                        <h3>5. What does the ps command do?</h3>
                        <p>Answer: a) Lists running processes</p>

                        <h3>6. Which of the following commands brings a background job to the foreground?</h3>
                        <p>Answer: c) fg</p>

                        <h3>7. Which of the following is used to view running processes in real-time?</h3>
                        <p>Answer: a) top</p>

                        <h3>8. What does the chmod 755 filename command do?</h3>
                        <p>Answer: b) Grants full permissions to the owner, and read/execute permissions to others</p>

                        <h3>9. Which networking command is used to check connectivity to another system?</h3>
                        <p>Answer: a) ping</p>

                        <h3>10. What does the cd ../ command do?</h3>
                        <p>Answer: b) Moves up one directory level (to the parent directory)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Additional weeks can follow the same structure -->
     <!-- Week 3 -->
    <div class="dropdown">
        <button onclick="toggleDropdown('week3')">Week 3</button>
        <div id="week3" class="dropdown-content">
            <!-- Days -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week3day1')">Day 1</button>
                <div id="week3day1" class="dropdown-content">
                    <div class="day-title">Using Package Managers on Linux: Managing Software</div>
                    <div class="day-info">
                        <p>A package manager is a tool that automates the process of installing, upgrading, configuring, and removing software on a computer. On Linux systems, package managers are crucial for maintaining the software ecosystem, ensuring that users can easily install applications, libraries, and utilities, along with their dependencies, from a central repository.</p>
                        <b>What Are Package Managers For?</b>
                        <p>Package managers are essential for several reasons:</p>
                        <p><b>1. Centralized Software Management:</b> Without a package manager, users would need to download, compile, and install software manually from source code, which is time-consuming and prone to errors. A package manager centralizes this process, offering a consistent and user-friendly way to manage software.</p>
                        <p><b>2. Automatic Dependency Resolution:</b> When installing software manually, one might overlook necessary dependencies, leading to errors or failed installations. A package manager automatically resolves these dependencies, downloading and installing everything needed for the software to work correctly.</p>
                        <p><b>3. Version Control:</b> Package managers keep track of installed software versions and allow users to easily upgrade, downgrade, or switch between different versions of an application. This is especially important for software that relies on specific versions of libraries or frameworks.</p>
                        <p><b>4. Security and Stability:</b> Since package managers pull software from trusted, well-maintained repositories, they help ensure that the software is secure and stable. The repositories are usually maintained by the Linux distribution’s developers, and the packages undergo testing before being released to the public.</p>
                        <P><b>5. System Integrity:</b> By managing software installations and updates, package managers prevent conflicts between different software packages. For instance, they avoid scenarios where two packages require different versions of the same dependency, which could break functionality.</P>
                        <p><b>6. Consistency Across Systems:</b> Package managers ensure consistency across systems. By using the same package manager, users and administrators can replicate software environments on different machines, making it easier to manage multiple systems (especially in enterprise environments).</p>

                        <b>How Package Managers Work</b>

                        <p>At their core, package managers simplify software management by handling tasks that would otherwise be complex and error-prone if done manually. Here's how they generally work:</p>
                        <p><b>1. Package Repositories:</b> Package managers connect to online repositories (servers or mirrors) that store collections of software, known as packages. Each package includes not only the application itself but also metadata about dependencies, version numbers, and installation instructions.</p>
                        <p><b>2. Package Metadata:</b> Every package contains metadata—information about its dependencies (other software it relies on to function), the version, and its intended system architecture. The package manager uses this metadata to ensure that the right versions of software are installed.</p>
                        <p><b>3. Dependencies Management:</b> Many applications depend on other software (called dependencies) to run correctly. The package manager resolves these dependencies automatically, downloading and installing the necessary software alongside the requested package. This prevents the user from having to manually hunt down each required library or tool.</p>
                        <p><b>4. Installation:</b> Once a user requests to install a package, the package manager downloads the appropriate files and places them in the correct directories on the system. It also registers the package, so the manager knows it's installed and can manage it in the future.</p>
                        <p><b>5. Upgrading Software:</b> Package managers allow users to update all installed software to the latest versions with a single command. When a package is updated in the repository, the package manager downloads the new version and replaces the older one. It may also install new dependencies or remove obsolete ones.</p>
                        <p><b>6. Uninstallation and Cleanup:</b> Removing software via a package manager ensures that all the files associated with the application are also removed. This includes binaries, configuration files, and dependencies that are no longer needed. This keeps the system clean and prevents "dependency hell," where unneeded software clogs up the system.</p>

                        <b>Types of Package Managers</b>

                        <p>Linux distributions use different package managers depending on their base architecture:</p>
                        <ul>
                            <li>APT is used in Debian-based distributions like Ubuntu. It is designed for installing .deb packages.</li>
                            <li> YUM and DNF are used in Red Hat-based distributions like CentOS and Fedora, handling .rpm packages.</li>
                            <li>Pacman is used in Arch Linux and its derivatives, handling packages in its own format.</li>
                        </ul>
                        <p>Each package manager works slightly differently, but their goals are the same: to simplify software installation, removal, and management on Linux systems.</p>

                        <h3>1. APT (Advanced Package Tool)</h3>
                        <p>Used in Debian-based distributions like Ubuntu and Linux Mint, apt is one of the most widely used package managers.</p>
                        <p>Common Commands:</p>
                        <p>Update the package list:</p>
                        <ul>
                            <li><b>sudo apt update</b></li>
                        </ul>
                        <p>This refreshes the local cache of available packages from repositories, but it doesn't install or upgrade anything yet.</p>
                        <p>Upgrade all installed packages:</p>
                        <ul>
                            <li><b>sudo apt upgrade</b></li>
                        </ul>
                        <p>This upgrades all the packages currently installed on your system to their latest available versions.</p>
                        <p>Install a new package:</p>
                        <ul>
                            <li><b>sudo apt install [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo apt install vim</b></li>
                        </ul>
                        <p>Clean up unnecessary packages:</p>
                        <ul>
                            <li><b>sudo apt autoremove</b></li>
                        </ul>
                        <p>This removes packages that were installed as dependencies but are no longer needed.</p>

                        <h3>2. YUM (Yellowdog Updater Modified)</h3>
                        <p>Used in CentOS and older versions of Red Hat Enterprise Linux (RHEL). While it has been mostly replaced by dnf in newer versions, it's still widely used.</p>
                        <p>Common Commands:</p>
                        <p>Update all repositories and package lists:</p>
                        <ul>
                            <li><b>sudo yum check-update</b></li>
                        </ul>
                        <p>Install a new package:</p>
                        <ul>
                            <li><b>sudo yum install [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo yum install httpd</b></li>
                        </ul>
                        <p>Remove a package:</p>
                        <ul>
                            <li><b>sudo yum remove [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo yum remove httpd</b></li>
                        </ul>
                        <p>Update all installed packages:</p>
                        <ul>
                            <li><b>sudo yum update</b></li>
                        </ul>
                        <p>This upgrades all packages to the latest versions available in the repositories.</p>

                        <h3>3. DNF (Dandified YUM)</h3>
                        <p>dnf is the newer version of yum and is used in newer Fedora, CentOS 8+, and RHEL 8+ distributions. It provides faster dependency resolution and better performance compared to yum.</p>
                        <p>Common Commands:</p>
                        <p>Update the package list:</p>
                        <ul>
                            <li><b>sudo dnf check-update</b></li>
                        </ul>
                        <p>Install a new package:</p>
                        <ul>
                            <li><b>sudo dnf install [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo dnf install nginx</b></li>
                        </ul>
                        <p>Remove a package:</p>
                        <ul>
                            <li><b>sudo dnf remove [package-name]</b></li>
                        </ul>
                        <p>Update all installed packages:</p>
                        <ul>
                            <li><b>sudo dnf upgrade</b></li>
                        </ul>
                        <p>Clean up old packages:</p>
                        <ul>
                            <li><b>sudo dnf autoremove</b></li>
                        </ul>

                        <h3>4. Pacman</h3>
                        <p>pacman is the package manager used by Arch Linux and Arch-based distributions like Manjaro. It is a powerful tool designed to be simple and efficient.</p>
                        <p>Common Commands:</p>
                        <p>Synchronize the package list:</p>
                        <ul>
                            <li><b>sudo pacman -Sy</b></li>
                        </ul>
                        <p>Install a new package:</p>
                        <ul>
                            <li><b>sudo pacman -S [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo pacman -S neovim</b></li>
                        </ul>
                        <p>Remove a package:</p>
                        <ul>
                            <li><b>sudo pacman -R [package-name]</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>sudo pacman -R neovim</b></li>
                        </ul>
                        <p>Upgrade all installed packages:</p>
                        <ul>
                            <li><b>sudo pacman -Syu</b></li>
                        </ul>
                        <p>Remove unneeded packages:</p>
                        <ul>
                            <li><b>sudo pacman -Rns $(pacman -Qdtq)</b></li>
                        </ul>
                        <p>This command removes orphaned packages (those that were installed as dependencies but are no longer needed).</p>

                        <p>Package Manager	Command	Function</p>
                        <ul>
                            <li><b>apt	sudo apt update:</b> Update the package list.</li>
                            <li><b>sudo apt upgrade:</b> Upgrade all installed packages.</li>
                            <li><b>sudo apt install [pkg]:</b> Install a new package.</li>
                            <li><b>sudo apt remove [pkg]:</b> Remove a package.</li>
                            <li><b>sudo apt autoremove:</b> Remove unneeded dependencies.</li>
                            <li><b>dnf	sudo dnf check-update:</b> Check for package updates.</li>
                            <li><b>sudo dnf upgrade:</b> Upgrade installed packages.</li>
                            <li><b>sudo dnf install [pkg]:</b> Install a package.</li>
                            <li><b>sudo dnf remove [pkg]:</b> Remove a package.</li>
                            <li><b>sudo dnf autoremove:</b> Clean up unused dependencies.</li>
                            <li><b>pacman	sudo pacman -Syu:</b> Update package list and upgrade all packages.</li>
                            <li><b>sudo pacman -S [pkg]:</b> Install a package.</li>
                            <li><b>sudo pacman -R [pkg]:</b> Remove a package.</li>
                            <li><b>sudo pacman -Rns $(pacman -Qdtq):</b> Clean up orphaned packages.</li>
                        </ul>
                        <p>By automating the handling of dependencies, repositories, and system integration, they remove much of the complexity traditionally associated with maintaining a Linux system.</p>

                        
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week3day2')">Day 2</button>
                <div id="week3day2" class="dropdown-content">
                    <div class="day-title">User and Group Management</div>
                    <div class="day-info">
                        <h3>Creating and Managing Users and Groups on Linux</h3>
                        <p>In Linux, user and group management is fundamental to controlling access, ensuring security, and organizing system resources. Each user has a unique identity, and groups are used to manage collections of users that share similar permissions. By understanding how to create and manage users and groups, you can control who can access files, run programs, and administer the system.</p>
                        <h3>1. Users in Linux</h3>
                        <p>Every user on a Linux system has:</p>
                        <ul>
                            <li><b>A username:</b> A unique identifier used for logging in.</li>
                            <li><b>A user ID (UID):</b> A numerical value assigned to each user.</li>
                            <li><b>A home directory:</b> The user’s personal workspace, typically located at /home/[username].</li>
                            <li><b>Shell:</b> A command-line interface assigned to the user (such as Bash, /bin/bash).</li>
                            <li><b>Permissions:</b> Users have specific read, write, and execute permissions on files and directories.</li>
                        </ul>
                        <b>Creating a User</b>
                        <p>To create a new user, the useradd command is used (or adduser, which is a more user-friendly wrapper in some distributions). After a user is created, you can set their password and assign them to groups.</p>
                        <p>When a user is created, their home directory is usually set up automatically, and a shell is assigned to them. System administrators can customize these settings depending on the user's role.</p>
                        <b>Managing Users</b>
                        <p>Adding, Modifying, and Deleting a User in Linux</p>

                        <h3>1. Adding a User</h3>
                        <p>To add a new user, use the useradd command, which creates a new user account and associated settings, such as the home directory and shell.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo useradd [options] username</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>Let's say we want to create a user named john.</p>
                        <ul>
                            <li><b>sudo useradd john</b></li>
                        </ul>
                        <p>This creates the user john but does not set up a password or create a home directory. To create a home directory and set the default shell, you can use options like -m (create home directory) and -s (specify the shell).</p>
                        <ul>
                            <li><b>sudo useradd -m -s /bin/bash john</b></li>
                        </ul>
                        <p>Setting a Password:</p>
                        <p>To set a password for the user john, use the passwd command:</p>
                        <ul>
                            <li><b>sudo passwd john</b></li>
                        </ul>
                        <p>This will prompt you to enter and confirm the password. When setting up a new user, you will be prompted to set up password then, but can change it with the command above.</p>

                        <h3>2. Modifying a User</h3>
                        <p>To modify a user, use the usermod command. You can change the user's home directory, add them to groups, or modify other account details.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo usermod [options] username</b></li>
                        </ul>
                        <p>Example 1: Change Home Directory</p>
                        <p>Let's change the home directory of user john to /home/johndoe:</p>
                        <ul>
                            <li><b>sudo usermod -d /home/johndoe john</b></li>
                        </ul>
                        <p>You can also use the -m option to move the contents of the old home directory to the new one.</p>
                        <ul>
                            <li><b>sudo usermod -d /home/johndoe -m john</b></li>
                        </ul>
                        <p>Example 2: Add User to a Group</p>
                        <p>To add john to a group (e.g., the sudo group so he can run administrative commands):</p>
                        <ul>
                            <li><b>sudo usermod -aG sudo john</b></li>
                        </ul>
                        <p>-aG: Appends the user to the group (here, the sudo group). The -a is important because without it, the user will be removed from any other groups.</p>

                        <h3>3. Deleting a User</h3>
                        <p>To remove a user, use the userdel command. You can delete just the user account or also remove their home directory and mail spool.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo userdel [options] username</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                        <p>To delete user john but leave their home directory:</p>
                            <li><b>sudo userdel john</b></li>
                        </ul>
                        <p>To delete john and their home directory:</p>
                        <ul>
                            <li><b>sudo userdel -r john</b></li>
                        </ul>
                        <p>The -r option removes the user’s home directory and mail spool, ensuring no leftover files from the deleted account.</p>
                        <p>Options for useradd, usermod, and userdel Commands</p>

                        <h3>1. useradd Options (Adding Users)</h3>
                        <p>useradd [options] username</p>
                        <ul>
                            <li><b>-c "comment":</b> Sets the user's full name or description (often used for real names).</li>
                            <li><b>-d /home/path:</b> Sets the home directory for the user. If not specified, defaults to /home/username.</li>
                            <li><b>-e YYYY-MM-DD:</b> Sets the account expiration date (after which the user cannot log in).</li>
                            <li><b>-f DAYS:</b> Specifies the number of days after a password expires before the account is disabled. -1 disables this feature (default).</li>
                            <li><b>-g GROUP:</b> Sets the primary group for the user (the group must already exist).</li>
                            <li><b>-G GROUPS:</b> Sets additional (secondary) groups the user should belong to, separated by commas.</li>
                            <li><b>-m:</b> Creates the user's home directory if it doesn't exist.</li>
                            <li><b>-s /path/to/shell:</b> Sets the user's default shell (e.g., /bin/bash, /bin/zsh).</li>
                            <li><b>-u UID:</b> Specifies a unique User ID (UID) for the user.</li>
                            <li><b>-r:</b> Creates a system account (with a lower-range UID, typically for services).</li>
                            <li><b>-k /etc/skel:</b> Copies files from the specified skeleton directory to the new user's home directory. If not set, /etc/skel is used by default.</li>
                            <li><b>-K KEY=VALUE:</b> Overrides default settings specified in /etc/login.defs.</li>
                            <li><b>-N no-user-group:</b> do not create a group with the same name as</li>
                            <li><b>-M no-create-home:</b> do not create a group with the same name as</li>
                            <li><b>-l no-log-init:</b> do not add the user to the lastlog and faillog databases</li>
                        </ul>

                        <p>There are a few more options. you can use:</p>
                        <ul>
                            <li><b>useradd -h</b></li>
                        </ul>
                        <p>This will list them all. I have add most of them above.</p>

                        <h3>3. userdel Options (Deleting Users)</h3>
                        <p>userdel [options] username</p>
                        <p>Option	Description</p>
                        <ul>
                            <li><b>-r:</b> Deletes the user and removes the home directory and mail spool.</li>
                            <li><b>-f:</b> Forces the removal of the user account even if they are currently logged in or their home directory cannot be removed.</li>
                            <li><b>-Z:</b> Removes any SELinux user mapping.</li>
                        </ul>
                        <p>This will list them all. I have add most of them above.</p>
                        <p>Once users are created, they can be managed in various ways, such as changing passwords, deleting users, or modifying their permissions and groups.</p>

                        <h3>2. Groups in Linux</h3>
                        <p>A group is a collection of users, and it simplifies managing permissions for multiple users. Rather than giving individual users access to specific files or resources, you can assign users to a group, and then grant that group the necessary permissions. Groups make it easier to manage permissions, especially in systems with many users.</p>
                        <p>Each user belongs to at least one group, which is typically their primary group. Users can also belong to additional secondary groups.</p>
                        <p>Creating and Managing Groups</p>
                        <p>To create a new group, the groupadd command is used. You can then add users to the group with the usermod command, assigning them to either their primary or secondary groups.</p>
                        <p>For example, if you have a development team, you can create a devs group and add all your developers to this group. Then, by giving the devs group access to certain project directories, you automatically grant all members the same level of access.</p>
                        <p>Adding, Modifying, and Deleting Groups in Linux</p>
                        <p>Managing groups is an important part of user administration in Linux. Here’s how you can add, modify, and delete groups using basic Linux commands.</p>

                        <h3>1. Adding a Group</h3>
                        <p>The groupadd command is used to create a new group.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo groupadd [options] groupname</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>Let’s say we want to create a group called developers.</p>
                        <ul>
                            <li><b>sudo groupadd developers</b></li>
                        </ul>
                        <p>Common Options:</p>
                        <ul>
                            <li><b>-g GID: Specifies the Group ID (GID) for the group. If not provided, the system assigns a unique GID.</b></li>
                        </ul>

                        <h3>2. Modifying a Group</h3>
                        <p>The groupmod command allows you to change group details, such as the group’s name or GID.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo groupmod [options] groupname</b></li>
                        </ul>
                        <p>Example 1: Change the Group Name</p>
                        <p>Let’s change the name of the group developers to engineers.</p>
                        <ul>
                            <li><b>sudo groupmod -n engineers developers</b></li>
                        </ul>
                        <p>-n newname: Changes the group name.</p>

                        <h3>Example 2: Change the Group ID (GID)</h3>
                        <p>Let’s change the GID of the group engineers to 1050.</p>
                        <ul>
                            <li><b>sudo groupmod -g 1050 engineers</b></li>
                            <li><b>-g GID: Changes the GID of the group.</b></li>
                        </ul>

                        <h3>3. Deleting a Group</h3>
                        <p>The groupdel command is used to delete an existing group.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo groupdel groupname</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>To delete the engineers group:</p>
                        <ul>
                            <li><b>sudo groupdel engineers</b></li>
                        </ul>
                        <p>You cannot delete a group if it is the primary group of any user. You must change the user’s primary group first before deleting the group.</p>
                        <p>These are the basic commands for managing groups in Linux. These allow you to efficiently create new groups, change existing ones, and delete groups as needed.</p>

                        <h3>Understanding and Configuring sudo</h3>
                        <p>In Linux, system administration tasks (such as installing software or modifying system configurations) require root or superuser access. Rather than giving every user full root privileges (which can be dangerous), Linux uses the sudo command to allow authorized users to perform specific administrative tasks.</p>
                        <b>What is sudo?</b>
                        <p>sudo (short for "superuser do") is a tool that allows a permitted user to execute a command as the superuser (root) or another user, as specified by the system’s sudoers file.</p>
                        <p>For example, instead of logging in as the root user to install software, a regular user with sudo privileges can run:</p>
                        <ul>
                            <li><b>sudo apt update</b></li>
                        </ul>
                        <p>The sudo command temporarily elevates that user’s privileges to complete the task and then returns them to their normal permissions.</p>

                        <h3>Configuring sudo Access</h3>
                        <p>The users who can use sudo are controlled by the sudoers file, typically located at /etc/sudoers. This file dictates which users and groups have sudo privileges and what specific commands they can run as root.</p>
                        <p>To edit this file, the command visudo is used because it checks for syntax errors before saving changes. Incorrectly modifying the sudoers file can lock out administrative access to the system.</p>
                        <p>The basic structure of the sudoers file includes:</p>
                        <ul>
                            <li><b>User permissions:</b> Allowing specific users to run commands with sudo.</li>
                            <li><b>Group permissions:</b> Allowing an entire group to use sudo.</li>
                        </ul>

                        <p>For example, to allow a user named alice to use sudo, you might add the following to the sudoers file:</p>
                        <ul>
                            <li><b>alice ALL=(ALL:ALL) ALL</b></li>
                        </ul>
                        <p>This means that the user alice can run all commands as any user on any host (typically only relevant in multi-system environments).</p>
                        <b>Limiting sudo Privileges</b>
                        <p>You can also restrict which commands a user can run with sudo. For instance, if you want bob to only be able to restart the web server, you could add:</p>
                        <ul>
                            <li><b>bob ALL=(ALL) /bin/systemctl restart apache2</b></li>
                        </ul>
                        <p>This grants bob permission to run only the systemctl restart apache2 command as root, but nothing else.</p>
                        <b>Best Practices for Using sudo</b>
                        <ul>
                            <li><b>Use sudo Instead of Root Logins:</b> Rather than giving users full root access, use sudo to restrict which users can perform administrative tasks. This enhances security and limits the potential damage caused by mistakes.</li>
                            <li><b>Give Limited Access:</b> Where possible, grant users sudo access only to specific commands rather than blanket access to the entire system.</li>
                            <li><b>Log sudo Activity:</b> Each time a user runs a command with sudo, it is logged. This provides accountability and an audit trail for administrative actions.</li>
                            <li><b>Require Strong Passwords:</b> Since sudo uses the user’s password to confirm identity before executing a command, ensure that users have strong passwords to prevent unauthorized access.</li>
                        </ul>
                        <b>Summary of User, Group, and sudo Management</b>
                        <ul>
                            <li><b>Users:</b> Each user has a unique identity, home directory, and specific permissions. System administrators manage users by creating, modifying, or deleting them, and by assigning them to groups.</li>
                            <li><b>Groups:</b> Groups allow for collective management of permissions. Users can be assigned to one or more groups, and permissions can be granted to entire groups, simplifying access control.</li>
                            <li><b>sudo:</b> sudo allows authorized users to perform administrative tasks without needing full root access. It is configured through the sudoers file, which defines which users and groups can use sudo and for which commands.</li>
                        </ul>
                        <p>By carefully managing users, groups, and sudo access, you can maintain a secure and well-organized Linux environment.</p>

                        <h3>Understanding the /etc/passwd and /etc/shadow Files in Linux</h3>
                        <p>In Linux, user account information is stored in the /etc/passwd and /etc/shadow files. These files hold important details about users, including their login names, user IDs, home directories, shells, and more.</p>
                        <p>Let’s break down what each file does and then explain the structure of the passwd entry.</p>
                        <b>1. /etc/passwd File</b>
                        <p>The /etc/passwd file contains essential information about user accounts. Each line in the file represents a user, and the fields are separated by colons (:).</p>
                        <p>Structure of /etc/passwd:</p>
                        <ul>
                            <li><b>username:password_placeholder:UID:GID:comment:home_directory:shell</b></li>
                            <li><b>bob:x:1001:1001::/home/bob:/bin/bash</b></li>
                        </ul>
                        <p>Field Breakdown:</p>
                        <ul>
                            <li><b>bob (username):</b></li>
                        </ul>
                        <p>This is the username. It’s used to log in, and it’s the unique name for this user on the system.</p>
                        <p>x (password placeholder):</p>
                        <p>In older systems, this field used to contain the encrypted password. However, for security reasons, the password is now stored in the /etc/shadow file, and a placeholder x is used here.</p>
                        <p>(Note: In older versions of Linux, this field used to store the password itself, but this was a security risk since /etc/passwd is world-readable.)</p>
                        <p><b>1001 (UID - User ID):</b><br>This is the unique User ID (UID) assigned to the user bob. It’s an integer that the system uses to identify the user. For example:</p>
                        <ul>
                            <li><b>UIDs starting from 1000 (or 1001) are used for regular user accounts.</b></li>
                        </ul>
                        <p>UIDs starting from 1000 (or 1001) are used for regular user accounts.</p>
                        <p><b>1001 (GID - Group ID):</b> <br>This is the Group ID (GID) associated with the user’s primary group. In this case, the primary group for bob has the GID of 1001. The details about the group can be found in the /etc/group file.</p>
                        <p><b>"" (comment field):</b><br>This is typically used to store a description of the user (e.g., the user's full name). In this case, it's empty, but it could contain something like "bob hope".</p>
                        <p><b>/home/bob (home directory):</b><br>This is the user’s home directory, where their personal files and configuration files are stored. When bob logs in, they are taken to /home/bob.</p>
                        <p><b>/bin/bash (default shell):</b><br>This is the user’s default shell, which is the program that runs commands when they log in. In this case, bob uses the Bash shell. Other options could be /bin/sh, /bin/zsh, etc.</p>

                        <h3>2. /etc/shadow File</h3>
                        <p>The /etc/shadow file contains encrypted password information and additional security-related details about users. This file is readable only by the root user for security purposes.</p>
                        <p>Structure of /etc/shadow:</p>
                        <ul>
                            <li><b>username:encrypted_password:last_password_change:min:max:warn:inactive:expire</b></li>
                        </ul>
                        <p>Example entry:</p>
                        <ul>
                            <li><b>bob:$6$randomhashedpassword$...:19001:0:99999:7:::</b></li>
                        </ul>
                        <p>Field Breakdown:</p>
                        <p>bob (username):</p>
                        <ul>
                            <li><b>This is the same username found in /etc/passwd.</b></li>
                        </ul>
                        <p>$6$randomhashedpassword$... (encrypted password):</p>
                        <p>This is the user’s encrypted password. The number after the first $ sign represents the encryption algorithm used:</p>
                        <ul>
                            <li><b>$1$: MD5</b></li>
                            <li><b>$2$: Blowfish</b></li>
                            <li><b>$5$: SHA-256</b></li>
                            <li><b>$6$: SHA-512 (most common in modern systems)</b></li>
                        </ul>
                        <p>If the password is locked or disabled, this field might contain ! or *.</p>
                        <p><b>19001 (last password change):</b><br>This is the date of the last password change, stored as the number of days since January 1, 1970 (the UNIX epoch). In this example, the user last changed their password 19,001 days after the epoch.</p>
                        <p><b>0 (minimum days):</b><br>The minimum number of days required before the user is allowed to change their password again. In this case, it’s 0, meaning the user can change their password anytime.</p>
                        <p><b>99999 (maximum days):</b><br>The maximum number of days a password can be used before it must be changed. In this case, 99999 days is practically unlimited.</p>
                        <p><b>7 (warning period):</b><br>The number of days before the password expires that the system will warn the user to change it.</p>
                        <p><b>:: (inactive and expiration fields):</b><br>These fields specify the number of inactive days before the account is disabled and the expiration date of the account, respectively. Both are empty here, meaning no account expiration or inactivity settings are applied.</p>

                        <h3>Summary: /etc/passwd vs. /etc/shadow</h3>
                        <p>/etc/passwd contains basic user information, such as username, UID, GID, home directory, and shell. It’s readable by everyone, but sensitive data (like the password) is stored in /etc/shadow.</p>
                        <p>/etc/shadow stores the encrypted passwords and additional information about password aging (such as expiration dates).</p>
                        <p>Example Breakdown</p>
                        <p>/etc/passwd entry:</p>
                        <ul>
                            <li><b>bob:x:1001:1001::/home/bob:/bin/bash</b></li>
                            <li><b>Username: bob</b></li>
                            <li><b>Password: Placeholder (x, meaning password is in /etc/shadow)</b></li>
                            <li><b>UID: 1001</b></li>
                            <li><b>GID: 1001</b></li>
                            <li><b>Comment: Empty (no additional information)</b></li>
                            <li><b>Home Directory: /home/bob</b></li>
                            <li><b>Shell: /bin/bash</b></li>
                        </ul>

                        <p>/etc/shadow entry:</p>
                        <ul>
                            <li><b>bob:$6$randomhashedpassword$...:19001:0:99999:7:::</b></li>
                            <li><b>Username: bob</b></li>
                            <li><b>Password: Encrypted (with SHA-512, denoted by $6$)</b></li>
                            <li><b>Last password change: 19001 days since the UNIX epoch</b></li>
                            <li><b>Min/Max password age: 0 (can change anytime) / 99999 (doesn't need to change)</b></li>
                            <li><b>Warning period: 7 days before password expiry</b></li>
                        </ul>
                        <p>By understanding the structure of these files, you can manage and troubleshoot user accounts and passwords in Linux systems efficiently.</p>
                        
                        <h3>sudo Log Files in Linux</h3>
                        <p>The sudo command is a powerful tool that allows users to execute commands with elevated privileges. Since this can be a security-sensitive action, it's important to log sudo usage for auditing purposes. In most Linux distributions, sudo commands are logged to specific log files that record details about who ran a command, when it was run, and what command was executed.</p>
                        <p>Here’s an overview of where sudo log files are located, the kind of information they contain, and why they’re useful.</p>
                        <h3>1. Location of sudo Log Files</h3>
                        <p>In most Linux distributions, sudo logs can be found in the system log files, typically located in the /var/log/ directory. The specific file depends on the distribution and its configuration.</p>
                        <p>Common log file locations:</p>
                        <ul>
                            <li><b>/var/log/auth.log (Debian-based systems, including Ubuntu)</b></li>
                            <li><b>/var/log/secure (Red Hat-based systems, including CentOS, Fedora, and RHEL)</b></li>
                        </ul>
                        <p>These files log authentication events, including sudo activity, login attempts, and security-related messages.</p>

                        <h3>2. Information Inside sudo Log Files</h3>
                        <p>The sudo logs capture important information about each sudo command execution. This includes:</p>
                        <ul>
                            <li><b>Timestamp:</b> The date and time when the sudo command was executed.</li>
                            <li><b>Username:</b> The user who invoked sudo.</li>
                            <li><b>Command:</b> The exact command the user ran with sudo.</li>
                            <li><b>Terminal:</b> The terminal from which the sudo command was executed (useful for tracing if the command was run remotely or locally).</li>
                            <li><b>Host:</b> The hostname or system where the command was run.</li>
                            <li><b>Outcome:</b> Whether the command succeeded or failed.</li>
                        </ul>
                        <p>Example log entry (from /var/log/auth.log):</p>
                        <ul>
                            <li><b>Oct 12 14:55:05 servername sudo:  bob : TTY=pts/1 ; PWD=/home/bob ; USER=root ; COMMAND=/bin/ls /root</b></li>
                        </ul>
                        <p>Breaking it down:</p>
                        <ul>
                            <li><b>Date and Time:</b> Oct 12 14:55:05 — The exact time the command was executed.</li>
                            <li><b>Hostname:</b> servername — The name of the machine where the command was run.</li>
                            <li><b>User:</b> bob — The username of the person who ran the command.</li>
                            <li><b>TTY:</b> pts/1 — The terminal (TTY) used to execute the command (could be local or remote).</li>
                            <li><b>PWD:</b> /home/bob — The present working directory from where the command was run.</li>
                            <li><b>USER:</b> root — The target user (in this case, the user gained root privileges).</li>
                            <li><b>COMMAND:</b> /bin/ls /root — The actual command executed with sudo.</li>
                        </ul>

                        <h3>3. How to View sudo Logs</h3>
                        <p>To view the sudo logs, you can open the relevant log file with a text editor or use the grep command to filter out sudo entries.</p>
                        <p>Example on Ubuntu:</p>
                        <p>To view sudo logs in Ubuntu, open /var/log/auth.log:</p>
                        <ul>
                            <li><b>sudo less /var/log/auth.log</b></li>
                        </ul>
                        <p>To specifically filter for sudo commands:</p>
                        <ul>
                            <li><b>grep 'sudo' /var/log/auth.log</b></li>
                        </ul>
                        <p>Example on Red Hat-based systems:</p>
                        <p>On RHEL or CentOS, sudo activity is logged in /var/log/secure:</p>
                        <ul>
                            <li><b>sudo less /var/log/secure</b></li>
                        </ul>
                        <p>To view just the sudo entries:</p>
                        <ul>
                            <li><b>grep 'sudo' /var/log/secure</b></li>
                        </ul>

                        <h3>4. Useful Information</h3>
                        <p><b>Security Auditing:</b><br>The logs help monitor which users are using sudo and what commands they are running. This is critical for auditing purposes, as it provides insight into potential misuse or unauthorized access attempts.</p>
                        <p><b>Troubleshooting:</b><br>If an administrative command fails or behaves unexpectedly, reviewing sudo logs can help you see if the correct command was issued or if there were permission problems.</p>
                        <p><b>Detecting Suspicious Activity:</b><br>Logs help detect unusual sudo usage, such as users running unexpected commands, executing commands they don’t normally use, or attempts to elevate privileges when they shouldn’t.</p>
                        <p><b>Tracking Remote Access:</b><br>Since the logs capture the terminal from which the command was executed (e.g., pts/1), you can trace whether commands were run remotely via SSH or locally. This can help spot remote users executing commands they shouldn’t be.</p>

                        <h3>5. Configuring sudo Logs</h3>
                        <p>By default, sudo logs to the system logs (like /var/log/auth.log or /var/log/secure), but you can configure it to log to a different location or with more detailed information if needed.</p>
                        <p>To configure sudo logging behavior, you can modify the /etc/sudoers file using visudo. You can adjust parameters like:</p>
                        <ul>
                            <li><b>Log output location:</b> Specify custom log files.</li>
                            <li><b>Detailed logging:</b> Control the verbosity of sudo logs.</li>
                        </ul>
                        <p>For example, adding this line to /etc/sudoers logs all commands to a specific log file:</p>
                        <ul>
                            <li><b>Defaults logfile="/var/log/sudo.log"</b></li>
                        </ul>

                        <h3>6. Rotating Log Files</h3>
                        <p>Since /var/log/ files can grow large over time, Linux systems use a log rotation mechanism to manage log sizes. This ensures that old log files are archived and compressed, and new log files are created.</p>
                        <p>Log rotation is typically managed by the logrotate service, which automatically rotates files like /var/log/auth.log or /var/log/secure. You can configure how often the logs are rotated and how many old logs to keep.</p>
                        <p>Summary of sudo Log Files:</p>
                        <p>Location:</p>
                        <ul>
                            <li><b>/var/log/auth.log (Debian/Ubuntu)</b></li>
                            <li><b>/var/log/secure (Red Hat/CentOS)</b></li>
                        </ul>
                        <p>Contents: Includes the user who invoked sudo, the command they ran, the time, the terminal, and whether the command was successful or failed.</p>
                        <p>Useful for:</p>
                        <ul>
                            <li><b>Security auditing:</b> Tracking privileged commands.</li>
                            <li><b>Troubleshooting:</b> Understanding why a command failed or produced unexpected results.</li>
                            <li><b>Detecting suspicious or unauthorized activity.</b></li>
                        </ul>
                        <p>By understanding and reviewing sudo log files, administrators can keep a close watch on system usage, ensuring security and compliance with system policies.</p>


                        <div class="dropdown">
                            <button onclick="toggleDropdown('week3day2exercises')">Exercises</button>
                            <div id="week3day2exercises" class="dropdown-content">
                                <p>Here are 10 exercises for you to practice managing users and groups on a Linux virtual machine. These exercises will help you get comfortable with creating, modifying, and deleting users and groups, as well as configuring permissions with sudo.</p>

                                <h3>Exercise 1: Add a New User</h3>
                                <p>Create a new user named alice with:</p>
                                <ul>
                                    <li><b>A home directory.</b></li>
                                    <li><b>The default Bash shell.</b></li>
                                </ul>
                                <p>Set a password for alice.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use useradd with the appropriate options.</b></li>
                                    <li><b>Use passwd to set the password.</b></li>
                                </ul>

                                <h3>Exercise 2: Add a User with a Custom Shell</h3>
                                <p>Create a new user named bob with:</p>
                                <ul>
                                    <li><b>A home directory.</b></li>
                                    <li><b>The /bin/sh shell instead of the default Bash shell.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use useradd with the -m and -s options.</b></li>
                                    <li><b>Verify by logging in as bob and checking the shell.</b></li>
                                </ul>

                                <h3>Exercise 3: Modify an Existing User's Home Directory</h3>
                                <ul>
                                    <li><b>Change bob’s home directory from /home/bob to /home/bob_new.</b></li>
                                    <li><b>Move all files from the old home directory to the new one.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use usermod with -d and -m options.</b></li>
                                </ul>

                                <h3>Exercise 4: Add a User to a Group</h3>
                                <ul>
                                    <li><b>Create a new group called developers.</b></li>
                                    <li><b>Add alice to the developers group.</b></li>
                                    <li><b>Verify that alice is now in the developers group.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use groupadd to create the group.</b></li>
                                    <li><b>Use usermod -aG to add alice to the group.</b></li>
                                    <li><b>Check group membership with the groups command.</b></li>
                                </ul>

                                <h3>Exercise 5: Create a System User</h3>
                                <p>Create a system user named service_user with:</p>
                                <ul>
                                    <li><b>No home directory.</b></li>
                                    <li><b>A non-login shell /usr/sbin/nologin.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use useradd with the -r, -M, and -s options.</b></li>
                                </ul>

                                <h3>Exercise 6: Lock and Unlock a User Account</h3>
                                <ul>
                                    <li><b>Lock bob’s account to prevent him from logging in.</b></li>
                                    <li><b>Attempt to log in as bob.</b></li>
                                    <li><b>Unlock bob’s account and verify he can log in again.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use usermod -L to lock the account.</b></li>
                                    <li><b>Use usermod -U to unlock the account.</b></li>
                                </ul>

                                <h3>Exercise 7: Set an Expiry Date for a User</h3>
                                <ul>
                                    <li><b>Create a new user named temporary_user.</b></li>
                                    <li><b>Set the account expiration date to 30 days from today.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use useradd with the -e option.</b></li>
                                    <li><b>Use chage -l temporary_user to verify the expiration date.</b></li>
                                </ul>

                                <h3>Exercise 8: Delete a User Without Removing the Home Directory</h3>
                                <p>	Delete the user temporary_user, but keep their home directory intact.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use userdel without the -r option.</b></li>
                                </ul>

                                <h3>Exercise 9: Delete a User and Remove Their Home Directory</h3>
                                <p>Delete the user alice and remove her home directory and mail spool.</p>

                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use userdel -r to delete the user and their files.</b></li>
                                </ul>

                                <h3>Exercise 10: Manage Sudo Access</h3>
                                <ul>
                                    <li><b>Add the user bob to the sudo group so that he can run administrative commands.</b></li>
                                    <li><b>Switch to bob and use the sudo command to install a package.</b></li>
                                    <li><b>Remove bob from the sudo group.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Use usermod -aG sudo to grant sudo access.</b></li>
                                    <li><b>Switch users using su - bob and test sudo.</b></li>
                                    <li><b>Use gpasswd -d bob sudo to remove bob from the group.</b></li>
                                </ul>

                                <h3>Bonus Exercise: Create a User with Specific Group Membership</h3>
                                <ul>
                                    <li><b>Create a user named charlie who belongs to two groups: developers and testers.</b></li>
                                    <li><b>Verify that charlie is in both groups.</b></li>
                                </ul>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Create the testers group if it doesn't exist.</b></li>
                                    <li><b>Use useradd with -G developers,testers.</b></li>
                                    <li><b>Verify with the groups command.</b></li>
                                </ul>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week3day3')">Day 3</button>
                <div id="week3day3" class="dropdown-content">
                    <div class="day-title">Disk Management</div>
                    <div class="day-info">
                        <h3>Disk Partitions and Filesystems in Linux</h3>
                        <p>Understanding how to manage disk partitions and filesystems is essential for administering Linux systems. Disk partitions allow a single disk to be divided into multiple logical storage units, while filesystems determine how data is stored and accessed on each partition. Tools like fdisk, mkfs, and mount are used to manage and work with disk partitions and filesystems in Linux.</p>
                        <p>Let’s break this down step-by-step, including how each tool is used.</p>
                        
                        <h3>1. Disk Partitions</h3>
                        <p>A disk partition is a logical division of a hard disk. A single physical disk can be split into multiple partitions, each of which can contain its own filesystem.</p>
                        <b>Why Use Partitions?</b>
                        <ul>
                            <li><b>Separation:</b> Different partitions can be used for different purposes (e.g., separating the operating system files, user files, or swap space).</li>
                            <li><b>Multi-boot Systems:</b> Having multiple partitions allows different operating systems to coexist on the same disk.</li>
                            <li><b>Data Organization:</b> Partitions help in organizing data, backups, or specific software requirements.</li>
                        </ul>

                        <h3>2. Filesystems</h3>
                        <p>A filesystem is the structure that dictates how data is stored, organized, and retrieved on a partition. Common filesystems in Linux include:</p>
                        <ul>
                            <li><b>ext4:</b> The most widely used filesystem in Linux.</li>
                            <li><b>XFS:</b> Known for its high performance, especially with large files.</li>
                            <li><b>Btrfs:</b> A newer filesystem with features like snapshots and pooling.</li>
                            <li><b>FAT32, NTFS:</b> Common on Windows systems and for cross-platform compatibility (e.g., external drives).</li>
                            <li><b>Mounting:</b> Attaching a filesystem to the system’s directory tree so it can be accessed.</li>
                            <li><b>Unmounting:</b> Detaching a filesystem when you no longer need access to it.</li>
                            <li><b>Superblock:</b> A part of the filesystem that contains metadata (information about the size, status, etc.).</li>
                        </ul>

                        <h3>3. Tools for Managing Partitions and Filesystems</h3>
                        <p>Here are some of the core Linux utilities for managing partitions and filesystems:</p>
                        <ul>
                            <li><b>fdisk: Disk Partitioning Tool</b></li>
                        </ul>

                        <p>fdisk is used to create, delete, modify, and view disk partitions.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b> sudo fdisk /dev/sdX</b></li>
                        </ul>
                        <p>Replace /dev/sdX with your disk name (e.g., /dev/sda for the first disk).</p>
                        <p>Basic Commands in fdisk:</p>
                        <ul>
                            <li><b>p:</b> Print the partition table to see existing partitions.</li>
                            <li><b>n:</b> Create a new partition.</li>
                            <li><b>d:</b> Delete a partition.</li>
                            <li><b>w:</b> Write changes and exit.</li>
                            <li><b>q:</b> Quit without saving changes.</li>
                        </ul>

                        <p>mkfs: Create Filesystems</p>
                        <p>Once you have a partition, you need to create a filesystem on it using the mkfs (make filesystem) command.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo mkfs -t ext4 /dev/sdXn</b></li>
                            <li><b>-t ext4 specifies the filesystem type (you can change this to xfs, btrfs, etc.).</b></li>
                            <li><b>/dev/sdXn is the partition where the filesystem is being created (e.g., /dev/sda1).</b></li>
                        </ul>

                        <p>mount: Mounting Filesystems</p>
                        <p>After creating a filesystem, it must be mounted so that the system can access it.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>sudo mount /dev/sdXn /mnt</b></li>
                            <li><b>/dev/sdXn is the partition being mounted (e.g., /dev/sda1).</b></li>
                            <li><b>/mnt is the directory where the partition will be attached (you can choose any directory).</b></li>
                        </ul>

                        <p>To unmount a filesystem, use:</p>
                        <ul>
                            <li><B>sudo umount /mnt</B></li>
                        </ul>
                        <p>Permanent Mounting:</p>
                        <p>You can configure a partition to be automatically mounted at boot by editing the /etc/fstab file.</p>
                        <p>lsblk: View Block Devices</p>
                        <p>lsblk displays a detailed list of available storage devices and their partitions.</p>
                        <p>Command:</p>
                        <ul>
                            <li><b>lsblk</b></li>
                        </ul>
                        <p>df: Check Disk Space</p>
                        <ul>
                            <li><b>df shows how much disk space is used and available on mounted filesystems.</b></li>
                        </ul>
                        <p>Command:</p>
                        <ul>
                            <li><b>df -h</b></li>
                        </ul>

                        <h3>4. Example Workflow: Creating and Mounting a Partition</h3>
                        <p>Here’s a basic example of how to create, format, and mount a new partition:</p>
                        <p>Step 1: Check Available Disks</p>
                        <ul>
                            <li><b>lsblk</b></li>
                        </ul>
                        <p>This shows all available disks and partitions. Let's say you see /dev/sda with some free space.</p>
                        <p>Step 2: Partition the Disk</p>
                        <p>Use fdisk to create a new partition:</p>
                        <ul>
                            <li><b>sudo fdisk /dev/sda</b></li>
                        </ul>
                        <p>Type n to create a new partition.<br>Accept the default values (or set custom sizes if you need).<br>Type w to write changes and exit.</p>

                        <h3>Step 3: Format the Partition</h3>
                        <p>Now that you have a new partition (e.g., /dev/sda3), format it with mkfs:</p>
                        <ul>
                            <li><b>sudo mkfs -t ext4 /dev/sda3</b></li>
                        </ul>

                        <h3>Step 4: Mount the Partition</h3>
                        <p>Mount the partition to a directory (e.g., /mnt/newdata):</p>
                        <ul>
                            <li><b>sudo mkdir /mnt/newdata</b></li>
                            <li><b>sudo mount /dev/sda3 /mnt/newdata</b></li>
                        </ul>

                        <h3>Step 5: Verify Mount</h3>
                        <p>Use df or lsblk to verify that the partition is mounted:</p>
                        <p>df -h</p>

                        <h3>5. Other Useful Disk Utilities</h3>
                        <p> parted: Similar to fdisk, but more powerful and supports GPT partitioning (for disks larger than 2 TB).</p>
                        <p>parted also allows resizing partitions.</p>

                        <p>blkid: Shows information about block devices, including UUID and filesystem type.</p>
                        <ul>
                            <li><b>sudo blkid</b></li>
                        </ul>
                        <p>fsck: Used to check and repair filesystems.</p>
                        <ul>
                            <li><b>sudo fsck /dev/sda1</b></li>
                        </ul>
                        <p>mount -a: Re-mounts all filesystems listed in /etc/fstab.</p>

                        <h3>6. Filesystem Mounting Options (in /etc/fstab)</h3>
                        <p>When adding an entry to /etc/fstab, you can specify how a filesystem should be mounted at boot. Here’s an example entry:</p>
                        <ul>
                            <li><b>/dev/sda3  /mnt/newdata  ext4  defaults  0  2</b></li>
                        </ul>

                        <p>Fields:</p>
                        <ul>
                            <li><b>Device:</b> /dev/sda3 — the partition being mounted.</li>
                            <li><b>Mount Point:</b> /mnt/newdata — where it will be mounted.</li>
                            <li><b>Filesystem:</b> ext4 — the type of filesystem.</li>
                            <li><b>Options:</b> defaults — common default mount options.</li>
                            <li><b>Dump: 0 — whether the filesystem should be backed up (usually 0).</b></li>
                            <li><b>Pass: 2 — the order in which filesystems are checked (root filesystem is usually 1).</b></li>
                        </ul>

                        <h3>7. Important Considerations</h3>
                        <p>Partition Table Types: Older disks use the MBR partitioning scheme, while newer disks (especially those over 2 TB) use the GPT partitioning scheme, supported by tools like parted and gdisk.</p>
                        <p>Backup Important Data: Before creating, modifying, or deleting partitions, always back up your data. Partitioning operations can result in data loss if done incorrectly.</p>
                        <p>Unmounting Safely: Always unmount a partition before making changes to avoid data corruption.</p>

                        <p>Summary</p>
                        <ul>
                            <li><b>Disk Partitions divide a physical disk into multiple logical sections, each of which can have its own filesystem.</b></li>
                            <li><b>Filesystems determine how data is stored, with common types being ext4, XFS, and Btrfs.</b></li>
                            <li><b>Tools like fdisk (partitioning), mkfs (formatting), and mount (mounting) are essential for managing disks in Linux.</b></li>
                            <li><b>Use lsblk, df, and blkid to inspect your storage devices, and modify /etc/fstab to make mounting permanent.</b></li>
                        </ul>

                        <h3>Step-by-Step Walkthrough for Manual Partitioning</h3>

                        <h3>Step 1: Boot from Installation Media</h3>
                        <ul>
                            <li><b>First, you’ll need to boot your machine from the installation media (like a USB stick or DVD) with your chosen Linux distribution (e.g., Ubuntu).</b></li>
                            <li><b>Select “Try Ubuntu” or “Install Ubuntu” depending on your distro, and choose to go through the installer steps until you reach the partitioning section.</b></li>
                        </ul>

                        <h3>Step 2: Choose Manual Partitioning</h3>
                        <p>During the installation process, you’ll eventually come to a screen asking how you want to set up the disk. You'll see options like:</p>
                        <ul>
                            <li><b>Erase disk and install Ubuntu (automatic partitioning)</b></li>
                            <li><b>Something else (manual partitioning)</b></li>
                        </ul>

                        <p>Choose “Something else” to manually create partitions.</p>

                        <h3>Step 3: Understanding the Partitioning Scheme</h3>
                        <p>Before you create the partitions, you should know what partitions are typically needed on a Linux system:</p>
                        <ul>
                            <li><b>Root (/) Partition: This is where your operating system and applications are installed.</b></li>
                            <li><b>Swap Partition: This acts like extra RAM if your system runs out of physical memory.</b></li>
                            <li><b>Home (/home) Partition: This is where your personal files and settings are stored.</b></li>
                            <li><b>EFI Partition (if using UEFI booting): This is needed for newer systems using UEFI firmware to boot.</b></li>
                        </ul>

                        <p>Let’s assume you have a 500 GB hard drive. Here’s a basic setup you might use:</p>
                        <ul>
                            <li><b>250 GB for the root (/) partition</b></li>
                            <li><b>4 GB for the swap partition</b></li>
                            <li><b>240 GB for the home (/home) partition</b></li>
                            <li><b>~512 MB for the EFI partition (if needed)</b></li>
                        </ul>

                        <h3>Step 4: Creating Partitions Using the Installer</h3>
                        <p>Now, let’s create the partitions one by one. In the partitioning menu, you will see the disk available (e.g., /dev/sda). It will show as unallocated or free space.</p>
                        <p>1. EFI Partition (if your machine uses UEFI):</p>
                        <ul>
                            <li><b>Select free space and click Add.</b></li>
                            <li><b>Choose Primary as the partition type.</b></li>
                            <li><b>For the size, enter 512 MB.</b></li>
                            <li><b>For Use as, select EFI System Partition.</b></li>
                            <li><b>Click OK.</b></li>
                        </ul>
                        <p>This is where the system will store boot information if using UEFI. If you're using BIOS instead of UEFI, you don’t need this partition.</p>

                        <p>2. Root Partition (/):</p>
                        <p>Select the remaining free space and click Add.</p>
                        <ul>
                            <li><b>Choose Primary.</b></li>
                            <li><b>For the size, allocate around 250 GB (250,000 MB) or as much as you want for the system files and applications.</b></li>
                            <li><b>For Use as, choose ext4 (the most common filesystem for Linux).</b></li>
                            <li><b>Set the mount point to / (the root directory).</b></li>
                            <li><b>Click OK.</b></li>
                        </ul>

                        <p>The root partition will contain the operating system, system files, and applications.</p>

                        <p>3. Swap Partition:</p>
                        <p>Select the remaining free space and click Add.</p>
                        <ul>
                            <li><b>Choose Primary.</b></li>
                            <li><b>For the size, set it to 4 GB (4096 MB) or the amount of swap space you need. Typically, it’s 1-2 times the amount of RAM, but 4 GB is a good general size.</b></li>
                            <li><b>For Use as, select swap area.</b></li>
                            <li><b>Click OK.</b></li>
                        </ul>

                        <p>Swap space is used when your system runs out of RAM, acting as temporary memory on the disk.</p>

                        <p>4. Home Partition (/home):</p>
                        <p>Select the remaining free space and click Add.</p>
                        <ul>
                            <li><b>Choose Primary.</b></li>
                            <li><b>For the size, use the rest of the free space (approximately 240 GB in this case).</b></li>
                            <li><b>For Use as, choose ext4.</b></li>
                            <li><b>Set the mount point to /home (this is where your personal files and settings will be stored).</b></li>
                            <li><b> Click OK.</b></li>
                        </ul>

                        <h3>Step 5: Review and Apply the Changes</h3>
                        <p>Once you have created all the partitions (EFI, root, swap, and home), review them in the partition table. It should look something like this:</p>
                        <ul>
                            <li><b>/dev/sda1: EFI System Partition (if using UEFI) ~512 MB</b></li>
                            <li><b>/dev/sda2: Root partition (/) ~250 GB (ext4)</b></li>
                            <li><b>/dev/sda3: Swap partition ~4 GB (swap area)</b></li>
                            <li><b>/dev/sda4: Home partition (/home) ~240 GB (ext4)</b></li>
                        </ul>

                        <p>If everything looks correct, proceed by clicking Install Now. The installer will write the partitions to the disk and start copying the files.</p>

                        <h3>Step 6: Completing the Installation</h3>
                        <ul>
                            <li><b>Follow the remaining prompts, such as setting your time zone, creating your user account, and setting passwords.</b></li>
                            <li><b>After the installation completes, restart your machine.</b></li>
                        </ul>

                        <p>Why Manual Partitioning Is Useful:</p>
                        <ul>
                            <li><b>Control: You can decide how much space to allocate for the system versus your personal files.</b></li>
                            <li><b>Data Safety: If you have a separate /home partition, your personal files are safer during a system reinstall (as long as you don’t format /home during the reinstall).</b></li>
                            <li><b>Performance: Swap partitions can improve performance in low-memory systems, and manual partitioning can be optimized for different workloads.</b></li>
                        </ul>



                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week3day4')">Day 4</button>
                <div id="week3day4" class="dropdown-content">
                    <div class="day-title">System Monitoring and Performance</div>
                    <div class="day-info">
                        <p>Monitoring system performance is essential for keeping an eye on how your Linux machine is running—checking things like CPU usage, memory consumption, disk activity, and running processes. Let’s talk about some key commands to monitor performance:</p>
                        <p>Monitoring System Performance:</p>
                        <h3>1. top (Task Manager for Linux):</h3>
                        <p>The top command is a real-time system monitor that displays running processes and resource usage.</p>
                        <ul>
                            <li><b>It shows information like CPU usage, memory usage, load average, running processes, and more.</b></li>
                            <li><b>You can see which processes are using the most resources, making it easy to identify any performance issues.</b></li>
                        </ul>

                        <p>Example of what top displays:</p>
                        <ul>
                            <li><b>PID:</b> Process ID</li>
                            <li><b>USER:</b> The user running the process</li>
                            <li><b>%CPU:</b> Percentage of CPU usage by the process</li>
                            <li><b>%MEM:</b> Percentage of memory used by the process</li>
                            <li><b>COMMAND:</b> The name of the process</li>
                        </ul>

                        <p>You can sort processes by CPU usage, memory usage, and even kill processes directly from top by pressing the k key followed by the process ID</p>

                        <h3>2. htop (Enhanced top):</h3>
                        <p>htop is like top, but with a more colorful and user-friendly interface.</p>
                        <ul>
                            <li><b>It provides a clearer view of system resources, including CPU, memory, and swap usage, displayed in graphs.</b></li>
                            <li><b>htop also allows you to scroll through the list of processes, search for specific ones, and manage them easily.</b></li>
                            <li><b>Unlike top, it’s not installed by default on many systems, so you might need to install it (sudo apt install htop).</b></li>
                        </ul>
                        <p>Key features:</p>
                        <ul>
                            <li><b>Interactive and easier to use.</b></li>
                            <li><b>Displays CPU core usage separately.</b></li>
                            <li><b>You can sort, filter, and kill processes with simple keystrokes.</b></li>
                        </ul>

                        <h3>3. iostat (Input/Output Statistics):</h3>
                        <p>The iostat command is used to monitor system input/output device loading by observing the time the devices are active compared to their average transfer rates.</p>
                        <ul>
                            <li><b>It’s useful for understanding how disk I/O is impacting performance.</b></li>
                            <li><b>It shows the disk read/write speeds, the number of operations per second, and the CPU usage.</b></li>
                        </ul>
                        <p>This command is often used by system administrators to detect bottlenecks in disk subsystems.</p>

                        <h3>4. vmstat (Virtual Memory Statistics):</h3>
                        <p>vmstat provides detailed information about system performance, focusing on processes, memory, paging, block I/O, traps, and CPU activity.</p>
                        <ul>
                            <li><b>It gives you a quick overview of how much memory is free, how much is being swapped in and out, and the amount of CPU time spent on different tasks.</b></li>
                            <li><b>It’s great for detecting issues with memory or CPU usage that may not be obvious from other tools.</b></li>
                        </ul>

                        <p>5. Log Files and System Logging:</p>
                        <p>Log files are like the diaries of your Linux system. They record everything happening on your system, from successful operations to errors, which is useful for troubleshooting, performance monitoring, and system auditing.</p>

                        <p>1. /var/log/ Directory:</p>
                        <p>Most system logs are stored in the /var/log/ directory. This is where you’ll find logs for different services, system events, and applications.</p>
                        <p>Here are some key log files:</p>
                        <ul>
                            <li><b>/var/log/syslog or /var/log/messages:</b> These files contain general system logs, including messages from the kernel, boot process, and system services.</li>
                            <li><b>/var/log/auth.log:</b> This file contains logs related to authentication events (like login attempts), both successful and failed.</li>
                            <li><b>/var/log/dmesg:</b> This file holds messages from the kernel ring buffer, usually related to hardware and drivers.</li>
                            <li><b>/var/log/apt/:</b> Contains logs related to package management (like updates or installations via apt).</li>
                            <li><b>/var/log/kern.log:</b> Logs from the kernel itself.</li>
                            <li><b> /var/log/boot.log:</b> Logs from the boot process, detailing what happens when the system starts up.</li>
                        </ul>

                        <p>2. journalctl (Systemd Logs):</p>
                        <p>If your Linux system uses systemd (which many modern Linux distros do), the command journalctl is used to access the system logs.</p>
                        <p>journalctl collects logs from all system services and applications in one place. You can view logs by date, severity, or related to specific services.</p>
                        <p>Example usage:</p>
                        <ul>
                            <li><b>journalctl -xe - shows recent logs with more detail.</b></li>
                            <li><b>journalctl -n - To view the last 10 event messages. You can view the last n entries by using journalctl -n {number}</b></li>
                            <li><b>journalctl -f - To output new journal entries as they are written to the journal.</b></li>
                            <li><b>journalctl -k - Run the following command to display the kernel message log from the last boot.</b></li>
                            <li><b>journalctl -p crit - To view journal entries based on their critical priority.</b></li>
                            <li><b>journalctl --since today - To view journal entries for today.</b></li>
                            <li><b>journalctl -u sshd - To view journal entries related to the sshd daemon</b></li>
                            <li><b>journalctl -u httpd –since "1 hour ago" - To check for messages related to the httpd service for the past hour.</b></li>
                        </ul>

                        <p>3. dmesg (Kernel Ring Buffer):</p>
                        <p>The dmesg command shows messages from the kernel ring buffer, mostly related to hardware and driver events.</p>
                        <ul>
                            <li><b>If you’re troubleshooting hardware issues (like a new device not being recognized), dmesg is a helpful tool.</b></li>
                            <li><b>You can filter these messages to find specific types of errors or warnings, such as disk or network issues.</b></li>
                        </ul>

                        <p>Summary:</p>
                        <p>Monitoring Performance:</p>
                        <ul>
                            <li><b>top and htop: Monitor system resource usage and processes in real time.</b></li>
                            <li><b>iostat: Monitor disk I/O performance.</b></li>
                            <li><b>vmstat: Get detailed virtual memory statistics and system performance insights.</b></li>
                        </ul>

                        <b>Log Files and System Logging:</b>
                        <ul>
                            <li><b>Most system logs are stored in /var/log/.</b></li>
                            <li><b>Important logs include syslog (general system messages), auth.log (authentication events), and dmesg (kernel-related messages).</b></li>
                            <li><b>journalctl can be used to manage and view logs in systems that use systemd.</b></li>
                        </ul>

                        <p>Understanding system performance and logs is key to troubleshooting and optimizing your Linux system!</p>

                        <p>Common Linux log files names and usage:</p>
                        <ul>
                            <li><b>/var/log/messages:</b> General message and system related stuff</li>
                            <li><b>/var/log/auth.log:</b> Authenication logs</li>
                            <li><b>/var/log/kern.log:</b> Kernel logs</li>
                            <li><b>/var/log/cron.log:</b> Crond logs (cron job)</li>
                            <li><b>/var/log/maillog:</b> Mail server logs</li>
                            <li><b>/var/log/qmail/:</b> Qmail log directory (more files inside this directory)</li>
                            <li><b>/var/log/httpd/:</b> Apache access and error logs directory</li>
                            <li><b>/var/log/lighttpd/:</b> Lighttpd access and error logs directory</li>
                            <li><b>/var/log/nginx/:</b> Nginx access and error logs directory</li>
                            <li><b>/var/log/apt/:</b> Apt/apt-get command history and logs directory</li>
                            <li><b>/var/log/boot.log:</b> System boot log</li>
                            <li><b>/var/log/mysqld.log:</b> MySQL database server log file</li>
                            <li><b>/var/log/secure or /var/log/auth.log:</b> Authentication log</li>
                            <li><b>/var/log/utmp or /var/log/wtmp:</b> Login records file</li>
                            <li><b>/var/log/yum.log or /var/log/dnf.log:</b> Yum/Dnf command log file.</li>
                        </ul>
                        <b>Examples of some log files</b>
                        <p>Example 1: /var/log/syslog or /var/log/messages</p>
                        <p>This file contains general system messages, including information from the kernel, boot process, and system services. Here’s an example of what a few lines might look like:</p>
                        <ul>
                            <li><b>Oct 13 10:30:25 my-computer systemd[1]: Started Network Manager Script Dispatcher Service.</b></li>
                            <li><b>Oct 13 10:30:25 my-computer systemd[1]: Starting Cleanup of Temporary Directories...</b></li>
                            <li><b>Oct 13 10:30:25 my-computer systemd[1]: Finished Cleanup of Temporary Directories.</b></li>
                            <li><b>Oct 13 10:31:00 my-computer gnome-shell[1720]: [1734:1734:1013/103100.123456:ERROR:gl_context.cc(235)] Failed to make current with error GLXBadContext.</b></li>
                        </ul>
                        <p>Breaking It Down:</p>
                        <p>Oct 13 10:30:25: This is the timestamp, telling you when the event occurred (date and time).</p>
                        <p>my-computer: This is the hostname of the machine generating the log entry.</p>
                        <p>systemd[1]: This is the process name (systemd in this case) and the process ID (in brackets). systemd is the system and service manager on Linux.</p>
                        <p>Started Network Manager Script Dispatcher Service: This is the actual message describing what happened. In this case, the Network Manager's Script Dispatcher Service has started.</p>
                        <p>The gnome-shell error at the end of the log refers to a graphical shell (in this case, GNOME) encountering an OpenGL error (Failed to make current with error GLXBadContext), which could indicate an issue with rendering the desktop environment.</p>

                        <b>Example 3: /var/log/dmesg</b>
                        <ul>
                            <li><b>[    1.234567] usb 1-1: new high-speed USB device number 4 using xhci_hcd</b></li>
                            <li><b>[    1.678901] ata1: SATA link up 6.0 Gbps (SStatus 133 SControl 300)</b></li>
                            <li><b>[    3.456789] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)</b></li>
                            <li><b>[    5.678901] Bluetooth: hci0: Firmware revision 0.1 build 1234 week 01 2021</b></li>
                            <li><b>[    6.123456] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready</b></li>
                            <li><b>[    7.890123] eth0: link becomes ready</b></li>
                        </ul>

                        <p>Breaking It Down:</p>
                        <ul>
                            <li><b>[ 1.234567]: The time since the system started (in seconds) when the message was logged.</b></li>
                            <li><b>usb 1-1: new high-speed USB device number 4 using xhci_hcd: This indicates that a new USB device was detected and assigned device number 4 on the xhci_hcd USB controller.</b></li>
                            <li><b>ata1: SATA link up 6.0 Gbps: This shows that the SATA drive connected to the system is operating at 6.0 Gbps.</b></li>
                            <li><b>EXT4-fs (sda1): mounted filesystem: The EXT4 filesystem was successfully mounted on the device /dev/sda1.</b></li>
                            <li><b>Bluetooth: hci0: Firmware revision 0.1 build 1234: Indicates a Bluetooth device (hci0) with a specific firmware revision.</b></li>
                            <li><b>IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready: The Ethernet interface (eth0) was not yet ready at this point, but later we see it.</b></li>
                            <li><b>eth0: link becomes ready: This shows that the Ethernet connection has been successfully established.</b></li>
                        </ul>

                        <b>Example 4: /var/log/boot.log</b>
                        <p>This file logs the output of the boot process, showing services and processes that start up when the system boots.</p>
                        <ul>
                            <li><b>[  OK  ] Started Network Manager.</b></li>
                            <li><b>[  OK  ] Started Authorization Manager.</b></li>
                            <li><b>[FAILED] Failed to start Light Display Manager.</b></li>
                            <li><b>[  OK  ] Reached target Graphical Interface.</b></li>
                            <li><b>[  OK  ] Started CUPS Scheduler.</b></li>
                        </ul>

                        <p>Breaking It Down:</p>
                        <ul>
                            <li><b>[ OK ] Started Network Manager:</b> This indicates that the Network Manager service started successfully during boot.</li>
                            <li><b>[FAILED] Failed to start Light Display Manager:</b> This indicates an error—specifically, the Light Display Manager (responsible for graphical login screens) failed to start.</li>
                            <li><b>Reached target Graphical Interface:</b> Despite the Light Display Manager failing, the system was able to reach the graphical interface (though it might have used a fallback).</li>
                            <li><b>Started CUPS Scheduler:</b> The CUPS printing service started successfully.</li>
                        </ul>
                        <p>CUPS stands for Common Unix Printing System. It is a modular printing system for Unix-like operating systems (like Linux and macOS) that allows a computer to act as a print server.</p>
                        <p>In this case, the key message to note is the FAILED entry, which highlights an issue that might need troubleshooting (perhaps the display manager wasn’t configured properly).</p>

                        <b>Example 5: /var/log/kern.log</b>
                        <p>This file records kernel-specific messages. Here’s an example:</p>
                        <ul>
                            <li><b>Oct 13 10:31:05 my-computer kernel: [   1.234567] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.11.0-37-generic #41~20.04.2-Ubuntu</b></li>
                            <li><b>Oct 13 10:31:05 my-computer kernel: [   1.234569] Spectre V2 : Enabling Restricted Speculation for firmware calls</b></li>
                            <li><b>Oct 13 10:31:05 my-computer kernel: [   3.567890] nouveau 0000:01:00.0: DRM: VRAM: 2048 MiB</b></li>
                        </ul>
                        <p>Breaking It Down:</p>
                        <ul>
                            <li><b>kernel:: Indicates that these are messages coming from the kernel itself.</b></li>
                            <li><b>CPU: 1 PID: 1 Comm: swapper/0: This specifies the CPU core, process ID (1), and the process (swapper/0) involved in the event.</b></li>
                            <li><b>Spectre V2 : Enabling Restricted Speculation for firmware calls: This message refers to security mitigation for the Spectre vulnerability.</b></li>
                            <li><b>nouveau 0000:01:00.0: DRM: VRAM: 2048 MiB: This message shows that the nouveau graphics driver (open-source NVIDIA driver) detected 2048 MB of video RAM (VRAM) on the NVIDIA GPU.</b></li>
                        </ul>
                        <p>If you're trying to fix an issue or optimize performance, your system's logs can give you clues about what's happening behind the scenes.</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week3day5')">Day 5</button>
                <div id="week3day5" class="dropdown-content">
                    <div class="day-title">Introduction to Kernel</div>
                    <div class="day-info">
                        <p>The kernel is the core part of an operating system, responsible for managing the system's hardware, resources, and providing a bridge between applications and the hardware. On Linux, the kernel is the central part of the OS that:</p>
                        <ul>
                            <li><b>Manages hardware resources (CPU, memory, I/O devices like keyboards, printers, network cards, etc.)</b></li>
                            <li><b>Facilitates communication between the hardware and software applications</b></li>
                            <li><b>Provides core services like process management, memory management, file systems, and device management.</b></li>
                        </ul>
                        <p>Linux has a monolithic kernel, meaning it includes the core services of the system, including drivers for various hardware devices, all within the kernel space. However, it can also dynamically load and unload functionality, which brings us to kernel modules.</p>
                        
                        <h3>Basic Kernel Modules</h3>
                        <p>Kernel modules are pieces of code that can be loaded into the kernel at runtime to extend its functionality without needing to reboot or recompile the kernel. They’re typically used for:</p>
                        <ul>
                            <li><b>Device drivers: Modules can manage hardware like network cards, USB devices, etc.</b></li>
                            <li><b>File systems: Modules provide support for various file system types.</b></li>
                            <li><b>System features: Like networking protocols, cryptography, etc.</b></li>
                        </ul>

                        <h3>Why use kernel modules?</h3>
                        <ul>
                            <li><b>Modularity: You can add or remove drivers or functionality as needed, keeping the kernel lightweight.</b></li>
                            <li><b>Flexibility: Modules allow hardware to be supported dynamically, meaning the kernel doesn’t have to contain all drivers at all times.</b></li>
                            <li><b>Performance: Since the kernel can load only what it needs, the system’s performance can improve.</b></li>
                        </ul>
                        <p>Common Commands for Managing Kernel Modules:</p>
                        <ul>
                            <li><b>lsmod: Lists all currently loaded modules.</b></li>
                            <li><b>modprobe: Used to load and unload modules.</b></li>
                            <li><b>insmod: Installs a specific module into the kernel.</b></li>
                            <li><b>rmmod: Removes a module from the kernel.</b></li>
                        </ul>
                        <p>Example:</p>
                        <ul>
                            <li><b>modprobe module_name: Loads a module into the kernel</b></li>
                            <li><b>rmmod module_name: Removes the module from the kernel</b></li>
                        </ul>
                        <p>Basic Kernel Configuration</p>
                        <p>The kernel configuration involves setting up how the kernel should behave or determining which features or modules are compiled into it. When compiling or modifying a Linux kernel, you configure what gets included or excluded.</p>
                        <p>Key Configuration Areas:</p>
                        <ul>
                            <li><b>Device Drivers: Configure support for specific hardware (network cards, USB, printers, etc.).</b></li>
                            <li><b>File Systems: Choose which file systems (like ext4, FAT, NTFS) the kernel will support.</b></li>
                            <li><b>Processor Features: Configure settings for CPU architectures and optimizations.</b></li>
                            <li><b>Networking: Set up networking protocols, including support for IPv6, firewalls, etc.</b></li>
                            <li><b>Security: Choose which security frameworks (e.g., SELinux, AppArmor) are enabled.</b></li>
                        </ul>

                        <h3>Loading Kernel Modules (Example Use Case)</h3>
                        <p>Imagine you plug in a new USB network adapter, but your Linux system doesn’t recognize it right away. If the driver for this device isn’t included in the kernel by default, you may need to load the appropriate kernel module.</p>
                        <p>Steps:</p>
                        <p>Identify the hardware: Using dmesg or lspci/lsusb commands to get information about the hardware.<br>Identify the hardware: Using dmesg or lspci/lsusb commands to get information about the hardware.</p>
                        <ul>
                            <li><b>sudo modprobe </driver_name></b></li>
                        </ul>
                        <p>Verify it’s loaded: Use lsmod to check if the module is loaded.</p>
                        <ul>
                            <li><b>lsmod | grep </driver_name></b></li>
                        </ul>

                        <b>Kernel and Modules in Action: Dynamic Loading</b>
                        <p>Let’s say you connect a new piece of hardware (like a printer or a USB stick). Instead of having the drivers for every possible device loaded into the kernel at all times (which would be inefficient), the kernel can dynamically load the required drivers as needed. The kernel will look for the appropriate kernel module (if it exists) and load it.</p>
                        <p>For example:</p>
                        <ul>
                            <li><b>    If you insert a USB device, the kernel will load the appropriate USB driver module (if not already loaded) and initialize the device.</b></li>
                        </ul>

                        <b>Removing Modules</b>
                        <p>When a device is no longer in use, or if you no longer need certain functionality, you can remove modules to free up system resources. For example, to remove a module for a USB device you no longer use:</p>
                        <ul>
                            <li><b>sudo rmmod usb_storage</b></li>
                        </ul>
                        <b>Why remove modules?</b>
                        <ul>
                            <li><b>Free up kernel memory.</b></li>
                            <li><b>Reduce potential attack surfaces (especially for security reasons).</b></li>
                        </ul>

                        <b>Kernel Upgrades and Customization</b>
                        <p>For more advanced users, the Linux kernel can be customized and recompiled to suit specific hardware or performance needs. During the configuration process (before compiling the kernel), you can choose which drivers to compile into the kernel or as modules.</p>
                        <p>For instance:</p>
                        <ul>
                            <li><b>If you want better performance on a specific processor, you can configure the kernel with optimizations for that architecture.</b></li>
                            <li><b>For systems with limited memory, you can leave out unnecessary drivers and modules.</b></li>
                        </ul>
                        <p>Summary:</p>
                        <ul>
                            <li><b>The kernel is the core part of Linux, handling hardware, processes, memory, and system resources.</b></li>
                            <li><b>Kernel modules are like add-ons that can be dynamically loaded and unloaded to extend kernel functionality without rebooting the system.</b></li>
                            <li><b>Basic configuration involves deciding what features the kernel should have (such as device drivers, file systems, networking options, and security features).</b></li>
                            <li><b>Using tools like modprobe, lsmod, and rmmod, you can manage which modules are loaded into your kernel and modify its behavior on the fly.</b></li>
                        </ul>
                        <p>By understanding kernel modules and configuration, you can customize and optimize your Linux system to meet your needs and efficiently manage hardware.</p>

                        <h3>laymen's terms </h3>
                        <p>What is the Kernel?</p>
                        <p>Imagine your computer as a big company. In this company, there are workers (your hardware) like:</p>
                        <ul>
                            <li><b>The CPU (your computer’s brain)</b></li>
                            <li><b>Memory (like a temporary storage unit for quick access)</b></li>
                            <li><b>Hard drives (for permanent storage)</b></li>
                            <li><b>Printers, keyboards, network cards, etc. (the tools and equipment your company uses).</b></li>
                        </ul>
                        <p>Now, running this company efficiently requires a manager who:</p>
                        <ul>
                            <li><b>Assigns tasks to the workers (telling the CPU what to process).</b></li>
                            <li><b>Controls how much space each worker can use in storage (managing memory and hard drives).</b></li>
                            <li><b>Makes sure all the equipment is working properly (ensuring printers and network connections work).</b></li>
                        </ul>
                        <p>This manager is the kernel. It’s the core part of your operating system that manages all the workers (hardware) and makes sure everything runs smoothly.</p>
                        <b>How Does the Kernel Work?</b>
                        <p>The kernel is in charge of making sure the hardware (CPU, memory, disk, etc.) works together. For example:</p>
                        <ul>
                            <li><b>When you want to open a program (like a browser), the kernel tells the CPU, "Hey, start processing these instructions."</b></li>
                            <li><b>It gives the program some space in memory (RAM) to store temporary data.</b></li>
                            <li><b> It also fetches information from your hard drive if the program needs to load files.</b></li>
                        </ul>
                        <p>Providing a Communication Bridge: The kernel sits between the hardware (the physical machine) and the software (the programs you run, like browsers, music players, etc.). Whenever a program wants to talk to the hardware, it asks the kernel to handle it.</p>
                        <p>For example:</p>
                        <ul>
                            <li><b>If you want to print something, the program doesn’t directly talk to the printer. Instead, it asks the kernel: "Can you send this data to the printer?"</b></li>
                        </ul>
                        <b>What About Kernel Modules?</b>
                        <p>The kernel is like a manager who doesn’t always need all the tools in the office. Sometimes you might need a specific tool (say, a screwdriver for a specific task), but most of the time, you don’t need it. Instead of cluttering the office with unnecessary tools, the manager can load and unload them as needed.</p>
                        <p>These tools in the kernel are called kernel modules. They are small pieces of code (like extra drivers or functions) that can be added or removed without having to restart the entire company (the computer).</p>
                        <p>Example:</p>
                        <ul>
                            <li><b>If you plug in a new USB device that needs a special driver, the kernel can load a module to handle it.</b></li>
                            <li><b>Once the job is done, the module can be unloaded to save space and resources.</b></li>
                        </ul>
                        <p>Example: How the Kernel Handles a Task</p>
                        <p>Imagine you want to open a document from your hard drive. Here’s how the kernel manages this:</p>
                        <p>    The Request: You open a word processor like LibreOffice, and ask it to open a document.</p>
                        <p>Communication: LibreOffice (the software) doesn’t know how to talk directly to the hard drive, so it asks the kernel: "Hey, I need this file from the hard drive."</p>
                        <p>Hardware Handling: The kernel then tells the CPU: "Go fetch this file from the hard drive."</p>
                        <ul>
                            <li><b>It talks to the hard drive controller, asking for the specific file.</b></li>
                            <li><b>The hard drive gives the data back to the CPU.</b></li>
                            <li><b>The CPU processes the data and loads it into memory, where the word processor can access it.</b></li>
                        </ul>
                        <p>The kernel coordinates the entire process, ensuring that your hardware and software work together without any issues.</p>

                        <b>The Kernel in Action: Multiple Jobs at Once</b>
                        <p>Let’s say you’re listening to music, writing a document, and downloading a file — all at the same time. How does your computer handle all of this?</p>
                        <p>The kernel is responsible for multitasking. It makes sure the CPU divides its time between each task:</p>
                        <ul>
                            <li><b>Playing music: The kernel keeps sending instructions to the audio hardware to keep the music going.</b></li>
                            <li><b>Writing the document: The kernel ensures that your word processor has enough memory and tells the CPU to respond when you type.</b></li>
                            <li><b>Downloading a file: The kernel communicates with the network card to manage the data coming from the internet.</b></li>
                        </ul>
                        <p>The kernel keeps all these tasks running without the computer crashing or slowing down. It ensures that each task gets the right amount of resources without interfering with others.</p>
                        
                        <b>Kernel Configuration</b>
                        <p>The kernel can be customized for different needs. For example, you can choose to include or exclude certain features in the kernel, like:</p>
                        <ul>
                            <li><b>Support for specific file systems (how files are stored and organized on a disk, like ext4 or NTFS).</b></li>
                            <li><b>Drivers for specific hardware devices (like printers, network cards, or USB devices).</b></li>
                            <li><b>Different security features (like SELinux, a security module).</b></li>
                        </ul>
                        <p>You can even recompile the kernel with specific options based on your system's needs, but this is a more advanced task that experienced users or system administrators usually handle.</p>
                        <p>Summary:</p>
                        <ul>
                            <li><b>The kernel is like the manager of a company, managing workers (hardware like CPU, memory, etc.).</b></li>
                            <li><b>It ensures that the hardware does what it needs to, like opening files, running programs, and multitasking.</b></li>
                            <li><b>Kernel modules are like tools that the kernel can load and unload as needed, making the system flexible.</b></li>
                            <li><b>When you run multiple tasks, the kernel makes sure all the tasks get the right resources without crashing the system.</b></li>
                        </ul>
                        <p>By understanding how the kernel works, you get a sense of how Linux (or any operating system) manages the complex interactions between your hardware and software!</p>



                    </div>
                </div>
            </div>

            <div class="dropdown">
                <button onclick="toggleDropdown('week3review')">Week Review</button>
                <div id="week3review" class="dropdown-content">
                    <div class="day-title">Week Three Review: System Administration Essentials</div>
                    <div class="day-info">
                        <p>In week three, we built on foundational Linux skills and moved into essential system administration topics, covering package management, user and group management, disk management, system monitoring, and an introduction to the Linux kernel. Here’s a recap of each section.</p>
                        <h3>1. Package Management</h3>
                        <p>Managing software installations, updates, and removals is a critical part of administering any Linux system. Each distribution typically has its package manager:</p>
                        <p>apt (Advanced Package Tool): Used on Debian-based systems like Ubuntu. Example commands:</p>
                        <ul>
                            <li><b>apt update: Refreshes the package list.</b></li>
                            <li><b>apt install <package>: Installs a package.</b></li>
                            <li><b>apt remove <package>: Removes a package.</b></li>
                            <li><b> yum and dnf: Used on RHEL-based distributions like CentOS and Fedora. DNF is the newer tool replacing YUM.</b></li>
                            <li><b>pacman: The package manager for Arch Linux.</b></li>
                        </ul>
                        <p>Package managers simplify software management by automating installation, updating, and dependency resolution, which makes maintaining a Linux system more efficient.</p>

                        <h3>2. User and Group Management</h3>
                        <p>Understanding users and groups is crucial for system security and access control.</p>
                        <p>Adding, Modifying, and Deleting Users:</p>
                        <ul>
                            <li><b>useradd and adduser: Create new users.</b></li>
                            <li><b>usermod: Modify user properties, such as adding them to groups.</b></li>
                            <li><b>userdel: Delete a user and optionally their home directory.</b></li>
                        </ul>
                        <p>Managing Groups:</p>
                        <ul>
                            <li><b>groupadd: Adds a new group.</b></li>
                            <li><b>groupmod: Modifies group settings.</b></li>
                            <li><b>groupdel: Deletes a group.</b></li>
                        </ul>
                        <p>Understanding /etc/passwd and /etc/shadow Files:</p>
                        <ul>
                            <li><b>/etc/passwd: Contains user account information.</b></li>
                            <li><b>/etc/shadow: Stores encrypted passwords and password policies.</b></li>
                        </ul>
                        <p>User and group management is essential for securing a system and ensuring that only authorized individuals have the necessary permissions.</p>

                        <h3>3. Disk Management</h3>
                        <p>Managing disks, partitions, and file systems helps ensure the efficient and reliable storage of data.</p>
                        <p>Disk Utilities:</p>
                        <ul>
                            <li><b>fdisk: Used for partitioning disks. It allows you to create, delete, and modify partitions.</b></li>
                            <li><b>mkfs: Formats a partition with a specific file system, such as ext4.</b></li>
                            <li><b>mount and umount: Mounts and unmounts file systems to directories, making them accessible to the system.</b></li>
                        </ul>
                        <p>Partition Types:</p>
                        <ul>
                            <li><b>Primary and Extended: Primary partitions are limited to four, while extended partitions allow for more partitions through logical partitions.</b></li>
                            <li><b>Swap: A special type of partition that acts as virtual memory.</b></li>
                            <li><b>File Systems: Ext4, NTFS, and others that determine how files are stored and accessed on disk.</b></li>
                        </ul>
                        <p>Disk management, including partitioning and file systems, is essential for effective data organization, resource allocation, and system performance.</p>

                        <h3>4. System Monitoring and Performance</h3>
                        <p>Monitoring system performance is essential for keeping Linux systems running smoothly and efficiently.</p>
                        <p>Performance Monitoring Tools:</p>
                        <ul>
                            <li><b>top and htop: Display real-time system resource usage, including CPU, memory, and processes.</b></li>
                            <li><b>iostat: Reports CPU and input/output statistics for disks, useful for tracking disk bottlenecks.</b></li>
                            <li><b>vmstat: Monitors memory, swap, and CPU usage and can provide insights into system health.</b></li>
                        </ul>
                        <p>Log Files and System Logging:</p>
                        <ul>
                            <li><b>Logs, often located in /var/log, provide valuable information on system events, errors, and activities.</b></li>
                            <li><b>dmesg: Shows kernel messages, useful for debugging hardware issues.</b></li>
                            <li><b>syslog: Records general system messages and events, which is helpful for troubleshooting.</b></li>
                        </ul>

                        <p>Regular system monitoring and log review help identify issues, improve performance, and ensure the system runs smoothly.</p>

                        <h3>5. Introduction to the Kernel</h3>
                        <p>The kernel is the core component of Linux, responsible for managing hardware, processes, and system resources.</p>
                        <p>Kernel Modules: Small pieces of code that can be loaded or unloaded into the kernel as needed. Examples include drivers for hardware.</p>
                        <ul>
                            <li><b>lsmod: Lists currently loaded modules.</b></li>
                            <li><b>modprobe: Adds or removes modules from the kernel.</b></li>
                            <li><b>Basic Kernel Configuration: Kernel configuration, done mainly by administrators, allows for system optimization and customization, such as enabling specific drivers or features.</b></li>
                            <li><b>Updating the Kernel: Sometimes necessary for security and performance improvements, though care is needed to ensure compatibility.</b></li>
                        </ul>
                        <p>Understanding the Linux kernel and its modules is essential for system customization, troubleshooting, and optimizing hardware performance.</p>

                    </div>
                </div>
            </div>
            
            <div class="dropdown">
                <button onclick="toggleDropdown('week3quiz')">Quiz</button>
                <div id="week3quiz" class="dropdown-content">
                    <div class="day-title">Week 3 Quiz: System Administration Essentials</div>
                    <div class="day-info">
                        <h3>1. Which package manager is used on Debian-based distributions like Ubuntu?</h3>
                        <p>a) yum<br>b) pacman<br>c) apt<br>d) dnf</p>

                        <h3>2. Which command is used to add a new user in Linux?</h3>
                        <p>a) adduser<br>b) userdel<br>c) usermod<br>d) passwd</p>

                        <h3>3. What is the purpose of the /etc/passwd file?</h3>
                        <p>a) To store user password hashes<br>b) To store user account information, including usernames and user IDs<br>c) To store system configuration files<br>d) To store kernel module information</p>

                        <h3>4. Which command is used to check disk usage by directories and files?</h3>
                        <p>a) df<br>b) lsblk<br>c) du<br>d) blkid</p>

                        <h3>5. What does the mount command do?</h3>
                        <p>a) Displays the current file system usage<br>b) Connects a file system to a directory<br>c) Creates a new disk partition<br>d) Formats a disk with a file system</p>

                        <h3>6. What is the difference between htop and top?</h3>
                        <p>a) htop is a graphical version of top with more features.<br>b) top is used for file operations, while htop manages processes.<br>c) htop can only be used with root privileges, while top cannot.<br>d) There is no difference; they are identical.</p>

                        <h3>7. What is a kernel module?</h3>
                        <p>a) A type of user-space application<br>b) A program that runs outside of the Linux kernel<br>c) A piece of code that extends kernel functionality without rebooting<br>d) A configuration file for kernel settings</p>

                        <h3>8. Which command is used to load a kernel module?</h3>
                        <p>a) lsmod<br>b) modprobe<br>c) rmmod<br>d) insmod</p>

                        <h3>9. What does the /etc/shadow file store?</h3>
                        <p>a) Group information<br>b) Encrypted user password hashes<br>c) Usernames and home directories<br>d) Disk partition information</p>

                        <h3>10. Which command allows you to monitor system-wide memory, CPU, and disk I/O usage in real-time?</h3>
                        <p>a) vmstat<br>b) df<br>c) du<br>d) lsblk</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week3answers')">Quiz Answers</button>
                <div id="week3answers" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz Answers</div>
                    <div class="day-info">
                        <h3>1. Which package manager is used on Debian-based distributions like Ubuntu?</h3>
                        <p>Answer: c) apt</p>

                        <h3>2. Which command is used to add a new user in Linux?</h3>
                        <p>Answer: a) adduser</p>

                        <h3>3. What is the purpose of the /etc/passwd file?</h3>
                        <p>Answer: b) To store user account information, including usernames and user IDs</p>

                        <h3>4. Which command is used to check disk usage by directories and files?</h3>
                        <p>Answer: c) du</p>

                        <h3>5. What does the mount command do?</h3>
                        <p>Answer: b) Connects a file system to a directory</p>

                        <h3>6. What is the difference between htop and top?</h3>
                        <p>Answer: a) htop is a graphical version of top with more features.</p>

                        <h3>7. What is a kernel module?</h3>
                        <p>Answer: c) A piece of code that extends kernel functionality without rebooting</p>

                        <h3>8. Which command is used to load a kernel module?</h3>
                        <p>Answer: b) modprobe</p>

                        <h3>9. What does the /etc/shadow file store?</h3>
                        <p>Answer: b) Encrypted user password hashes</p>

                        <h3>10. Which command allows you to monitor system-wide memory, CPU, and disk I/O usage in real-time?</h3>
                        <p>Answer: a) vmstat</p>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Additional weeks can follow the same structure -->
     <!-- Week 4 -->
     <div class="dropdown">
        <button onclick="toggleDropdown('week4')">Week 4</button>
        <div id="week4" class="dropdown-content">
            <!-- Days -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week4day1')">Day 1</button>
                <div id="week4day1" class="dropdown-content">
                    <div class="day-title">Basic Security Concepts</div>
                    <div class="day-info">
                        <p>When using a Linux system (or any computer), security is about protecting your system and data from unauthorized access, breaches, or damage. Here are some fundamental security concepts to keep in mind.</p>
                        <p><b>User Accounts and Permissions:</b><br>Each user has their own account and set of permissions that dictate what they can do on the system (e.g., view files, modify system settings).<br>It’s important to give users only the access they need. This is called the principle of least privilege.</p>
                        <p><b>Authentication:</b><br>Ensuring that users are who they say they are. This is usually done with passwords, but can also involve other methods like SSH keys or multi-factor authentication (MFA).</p>
                        <p><b>Authorization:</b><br>Once a user is authenticated, authorization determines what they can access. For example, even if you're logged in, you might not have permission to modify important system files.</p>
                        <p><b>Encryption:</b><br>Encrypting data makes it unreadable to unauthorized users. This can be done for data stored on your disk (e.g., encrypted file systems) or data being sent over the internet (e.g., HTTPS).</p>
                        <p><b>Updates and Patching:</b><br>Regularly updating software is a basic security practice to ensure vulnerabilities are patched. Unpatched software is one of the biggest security risks.</p>
                        <p><b>Auditing and Monitoring:</b><br>Keeping an eye on logs and system behavior helps detect if anything unusual is happening. Logs contain records of activities like login attempts, program execution, and file access.</p>

                        <h3>Firewalls: UFW and iptables</h3>
                        <p>A firewall is a security system that controls incoming and outgoing network traffic based on predefined security rules. It acts as a barrier between your system and untrusted networks (like the internet), allowing or blocking traffic based on your configuration.</p>
                        <b>1. UFW (Uncomplicated Firewall):</b>
                        <ul>
                            <li><b>UFW is designed to be an easy-to-use interface for managing a firewall. It's often installed by default on Ubuntu and other Debian-based systems.</b></li>
                            <li><b>It's called "uncomplicated" because it simplifies managing iptables (the underlying Linux firewall).</b></li>
                            <li><b>With UFW, you can easily allow or deny access to specific services or ports, like web servers (port 80) or SSH (port 22).</b></li>
                        </ul>
                        <p>Example basic rules in UFW:</p>
                        <p>Allow SSH (used to connect remotely):</p>
                        <ul>
                            <li><b>sudo ufw allow ssh</b></li>
                        </ul>
                        <p>Deny all incoming traffic by default:</p>
                        <ul>
                            <li><b>sudo ufw default deny incoming</b></li>
                        </ul>
                        <p>Enable the firewall:</p>
                        <ul>
                            <li><b>sudo ufw enable</b></li>
                        </ul>
                        <h3>2. iptables:</h3>
                        <p>iptables is the more advanced and flexible tool that sits behind UFW. It works by defining rules that control how packets (data sent over the network) are handled. These rules are organized into tables, each with a specific purpose.<br>iptables is very powerful but can be complicated for beginners.</p>
                        <p>There are three basic chains that iptables uses:</p>
                        <ul>
                            <li><b>INPUT: Controls incoming connections to your machine.</b></li>
                            <li><b>FORWARD: Deals with traffic being forwarded through your machine (typically used in routers).</b></li>
                            <li><b>OUTPUT: Controls outgoing connections from your machine.</b></li>
                        </ul>
                        <p>Example iptables rules:</p>
                        <p>Allow incoming traffic on port 80 (HTTP):</p>
                        <ul>
                            <li><b>sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT</b></li>
                        </ul>
                        <p>Drop all incoming connections by default:</p>
                        <ul>
                            <li><b>sudo iptables -P INPUT DROP</b></li>
                        </ul>
                        
                        <h3>Basic Security Practices</h3>
                        <p><b>Strong Passwords:</b><br>Always use strong, unique passwords for your accounts. A strong password typically includes a mix of letters, numbers, and symbols.</p>

                        <p>Tools like password managers can help generate and store strong passwords.</p>

                        <p><b>Use SSH Instead of Telnet:</b><br>When remotely logging into your system, use SSH (Secure Shell) instead of Telnet, as SSH encrypts the connection. Telnet is insecure because it sends data, including your password, in plain text.</p>

                        <p><b>Keep Software Up-to-Date:</b><br>Regularly update your system to apply security patches. This includes the operating system and installed applications. You can use a package manager like apt or dnf to ensure everything is up-to-date.</p>

                        <p><b>Configure the Firewall:</b><br>Use UFW or iptables to configure your firewall. You should deny all unnecessary incoming connections and only allow traffic that you explicitly need, like SSH or web traffic.</p>

                        <p><b>Disable Root Login:</b><br>For security reasons, it's a good idea to disable direct root login, especially over SSH. Instead, use sudo to run administrative commands. This adds an extra layer of protection by requiring user authentication before running important commands.</p>

                        <p><b>Use Sudo for Privileged Operations:</b><br>Instead of logging in as root, use sudo to run commands that require administrative privileges. This prevents accidental system changes and makes it easier to keep track of who is doing what.</p>

                        <p><b>Monitor Log Files:</b><br>Regularly check log files for unusual activity, such as failed login attempts or unauthorized access. Important logs can be found in the /var/log directory.<br>For example, you might check the auth.log file to see login attempts:<br>cat /var/log/auth.log</p>

                        <p><b>Limit User Access:</b><br>Only give users access to what they need. If someone doesn’t need access to certain files or commands, don’t give them the permissions.<br>Use chown and chmod to properly manage file permissions.</p>

                        <p>Summary:</p>
                        <ul>
                            <li><b>Security concepts focus on protecting the system from unauthorized access using permissions, encryption, and monitoring.</b></li>
                            <li><b>Firewalls like UFW and iptables control the traffic coming into and leaving your system, acting as a barrier against untrusted networks.</b></li>
                            <li><b>Basic security practices such as strong passwords, software updates, using SSH, and proper user permissions are essential for maintaining a secure system.</b></li>
                        </ul>
                        <p>By keeping these concepts in mind and properly managing your firewall and access controls, you can ensure your Linux system stays safe from many common security threats.</p>

                        <b>OpenSSL Overview</b>
                        <p>OpenSSL is a powerful, open-source toolkit widely used for implementing cryptographic functions like encryption, decryption, and secure communications via protocols like TLS (which is used for HTTPS websites). It also helps create and manage certificates, keys, and cryptographic algorithms.</p>


                        <p>What is OpenSSL Used For?</p>
                        <ul>
                            <li><b>Encrypting and Decrypting Data: OpenSSL provides encryption algorithms (like AES or RSA) to secure your files or communication.</b></li>
                            <li><b>Creating SSL/TLS Certificates: OpenSSL is commonly used to generate SSL/TLS certificates to secure websites or network services.</b></li>
                            <li><b>Generating Cryptographic Keys: It can create both public and private keys for encryption and decryption.</b></li>
                            <li><b>Digital Signatures and Verification: OpenSSL can be used to sign files or messages, ensuring data integrity and authenticity.</b></li>
                            <li><b>Hashing: OpenSSL provides tools for generating hash functions (like SHA-256) to verify the integrity of data.</b></li>
                        </ul>

                        <h3>Encrypting Files with OpenSSL</h3>
                        <p>You can use OpenSSL to encrypt files so that only authorized users can decrypt them. Here's how to encrypt and decrypt a file.</p>
                        <b>Encrypting a File</b>
                        <p>Choose an Encryption Algorithm: AES (Advanced Encryption Standard) is one of the most common and secure encryption methods. You can use AES with a 256-bit key for high security.</p>
                        <p>Encrypt a File Using OpenSSL:</p>
                        <ul>
                            <li><b>Open a terminal and run the following command to encrypt a file (myfile.txt) using AES-256:</b></li>
                            <li><b>openssl enc -aes-256-cbc -salt -in myfile.txt -out myfile.enc</b></li>
                        </ul>
                        <p>Explanation:</p>
                        <ul>
                            <li><b>enc: This is the OpenSSL encryption command.</b></li>
                            <li><b>aes-256-cbc: Specifies the AES encryption algorithm with a 256-bit key in CBC mode (Cipher Block Chaining mode).</b></li>
                            <li><b>salt: Adds a layer of protection to prevent dictionary attacks.</b></li>
                            <li><b>in myfile.txt: The input file to encrypt.</b></li>
                            <li><b>out myfile.enc: The output file (the encrypted version).</b></li>
                        </ul>

                        <p>You'll be prompted to create a password. Make sure to remember it, as it will be required to decrypt the file.</p>

                        <b>Decrypting a File</b>
                        <p>To decrypt the file, use the following command:<br>openssl enc -d -aes-256-cbc -in myfile.enc -out myfile_decrypted.txt</p>

                        <p>Explanation:</p>
                        <ul>
                            <li><b>d: Specifies decryption.</b></li>
                        </ul>
                        <p>The rest of the command is the same, except the output file is now the decrypted version (myfile_decrypted.txt).</p>
                        <p>You'll be asked for the password that was used during encryption to decrypt the file.</p>

                        <b>Generating SSL/TLS Certificates Using OpenSSL</b>
                        <p>One of the key features of OpenSSL is generating SSL/TLS certificates, which are used to secure websites and communications. This process involves generating a private key, a certificate signing request (CSR), and optionally a self-signed certificate.</p>
                        <b>Step 1: Generate a Private Key</b>
                        <p>A private key is used to create the CSR and certificate. Run the following command to create a 2048-bit RSA private key:<br>openssl genpkey -algorithm RSA -out my_private_key.pem -aes256</p>
                        <p>Explanation:</p>
                        <ul>
                            <li><b>genpkey: This generates a private key.</b></li>
                            <li><b>algorithm RSA: Specifies the RSA encryption algorithm.</b></li>
                            <li><b>out my_private_key.pem: The file that will store the private key.</b></li>
                            <li><b>aes256: Encrypts the private key using AES-256 to keep it safe (you will need to provide a password).</b></li>
                        </ul>

                        <b>Step 2: Create a Certificate Signing Request (CSR)</b>
                        <p>The CSR is a file you give to a certificate authority (CA) to get an SSL certificate. It includes details about your domain and organization. If you're creating a self-signed certificate, you can skip this step.</p>
                        <p>To create the CSR:<br>openssl req -new -key my_private_key.pem -out my_csr.pem</p>
                        <p>Explanation:</p>
                        <ul>
                            <li><b>req -new: Creates a new CSR.</b></li>
                            <li><b>key my_private_key.pem: The private key is used to generate the CSR.</b></li>
                            <li><b>out my_csr.pem: The output file for the CSR.</b></li>
                        </ul>
                        <p>You'll be asked for details like your Country, State, Organization, and Common Name (domain name).</p>

                        <b>Step 3: Create a Self-Signed Certificate</b>
                        <p>If you're not getting your certificate signed by a Certificate Authority (CA), you can create a self-signed certificate for testing or internal use.</p>
                        <p>To create a self-signed certificate that is valid for 1 year (365 days):<br>openssl req -x509 -new -key my_private_key.pem -out my_certificate.pem -days 365</p>

                        <p>Explanation:</p>
                        <ul>
                            <li><b>x509: This option creates a self-signed certificate.</b></li>
                            <li><b>key my_private_key.pem: The private key is used to sign the certificate.</b></li>
                            <li><b>out my_certificate.pem: The output file for the self-signed certificate.</b></li>
                            <li><b>days 365: The certificate will be valid for 365 days.</b></li>
                        </ul>

                        <b>SSL Certificate Structure</b>
                        <p>When you generate or view a certificate, it contains several fields:</p>
                        <ul>
                            <li><b>Common Name (CN): Typically the domain name (e.g., example.com).</b></li>
                            <li><b>Organization: The name of your company.</b></li>
                            <li><b>Validity Period: The start and end date during which the certificate is valid.</b></li>
                            <li><b>Public Key: The public portion of the key pair, used for encryption.</b></li>
                            <li><b>Signature: If signed by a CA, this is the signature verifying the certificate’s authenticity.</b></li>
                        </ul>

                        <p>Summary</p>
                        <ul>
                            <li><b>OpenSSL is a toolkit used for encryption, decryption, SSL certificates, and cryptographic keys.</b></li>
                            <li><b>You can encrypt and decrypt files using algorithms like AES to protect sensitive information.</b></li>
                            <li><b>OpenSSL is also used to create SSL/TLS certificates for securing websites or network services.</b></li>
                            <li><b>You can generate a private key, a CSR (for requesting a certificate from a CA), or a self-signed certificate (for testing or internal use).</b></li>
                        </ul>
                        <p>By learning to use OpenSSL, you can enhance the security of your data and secure your communications effectively.</p>
                                               
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week4day1exercises')">Exercises</button>
                            <div id="week4day1exercises" class="dropdown-content">
                                <h3>Exercise 1: Securing File Permissions</h3>
                                <p>Create a file named secure.txt in your home directory.</p>
                                <p>Change the permissions so that only the owner can read and write the file.</p>
                                <p>Verify the new permissions using the ls -l command.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Create the file: touch ~/secure.txt</b></li>
                                    <li><b>Set the permissions: chmod 600 ~/secure.txt</b></li>
                                    <li><b>Verify: ls -l ~/secure.txt</b></li>
                                </ul>

                                <h3>Exercise 2: Adding a User and Assigning sudo Privileges</h3>
                                <p> Create a new user named testuser.</p>
                                <p>Add the user to the sudo group to give them administrative privileges.</p>
                                <p>Log in as testuser and verify they can run commands with sudo.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Add the user: sudo adduser testuser</b></li>
                                    <li><b>Add to sudo: sudo usermod -aG sudo testuser</b></li>
                                    <li><b>Log in and verify with sudo whoami.</b></li>
                                </ul>

                                <h3>Exercise 3: Creating a Custom Firewall Rule Using UFW</h3>
                                <p>Install UFW (Uncomplicated Firewall) if it’s not already installed.</p>
                                <p>Allow incoming SSH connections.</p>
                                <p>Block all other incoming connections.</p>
                                <p>Enable the firewall and verify the rules.</p>

                                <p>Steps:</p>
                                <ul>
                                    <li><b>Install UFW: sudo apt install ufw</b></li>
                                    <li><b>Allow SSH: sudo ufw allow ssh</b></li>
                                    <li><b>Deny all other incoming connections: sudo ufw default deny incoming</b></li>
                                    <li><b>Enable UFW: sudo ufw enable</b></li>
                                    <li><b>Check status: sudo ufw status</b></li>
                                </ul>

                                <h3>Exercise 4: Checking Running Services and Killing a Process</h3>
                                <p> Use the ps or top command to list running processes.</p>
                                <p>Identify a process running under your username.</p>
                                <p>Kill that process using the kill command.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>List processes: ps aux | grep your_username or top</b></li>
                                    <li><b>Find the PID (Process ID).</b></li>
                                    <li><b>Kill the process: kill PID</b></li>
                                </ul>

                                <h3>Exercise 5: Setting Up a Simple IPTables Rule</h3>
                                <p>Use iptables to block traffic to port 80 (HTTP) on your machine.</p>
                                <p>Verify that HTTP requests are blocked.</p>
                                <p>Delete the rule to restore normal traffic.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Block HTTP: sudo iptables -A INPUT -p tcp --dport 80 -j DROP</b></li>
                                    <li><b>Check: sudo iptables -L</b></li>
                                    <li><b>Remove rule: sudo iptables -D INPUT -p tcp --dport 80 -j DROP</b></li>
                                </ul>

                                <b>OpenSSL Exercises:</b>

                                <h3>Exercise 6: Encrypting and Decrypting a File with OpenSSL</h3>
                                <p>Create a text file named secret.txt containing some sensitive information.</p>
                                <p>Use OpenSSL to encrypt the file with AES-256.</p>
                                <p> Decrypt the file and verify the contents are intact.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Create file: echo "Sensitive Data" > secret.txt</b></li>
                                    <li><b>Encrypt: openssl enc -aes-256-cbc -salt -in secret.txt -out secret.enc</b></li>
                                    <li><b>Decrypt: openssl enc -d -aes-256-cbc -in secret.enc -out secret_decrypted.txt</b></li>
                                    <li><b>Check contents: cat secret_decrypted.txt</b></li>
                                </ul>

                                <h3>Exercise 7: Generating a Private Key</h3>
                                <p>Use OpenSSL to generate a 2048-bit RSA private key.</p>
                                <p>Secure the private key by encrypting it with AES-256.</p>
                                <p>View the private key to verify it is encrypted.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Generate key: openssl genpkey -algorithm RSA -out private_key.pem -aes256</b></li>
                                    <li><b>View key: cat private_key.pem</b></li>
                                </ul>

                                <h3>Exercise 8: Creating a Self-Signed SSL Certificate</h3>
                                <p>Generate a new private key for SSL/TLS use.</p>
                                <p>Create a Certificate Signing Request (CSR).</p>
                                <p>Generate a self-signed certificate valid for 365 days using OpenSSL.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Generate key: openssl genpkey -algorithm RSA -out my_ssl_key.pem</b></li>
                                    <li><b>Generate CSR: openssl req -new -key my_ssl_key.pem -out my_csr.pem</b></li>
                                    <li><b>Self-signed certificate: openssl req -x509 -key my_ssl_key.pem -in my_csr.pem -out my_cert.pem -days 365</b></li>
                                </ul>

                                <h3>Exercise 9: Creating a Password-Protected Encrypted Archive</h3>
                                <p>Create a directory with several files in it.</p>
                                <p>Use the tar command to create an archive of the directory.</p>
                                <p>Encrypt the archive using OpenSSL.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Create directory: mkdir my_folder && touch my_folder/file1.txt my_folder/file2.txt</b></li>
                                    <li><b>Create tar archive: tar czvf my_folder.tar.gz my_folder/</b></li>
                                    <li><b>Encrypt: openssl enc -aes-256-cbc -salt -in my_folder.tar.gz -out my_folder.enc</b></li>
                                    <li><b>Verify encryption: ls -l my_folder.enc</b></li>
                                </ul>

                                <h3>Exercise 10: Creating an MD5 Checksum for a File</h3>
                                <p>Create a file named checksum.txt.</p>
                                <p>Use OpenSSL to generate an MD5 checksum for the file.</p>
                                <p>Modify the file and check if the checksum changes.</p>
                                <p>Steps:</p>
                                <ul>
                                    <li><b>Create file: echo "Initial Content" > checksum.txt</b></li>
                                    <li><b>Generate checksum: openssl dgst -md5 checksum.txt</b></li>
                                    <li><b>Modify file: echo "New Content" >> checksum.txt</b></li>
                                    <li><b>Regenerate checksum and compare: openssl dgst -md5 checksum.txt</b></li>
                                </ul>

                                <p>These exercises provide hands-on practice with key Linux security tools and concepts, including managing file permissions, using OpenSSL for cryptography, and basic firewall and process control. They help solidify knowledge of security essentials and encryption techniques for protecting files and system integrity.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week4day2')">Day 2</button>
                <div id="week4day2" class="dropdown-content">
                    <div class="day-title">Backup and Recovery</div>
                    <div class="day-info">
                        <h3>Backup Strategies</h3>
                        <p>Backing up your data is critical to ensure that you can recover important files in case of hardware failure, accidental deletion, corruption, or other disasters. A good backup strategy will ensure your data is safe, secure, and recoverable.</p>

                        <h3>1.Full Backup:</h3>
                        <p>A complete copy of all the data. This ensures that you have a complete snapshot but can take more time and storage space.<br>Example: You back up every file on your computer.</p>

                        <h3>2.Incremental Backup:</h3>
                        <p>Only the data that has changed since the last backup is saved. It is faster and uses less space than a full backup.<br>Example: After your full backup, you only save files that have been modified or created since the last backup.</p>

                        <h3>3.Differential Backup:</h3>
                        <p>Saves changes made since the last full backup. It’s quicker than a full backup but grows in size with each run.<br>Example: You do a full backup on Sunday, and on Monday you back up all the files that changed since Sunday. On Tuesday, you back up files that changed since Sunday again.</p>

                        <h3>4.Backup Rotation:</h3>
                        <p>You don’t keep every backup forever. Instead, you keep a few of the latest backups and rotate them. A common strategy is to use the grandfather-father-son approach, where you rotate daily, weekly, and monthly backups.</p>

                        <h3>5.On-Site vs. Off-Site:</h3>
                        <p>On-Site: Keeping your backup locally on the same physical premises. This is fast for recovery but vulnerable to local disasters like fires or theft.<br>Off-Site: Storing a backup somewhere else, such as in the cloud or on a separate location. This increases the safety of your data but might be slower to restore.</p>

                        <h3>Tools for Backup in Linux</h3>
                        <p>Linux has several robust tools for backing up and synchronizing data. Two of the most widely used tools are rsync and tar.</p>

                        <h3>1. rsync: A Powerful Backup and Synchronization Tool</h3>
                        <p>rsync is a command-line utility used to copy and synchronize files and directories efficiently between two locations (either locally or remotely). It’s especially good for incremental backups, as it only transfers changed parts of files, reducing backup time and bandwidth usage.</p>

                        <h3>Key Features of rsync:</h3>
                        <ul>
                            <li><b>Incremental: It only copies the differences between the source and the destination, making backups efficient.</b></li>
                            <li><b>Network Backups: You can copy files over the network using SSH.</b></li>
                            <li><b>Preserve File Permissions: It keeps file permissions, timestamps, symbolic links, and ownership intact.</b></li>
                        </ul>

                        <h3>Basic rsync Command:</h3>
                        <p>To back up a directory /home/user/data to a backup location /mnt/backup, you can run:</p>
                        <ul>
                            <li><b>rsync -av /home/user/data /mnt/backup</b></li>
                        </ul>
                        <p>Explanation:</p>
                        <ul>
                            <li><b>-a: Archive mode (preserves permissions, ownership, symbolic links, etc.).</b></li>
                            <li><b>-v: Verbose (displays what is being copied).</b></li>
                            <li><b>The source is /home/user/data and the destination is /mnt/backup.</b></li>
                        </ul>

                        <p>Network Backup Example:</p>
                        <p>To back up data to a remote server over SSH:</p>
                        <ul>
                            <li><b>rsync -av -e ssh /home/user/data user@remote:/backup</b></li>
                        </ul>
                        <p>-e ssh: Specifies to use SSH for the connection.<br>user@remote:/backup: The remote destination.</p>
                        <p>rsync Options:</p>
                        <p>--delete: Remove files from the destination that no longer exist in the source.</p>
                        <p>rsync -av --delete /home/user/data /mnt/backup</p>
                        <p>-z: Compresses data during transfer, useful for network backups.</p>

                        <h3>2. tar: Archiving Tool</h3>
                        <p>tar is one of the most commonly used tools in Linux for creating compressed archives. Unlike rsync, which is more for file synchronization and copying, tar bundles multiple files into a single archive file and can optionally compress it.</p>
                        <p>Key Features of tar:</p>
                        <ul>
                            <li><b>Archiving: It can bundle multiple files or directories into a single file for easier storage or transfer.</b></li>
                            <li><b>Compression: It supports compression using tools like gzip and bzip2.</b></li>
                            <li><b>Flexibility: It’s highly customizable for backup purposes.</b></li>
                        </ul>
                        <p>Creating a tar Backup:</p>
                        <p>You can create a compressed backup of a directory /home/user/data and save it as backup.tar.gz:</p>
                        <ul>
                            <li><b>tar -czvf backup.tar.gz /home/user/data</b></li>
                        </ul>
                        <p>Explanation:</p>
                        <ul>
                            <li><b>-c: Create an archive.</b></li>
                            <li><b>-z: Compress the archive using gzip.</b></li>
                            <li><b>-v: Verbose (displays the process).</b></li>
                            <li><b>-f backup.tar.gz: The name of the archive.</b></li>
                            <li><b>/home/user/data: The directory to back up.</b></li>
                        </ul>
                        <p>Extracting tar Backups:</p>
                        <p>To restore or extract the tar archive, you can use:</p>
                        <p>tar -xzvf backup.tar.gz -C /restore/destination</p>
                        <ul>
                            <li><b>-x: Extract the archive.</b></li>
                            <li><b>-C /restore/destination: Extract the contents to the specified directory.</b></li>
                        </ul>

                        <h3>Creating and Restoring Backups</h3>
                        <p>Creating a Backup Strategy Using rsync and tar:</p>
                        <p>Full Backup with rsync:</p>
                        <p>Schedule a weekly full backup using rsync:</p>
                        <ul>
                            <li><b>rsync -av /home/user/data /mnt/backup</b></li>
                        </ul>
                        <p>Incremental Backup with rsync:</p>
                        <p>You can create daily incremental backups that only copy changes:</p>
                        <ul>
                            <li><b>rsync -av --delete /home/user/data /mnt/backup/daily</b></li>
                        </ul>
                        <p>Creating tar Archives for Long-Term Storage:</p>
                        <p>Create a monthly full archive backup of your data using tar for long-term storage:</p>
                        <ul>
                            <li><b>tar -czvf /mnt/backup/monthly/backup-$(date +%F).tar.gz /home/user/data</b></li>
                        </ul>
                        <p>Restoring Backups:</p>
                        <p>From rsync: If you need to restore a file or directory, use rsync to copy it back to its original location:</p>
                        <ul>
                            <li><b>rsync -av /mnt/backup/data /home/user/</b></li>
                        </ul>
                        <p>From tar Archive: To restore a specific file or directory from a tar backup:</p>
                        <ul>
                            <li><b>tar -xzvf backup.tar.gz -C /home/user/ --wildcards '*myfile.txt'</b></li>
                        </ul>
                        <p>--wildcards: This allows you to extract specific files by pattern.</p>

                        <h3>Summary of Backup Tools and Strategies:</h3>
                        <ul>
                            <li><b>rsync is ideal for incremental backups and synchronization, especially for large data sets or over the network. It minimizes transfer time by copying only changed files.</b></li>
                            <li><b>tar is useful for creating compressed archives of files or directories, which is perfect for long-term storage or transferring backups between systems.</b></li>
                            <li><b>A good backup strategy might include regular full backups combined with incremental backups, ensuring data is safe but not taking up too much space.</b></li>
                            <li><b>Store your backups both locally and off-site (e.g., on the cloud) for better protection against disasters.</b></li>
                        </ul>
                        <p>By combining rsync for frequent backups and tar for long-term, compressed archives, you can create an effective backup strategy to protect your data.</p>

                        <div class="dropdown">
                            <button onclick="toggleDropdown('week4day2exercises')">Exercises</button>
                            <div id="week4day2exercises" class="dropdown-content">
                                <h3>Exercise 1: Basic File Backup Using rsync</h3>
                                <p>Create a directory named project and add a few files (file1.txt, file2.txt).</p>
                                <p> Use rsync to back up the project directory to a new location /backup/project_backup.</p>
                                <p>Verify that the files are correctly copied.</p>
                                <b>Steps:</b>
                                <p>Create directory and files:</p>
                                <p>mkdir ~/project && touch ~/project/file1.txt ~/project/file2.txt</p>
                                <p>Backup using rsync:<br>rsync -av ~/project /backup/project_backup</p>
                                <p>Verify the files:<br>ls /backup/project_backup</p>
                                

                                <h3>Exercise 2: Incremental Backup with rsync</h3>
                                <p>Add a new file file3.txt to the project directory.</p>
                                <p>Use rsync to update the backup by only copying the new file.</p>
                                <p>Verify that only file3.txt is added to the backup.</p>
                                <b>Steps:</b>
                                <p>Add file:<br>touch ~/project/file3.txt</p>
                                <p>Run incremental backup:<br>rsync -av ~/project /backup/project_backup</p>
                                <p>Verify:<br>ls /backup/project_backup</p>

                                <h3>Exercise 3: Synchronizing a Backup with --delete Option</h3>
                                <p>Delete file2.txt from the original project directory.</p>
                                <p>Use rsync with the --delete option to synchronize the backup.</p>
                                <p>Verify that file2.txt is removed from the backup as well.</p>
                                <b>Steps:</b>
                                <p>Delete file:<br>rm ~/project/file2.txt</p>
                                <p>Sync and delete in backup:<br>rsync -av --delete ~/project /backup/project_backup</p>
                                <p>Verify deletion:<br>ls /backup/project_backup</p>

                                <h3>Exercise 4: Archiving a Directory with tar</h3>
                                <p>Create a new directory docs and add files (doc1.txt, doc2.txt).</p>
                                <p>Create a tar archive of the docs directory named docs_backup.tar.gz.</p>
                                <p> Verify that the archive is created successfully.</p>
                                <b>Steps:<br>mkdir ~/docs && touch ~/docs/doc1.txt ~/docs/doc2.txt</b>
                                <p>Archive the directory:<br>tar -czvf docs_backup.tar.gz ~/docs</p>
                                <p>Verify archive:<br>ls docs_backup.tar.gz</p>

                                <h3>Exercise 5: Extracting Files from a tar Archive</h3>
                                <p>Use the docs_backup.tar.gz archive created in the previous exercise.</p>
                                <p>Extract the archive into a new directory /restore/docs_restored.</p>
                                <p>Verify that the files have been restored.</p>
                                <b>Steps:</b>
                                <p>Extract archive:<br>mkdir -p /restore/docs_restored<br>tar -xzvf docs_backup.tar.gz -C /restore/docs_restored</p>
                                <p>Verify files:<br>ls /restore/docs_restored/docs</p>

                                <h3>Exercise 6: Creating a Full Backup with tar and Encrypting It</h3>
                                <p>Archive and compress the project directory into project_backup.tar.gz.</p>
                                <p>Use openssl to encrypt the archive using AES-256.</p>
                                <p>Verify that the archive is encrypted.</p>
                                <b>Steps:</b>
                                <p>Archive the project:<br>tar -czvf project_backup.tar.gz ~/project</p>
                                <p>Encrypt with OpenSSL:<br>openssl enc -aes-256-cbc -salt -in project_backup.tar.gz -out project_backup_encrypted.tar.gz</p>
                                <p>Verify:<br>ls project_backup_encrypted.tar.gz</p>

                                <h3>Exercise 7: Restoring an Encrypted Backup</h3>
                                <p>Use the encrypted archive project_backup_encrypted.tar.gz created in the previous exercise.</p>
                                <p>Decrypt the archive using openssl.</p>
                                <p>Extract the decrypted archive and verify the files are intact.</p>
                                <b>Steps:</b>
                                <p>Decrypt the archive:<br>openssl enc -d -aes-256-cbc -in project_backup_encrypted.tar.gz -out project_backup_decrypted.tar.gz</p>
                                <p>Extract the decrypted archive:<br>tar -xzvf project_backup_decrypted.tar.gz -C ~/restored_project</p>
                                <p>Verify the files:<br>ls ~/restored_project</p>

                                <h3>Exercise 8: Scheduling a Daily Backup with cron and rsync</h3>
                                <p>Set up a cron job to automatically back up the project directory every day at 2 AM using rsync.</p>
                                <p>Verify that the cron job is set up correctly by checking the cron file.</p>
                                <b>Steps:</b>
                                <p>Edit the crontab:<br>crontab -e</p>
                                <p>Add the following line to schedule the backup:<br>0 2 * * * rsync -av ~/project /backup/project_backup</p>
                                <p> Verify the cron job:<br>crontab -l</p>

                                <h3>Exercise 9: Creating a Differential Backup Using tar</h3>
                                <p>Create a full backup of the project directory with tar.</p>
                                <p>Modify one of the files in the project directory.</p>
                                <p>Create a differential backup that includes only the changed files.</p>
                                <b>Steps:</b>
                                <p>Full backup:<br>tar -czvf project_full_backup.tar.gz ~/project</p>
                                <p>Modify a file:<br>echo "New Data" >> ~/project/file1.txt</p>
                                <p>Create differential backup:<br>tar -czvf project_diff_backup.tar.gz --newer project_full_backup.tar.gz ~/project</p>

                                <h3>Exercise 10: Backing Up to a Remote Server Using rsync</h3>
                                <p>Set up rsync to back up the project directory to a remote server.</p>
                                <p>Verify that the files are correctly copied to the remote server.</p>
                                <b>Steps:</b>
                                <p>Use rsync to back up to remote:<br>rsync -av ~/project user@remote:/backup/project_backup</p>
                                <p>Log in to the remote server and verify:<br>ssh user@remote<br>ls /backup/project_backup</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week4day3')">Day 3</button>
                <div id="week4day3" class="dropdown-content">
                    <div class="day-title">Automating Tasks</div>
                    <div class="day-info">
                        <p>Automating tasks in Linux is essential for performing repetitive tasks without manual intervention. Two commonly used tools for scheduling tasks are cron and anacron. Let’s break down how each works and when to use them, as well as the basics of scheduling tasks.</p>

                        <h3>1. Cron: Automating Tasks on Regular Intervals</h3>
                        <p>Cron is a time-based job scheduler in Unix-like operating systems. It allows you to automate scripts or commands to run at specified times and intervals. Cron jobs are widely used for routine maintenance, backups, notifications, and more.</p>
                        <b>How Cron Works</b>
                        <p>Cron Daemon (crond): The cron daemon runs in the background and checks the crontab (cron tables) for scheduled tasks.<br>Crontab (Cron Tables): A configuration file where you specify the command or script to run, along with the schedule.</p>
                        <p>Crontab Syntax</p>
                        <p>Each line in a crontab file represents a job and follows a specific format with five fields:</p>
                        <p>* * * * * command
                            | | | | |
                            | | | | ----- Day of the week (0 - 7) (0 or 7 is Sunday)
                            | | | ------- Month (1 - 12)
                            | | --------- Day of the month (1 - 31)
                            | ----------- Hour (0 - 23)
                            ------------- Minute (0 - 59)
                        </p>
                        <p>For example:</p>
                        <ul>
                            <li><b>30 2 * * * /path/to/backup.sh — Runs backup.sh every day at 2:30 AM.</b></li>
                            <li><b>0 */6 * * * /path/to/script.sh — Runs script.sh every six hours.</b></li>
                        </ul>
                        <p>Managing Cron Jobs</p>
                        <p>To edit your crontab file, use:<br>crontab -e</p>
                        <p>To list the current scheduled jobs, use:<br>crontab -l</p>
                        <p>Use Cases for Cron</p>
                        <ul>
                            <li><b>Backups: Schedule a script to back up a directory daily or weekly.</b></li>
                            <li><b>System Cleanup: Automate the deletion of temporary files or logs.</b></li>
                            <li><b>Email Notifications: Schedule email reminders or system alerts.</b></li>
                        </ul>
                        <p>Cron Example</p>
                        <p>You want to run a script every Monday at 6 AM to update your system:<br>0 6 * * 1 /usr/bin/apt update && /usr/bin/apt upgrade -y</p>
                        <p>This command updates and upgrades the system every Monday at 6 AM.</p>

                        <h3>2. Anacron: Automating Tasks with No Strict Time Requirements</h3>
                        <p>Anacron is similar to cron, but it’s designed for systems that are not running 24/7, such as laptops or desktops that might be turned off at the time a cron job was supposed to run. Differences Between Anacron and Cron</p>
                        <ul>
                            <li><b>Cron assumes that the system is always running and tasks are scheduled based on time.</b></li>
                            <li><b>Anacron runs the scheduled jobs as soon as possible after the system starts, if it missed the scheduled time (e.g., if the system was off).</b></li>
                        </ul>

                        <h3>Anacron Configuration</h3>
                        <p>Anacron jobs are defined in /etc/anacrontab. Each job specifies how many days can pass between executions, along with a command to run.</p>
                        <p>The format is as follows:</p>
                        <ul>
                            <li><b>period: Number of days between job runs (1 for daily, 7 for weekly, 30 for monthly).</b></li>
                            <li><b>delay: Delay in minutes after the system starts before the job is run.</b></li>
                            <li><b>job-identifier: A unique name for the job.</b></li>
                            <li><b>command: The actual command to run.</b></li>
                        </ul>
                        <p>Anacron Example</p>
                        <p>Suppose you want to run a backup every 7 days (weekly):<br>7   10   weekly-backup   /path/to/backup.sh</p>
                        <p>This tells anacron to wait 10 minutes after system startup, then run backup.sh if 7 days have passed since the last time it was executed.</p>
                        <b>Use Cases for Anacron</b>
                        <ul>
                            <li><b>Laptops or Non-24/7 Systems: Ensures that maintenance tasks still run even if the machine wasn’t turned on at the scheduled time.</b></li>
                            <li><b>Daily, Weekly, Monthly Jobs: Anacron is commonly used for tasks that need to be run once per day, week, or month but don't need precise timing.</b></li>
                        </ul>

                        <h3>3. Scheduling Tasks with Cron and Anacron</h3>
                        <p>Both cron and anacron can be used to schedule tasks, but their use depends on the nature of the system and the task:</p>
                        <ul>
                            <li><b>Cron: For tasks that need to run at specific times (e.g., run every day at 3:00 AM).</b></li>
                            <li><b>Anacron: For tasks on systems that may be turned off, ensuring the task runs the next time the system starts.</b></li>
                        </ul>
                        <b>Combining Cron and Anacron</b>
                        <p>For systems that run most of the time but may occasionally shut down, you can combine cron and anacron. For example:</p>
                        <ul>
                            <li><b>Use cron for time-sensitive tasks (e.g., backups at exactly 2 AM).</b></li>
                            <li><b>Use anacron for important tasks that don’t need to run at specific times but must run eventually (e.g., weekly system cleanup).</b></li>
                        </ul>

                        <h3>4. Advanced Scheduling Features</h3>
                        <p>Wildcards and Ranges</p>
                        <ul>
                            <li><b>Wildcards (*): Used to represent "every possible value" (e.g., * * * * * runs every minute).</b></li>
                            <li><b>Ranges (-): Specify a range of values (e.g., 0-5 for the first five minutes of each hour).</b></li>
                            <li><b>Lists (,): Specify multiple values (e.g., 0,15,30,45 for every 15 minutes).</b></li>
                        </ul>
                        <b>Special Time Macros</b>
                        <p>Cron also supports special time macros for common schedules:</p>
                        <ul>
                            <li><b>@hourly: Runs every hour.</b></li>
                            <li><b>@daily: Runs once per day (midnight).</b></li>
                            <li><b>@weekly: Runs once per week (midnight Sunday).</b></li>
                            <li><b>@monthly: Runs once per month (midnight on the 1st).</b></li>
                            <li><b>@reboot: Runs once after each reboot.</b></li>
                        </ul>

                        <p>For example:</p>
                        <p>@daily /path/to/daily_backup.sh</p>
                        <p>This runs the daily_backup.sh script every day at midnight.</p>

                        <h3>5. Logs and Troubleshooting Cron Jobs</h3>
                        <p>To ensure that cron jobs are running correctly, Linux systems often log the results of cron jobs to system logs. You can check cron logs using:</p>
                        <ul>
                            <li><b>cat /var/log/syslog | grep cron</b></li>
                        </ul>
                        <p>or</p>
                        <ul>
                            <li><b>journalctl -u cron.service</b></li>
                        </ul>
                        <p>This helps you verify if a job ran successfully or if there were any errors.</p>
                        <p>Summary</p>
                        <ul>
                            <li><b>Cron is best for precise time-based scheduling on systems that are running continuously.</b></li>
                            <li><b>Anacron ensures tasks eventually run, even if the system was off at the scheduled time.</b></li>
                            <li><b>Both tools can be used to automate backups, maintenance, and updates.</b></li>
                            <li><b>Understanding how to schedule tasks efficiently improves system maintenance, ensuring important tasks are automated and performed regularly.</b></li>
                        </ul>
                        <p>These tools form the backbone of automated task scheduling in Linux, making them critical for managing system processes and ensuring consistent, timely maintenance.</p>
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week4day3exercises')">Exercises</button>
                            <div id="week4day3exercises" class="dropdown-content">
                                <h3>Exercise 1: Schedule a Simple Cron Job</h3>
                                <p>Create a script hello.sh that prints "Hello, world!" to a file.</p>
                                <p>Schedule the script to run every 5 minutes using cron.</p>
                                <p>Verify that the script runs at the scheduled time by checking the output file.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'echo "Hello, world!" >> ~/hello_output.txt' > ~/hello.sh<br>chmod +x ~/hello.sh</p>
                                <p>Schedule it with cron:<br>crontab -e</p>
                                <p>Add this line:<br>*/5 * * * * ~/hello.sh</p>
                                <p>Verify by checking the output file:<br>cat ~/hello_output.txt</p>

                                <h3>Exercise 2: Schedule a Daily Backup with Cron</h3>
                                <p>Create a backup script backup.sh that copies files from ~/project to /backup/project.</p>
                                <p>Schedule the script to run every day at 2 AM using cron.</p>
                                <p>Verify that the backup occurs.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'rsync -av ~/project /backup/project' > ~/backup.sh<br>chmod +x ~/backup.sh</p>
                                <p>Schedule with cron:<br>crontab -e</p>
                                <p>Add this line:<br>0 2 * * * ~/backup.sh</p>

                                <h3>Exercise 3: Use a Cron Special Time Macro</h3>
                                <p>Write a script that updates the system (apt update and apt upgrade).</p>
                                <p>Use the @weekly special time macro to schedule the script to run once every week.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'sudo apt update && sudo apt upgrade -y' > ~/system_update.sh<br>chmod +x ~/system_update.sh</p>
                                <p>Schedule using @weekly:<br>crontab -e</p>
                                <p>Add this line:<br>@weekly ~/system_update.sh</p>

                                <h3>Exercise 4: Use Cron with a Range</h3>
                                <p>Create a script log.sh that appends the current date and time to a log file.</p>
                                <p>Schedule it to run every day between 8 AM and 6 PM, every 30 minutes.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'date >> ~/log_output.txt' > ~/log.sh<br>chmod +x ~/log.sh</p>
                                <p>Schedule with a time range:<br>crontab -e</p>
                                <p>Add this line:<br>*/30 8-18 * * * ~/log.sh</p>

                                <h3>Exercise 5: Run a Job After Every Reboot with Cron</h3>
                                <p>Write a script startup_message.sh that writes "System has started!" to a file.</p>
                                <p>Use the @reboot cron option to run the script every time the system reboots.</p>
                                <p>Verify that the script runs on reboot.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'echo "System has started!" >> ~/startup_log.txt' > ~/startup_message.sh<br>chmod +x ~/startup_message.sh</p>
                                <p>Schedule using @reboot:<br>crontab -e</p>
                                <p>Add this line:</p>
                                <p>@reboot ~/startup_message.sh</p>

                                <h3>Exercise 6: Schedule a Job with Anacron</h3>
                                <p>Write a script daily_cleanup.sh that deletes files older than 7 days from ~/Downloads.</p>
                                <p>Schedule it to run daily using anacron, with a 10-minute delay after system boot.</p>
                                <p>Verify that the script runs when the system starts.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'find ~/Downloads -type f -mtime +7 -exec rm {} \;' > ~/daily_cleanup.sh<br>chmod +x ~/daily_cleanup.sh</p>
                                <p>Add the task to /etc/anacrontab:<br>sudo nano /etc/anacrontab<br>Add this line:<br>1 10 daily-cleanup ~/daily_cleanup.sh</p>

                                <h3>Exercise 7: Schedule a Weekly Task with Anacron</h3>
                                <p>Write a script weekly_backup.sh that backs up your home directory to /backup/home_backup.</p>
                                <p>Schedule it to run every week using anacron, with a 15-minute delay after system boot.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'rsync -av ~/ /backup/home_backup' > ~/weekly_backup.sh<br>chmod +x ~/weekly_backup.sh</p>
                                <p>Add the task to /etc/anacrontab:<br>sudo nano /etc/anacrontab</p>
                                <p>Add this line:<br>7 15 weekly-backup ~/weekly_backup.sh</p>

                                <h3>Exercise 8: Troubleshooting a Cron Job</h3>
                                <p>Schedule a cron job to run a script that does not exist (non_existent.sh).</p>
                                <p>Check the cron log to see the error messages related to the missing file.</p>
                                <p>Correct the cron job to run an actual script.</p>
                                <b>Steps:</b>
                                <p>Schedule the broken job:<br>crontab -e</p>
                                <p>Add this line:<br>* * * * * ~/non_existent.sh</p>
                                <p>Wait a few minutes, then check the cron log:<br>grep cron /var/log/syslog</p>
                                <p>Correct the cron job to a valid script.</p>

                                <h3>Exercise 9: View and Analyze Cron Logs</h3>
                                <p>Schedule a cron job that logs the current system uptime to a file every 10 minutes.</p>
                                <p>Check the cron logs to confirm that the job runs successfully.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'uptime >> ~/uptime_log.txt' > ~/log_uptime.sh<br>chmod +x ~/log_uptime.sh</p>
                                <p>Schedule the cron job:<br>crontab -e</p>
                                <p>Add this line:<br>*/10 * * * * ~/log_uptime.sh</p>
                                <p>View the cron logs to confirm:<br>grep cron /var/log/syslog</p>

                                <h3>Exercise 10: Automate a System Health Report with Cron</h3>
                                <p> Write a script health_report.sh that gathers system information (disk usage, memory usage, CPU load) and saves it to a report file.</p>
                                <p>Schedule it to run daily at 1 AM.</p>
                                <p>Verify that the reports are being generated.</p>
                                <b>Steps:</b>
                                <p>Create the script:<br>echo 'df -h > ~/system_health.txt && free -h >> ~/system_health.txt && uptime >> ~/system_health.txt' > ~/health_report.sh<br>chmod +x ~/health_report.sh</p>
                                <p>Schedule the cron job:<br>crontab -e</p>
                                <p>Add this line:<br>0 1 * * * ~/health_report.sh</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week4day4')">Day 4</button>
                <div id="week4day4" class="dropdown-content">
                    <div class="day-title">Advanced Shell Scripting</div>
                    <div class="day-info">
                        <h3>Advanced Scripting Techniques and Script Debugging/Optimization in Linux</h3>
                        <p>After mastering basic shell scripting, the next step is learning advanced scripting techniques to handle more complex tasks. This includes using control structures, functions, arrays, and more to write efficient, reusable, and maintainable scripts. Script debugging and optimization are essential for identifying and resolving errors and improving the performance and readability of scripts.</p>

                        <h3>1. Advanced Scripting Techniques</h3>
                        <b>a. Using Functions in Shell Scripts</b>
                        <p>Functions allow you to reuse blocks of code without repetition, making your scripts cleaner and more modular. They are especially useful when the same code needs to be executed multiple times.</p>
                        <p>Syntax:</p>
                        <p>function_name() {
                            # commands
                        }</p>
                        <p>Example:</p>
                        <p>#!/bin/bash<br># Define a function to check disk usage</p>
                        <p>check_disk_usage() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;df -h<br>}</p>
                        <p># Call the function<br>check_disk_usage</p>

                        <b>b. Arrays in Shell Scripts</b>
                        <p>Arrays in shell scripting allow you to store multiple values in a single variable. Arrays can be indexed by numbers and are useful when handling lists of data (e.g., file paths or user inputs).</p>
                        <p>Syntax:</p>
                        <p>array_name=(element1 element2 element3)</p>
                        <p>Example:</p>
                        <p>#!/bin/bash<br># Define an array of file names</p>
                        <p>files=("file1.txt" "file2.txt" "file3.txt")</p>
                        <p># Loop through array elements and print them<br>for file in "${files[@]}"; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Processing $file"<br>done</p>

                        <h3>c. Loops (For, While, Until)</h3>
                        <p>Loops allow you to execute commands repeatedly based on a condition. In addition to the basic for loop, you can use while and until loops to control the flow of your script based on conditions.</p>
                        <p>For Loop:</p>
                        <p>for i in {1..5}; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Number: $i"<br>done</p>
                        <p>While Loop:</p>
                        <p>count=1<br>while [ $count -le 5 ]; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Count: $count"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count=$((count + 1))<br>done</p>
                        <p>Until Loop:</p>
                        <p>count=5<br>until [ $count -lt 1 ]; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Countdown: $count"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count=$((count - 1))<br>done</p>

                        <h3>d. Conditional Statements (If, Else, Case)</h3>
                        <p>Control structures such as if, else, and case help make decisions in scripts based on conditions.</p>
                        <p>If-Else Statement:</p>
                        <p>#!/bin/bash<br># Check if a file exists</p>
                        <p>if [ -f "/homw/harrycallahan/loop1.sh" ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "File exists."<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "File does not exist."<br>fi</p>
                        <p>Case Statement:</p>
                        <p>A case statement is useful when you need to choose between several options.</p>
                        <p>#!/bin/bash<br># Determine the day of the week</p>
                        <p>day=$(date +%A)</p>
                        <p>case $day in<br>&nbsp;&nbsp;&nbsp;&nbsp;Monday)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "It's Monday, start of the week!"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;;<br>&nbsp;&nbsp;&nbsp;&nbsp;Friday)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "It's Friday, almost weekend!"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;;<br>&nbsp;&nbsp;&nbsp;&nbsp;*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "It's $day."<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;;<br>esac</p>

                        <h3>e. Input and Output Redirection</h3>
                        <p>Advanced scripts often require redirecting input and output. Redirection can send the output of a command to a file or use a file as input.</p>
                        <p>Standard Output (stdout) Redirection:</p>
                        <p>command > output.txt  # Overwrites output.txt<br>command >> output.txt  # Appends to output.txt</p>
                        <p>Standard Input (stdin) Redirection:</p>
                        <ul>
                            <li><b>command < input.txt  # Uses input.txt as input</b></li>
                        </ul>
                        <p>Standard Error (stderr) Redirection:</p>
                        <ul>
                            <li><b>command 2> error.txt  # Redirects error output to error.txt</b></li>
                        </ul>
                        <p>Combine stdout and stderr:</p>
                        <ul>
                            <li><b>command > output.txt 2>&1  # Redirect both stdout and stderr to output.txt</b></li>
                        </ul>

                        <h3>2. Script Debugging Techniques</h3>
                        <p>Even seasoned scripters face errors in their code. Debugging is the process of identifying and fixing these errors. Shell scripting has built-in mechanisms to help you trace, log, and debug scripts.</p>
                        <b>a. Enabling Debug Mode</b>
                        <p>You can enable debug mode in a script to show each command and its result as it executes.</p>
                        <p>To debug an entire script, add the -x option to the shebang:</p>
                        <ul>
                            <li<b>#!/bin/bash -x</b></li>
                        </ul>
                        <p>Or run the script with:</p>
                        <ul>
                            <li><b>bash -x script.sh</b></li>
                        </ul>

                        <b>b. Using set Options for Debugging</b>
                        <p>The set command allows you to control shell options within the script. Some helpful options for debugging include:</p>
                        <ul>
                            <li><b>set -x: Enables debug mode, prints each command before executing.</b></li>
                            <li><b>set -e: Exits the script if any command fails.</b></li>
                            <li><b>set -u: Treats unset variables as an error.</b></li>
                            <li><b>set -o pipefail: Causes the script to fail if any command in a pipeline fails.</b></li>
                        </ul>
                        <p>Example:</p>
                        <p>#!/bin/bash<br>set -x  # Enable debug mode</p>
                        <p>file="/path/to/file"</p>
                        <p>if [ -f "$file" ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "File exists"<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "File not found"<br>fi</p>

                        <b>c. Using trap for Error Handling</b>
                        <p>The trap command allows you to capture signals or errors and execute custom commands when they occur. This is useful for cleaning up temporary files or printing messages before a script exits.</p>
                        <p>Syntax:</p>
                        <p>trap 'commands' SIGNAL</p>
                        <p>Example:</p>
                        <p>#!/bin/bash<br>trap 'echo "An error occurred. Exiting..."; exit 1;' ERR</p>
                        <p># Simulate an error<br>ls /nonexistent/file</p>

                        <b>d. Logging and Debug Information</b>
                        <p>Use logging to track what your script is doing. You can use echo commands or redirect output to log files.</p>
                        <p>Example:</p>
                        <p>#!/bin/bash<br>log_file="/path/to/log_file.log"</p>
                        <p># Log the start of the script<br>echo "Script started at $(date)" >> $log_file</p>
                        <p># Perform some task and log the result<br>if [ -f "/path/to/file" ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "File exists." >> $log_file<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "File does not exist." >> $log_file<br>fi</p>
                        <p># Log the end of the script<br>echo "Script ended at $(date)" >> $log_file</p>

                        <h3>3. Script Optimization Techniques</h3>
                        <p>After debugging, you can improve the performance and efficiency of your scripts by optimizing them. Optimization focuses on making your script run faster, use fewer resources, or be easier to maintain.</p>
                        <b>a. Avoiding Unnecessary Subshells</b>
                        <p>Each time you use a command within $(), it spawns a subshell. Reduce the number of subshells for better performance.</p>
                        <p>Example:</p>
                        <p>Instead of:</p>
                        <ul>
                            <li><b>var=$(cat file.txt)</b></li>
                        </ul>
                        <p>Use:</p>
                        <ul>
                            <li><b>''var=$(<(file.txt)''</b></li>
                        </ul>
                        <p>This avoids spawning an extra process.</p>

                        <b>b. Use Built-in Shell Commands</b>

                        <p>Built-in shell commands ([[ ]], test, let, echo) are faster than external commands (expr, grep, awk). Prefer built-in commands for common tasks.</p>
                        <p>Example:</p>
                        <p>Instead of:</p>
                        <ul>
                            <li><b>result=$(expr $num1 + $num2)</b></li>
                        </ul>
                        <p>Use:</p>
                        <ul>
                            <li><b>let result=$num1+$num2</b></li>
                        </ul>

                        <b>c. Optimize Loops</b>
                        <p>Try to minimize the number of iterations in loops by handling as much work as possible outside of the loop. Avoid using loops when a built-in command can handle the task more efficiently.</p>
                        <p>Example:</p>
                        <p>Instead of:</p>
                        <p>for file in $(ls *.txt); do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# process files<br>done</p>
                        <p>Use:</p>
                        <p>for file in *.txt; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# process files<br>done</p>
                        <p>This avoids spawning unnecessary subshells for each ls command.</p>

                        <b>d. Use xargs for Efficient Pipelining</b>
                        <p>When working with a large number of files, xargs can speed up execution by processing multiple files at once, rather than one at a time.</p>
                        <p>Example:</p>
                        <p>Instead of:</p>
                        <p>find . -name "*.txt" | while read file; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rm "$file"<br>done</p>
                        <p>Use:</p>
                        <ul>
                            <li><b>find . -name "*.txt" | xargs rm</b></li>
                        </ul>
                        <p>This uses xargs to remove all files in a single command rather than repeatedly calling rm.</p>
                        <p>These advanced scripting techniques, debugging, and optimization methods, you'll be able to write more efficient and reliable scripts, making your workflows more automated and error-resistant.</p>
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week4day4exercises')">Exercises</button>
                            <div id="week4day4exercises" class="dropdown-content">
                                <h3>Exercise 1: Create a Script with Functions</h3>
                                <p>Write a script that includes two functions:</p>
                                <ul>
                                    <li><b>check_disk_space: This function should display the current disk usage (df -h).</b></li>
                                    <li><b>check_memory_usage: This function should display the current memory usage (free -h).</b></li>
                                    <li><b>Call both functions in the script.</b></li>
                                </ul>

                                <h3>Exercise 2: Using Arrays in Scripts</h3>
                                <p>Create a script that:</p>
                                <ul>
                                    <li><b>Defines an array of 5 directory paths.</b></li>
                                    <li><b>Loops through the array and checks if each directory exists.</b></li>
                                    <li><b>If it exists, print "Directory exists". If not, print "Directory does not exist".</b></li>
                                </ul>

                                <h3>Exercise 3: Using Loops for Automation</h3>
                                <p>Write a script that:</p>
                                <ul>
                                    <li><b>Creates a directory called "test_dir".</b></li>
                                    <li><b>Inside "test_dir", creates 5 files (file1.txt, file2.txt, ..., file5.txt).</b></li>
                                    <li><b>Use a for loop to append the line "This is file X" into each file (where X is the number of the file).</b></li>
                                </ul>

                                <h3>Exercise 4: Conditional Logic</h3>
                                <p>Create a script that:</p>
                                <ul>
                                    <li><b>Asks the user to input a number.</b></li>
                                    <li><b>If the number is greater than 10, print "The number is greater than 10".</b></li>
                                    <li><b>If the number is less than or equal to 10, print "The number is 10 or less".</b></li>
                                </ul>

                                <h3>Exercise 5: Using case Statements</h3>
                                <p>Write a script that:</p>
                                <ul>
                                    <li><b>Asks the user to input the day of the week (e.g., Monday, Tuesday).</b></li>
                                    <li><b>Uses a case statement to print a custom message for each day. For example, if the user inputs "Monday", print "Start of the week!".</b></li>
                                </ul>

                                <h3>Exercise 6: Debug a Broken Script</h3>
                                <p>A script is supposed to create a backup of a file but has some errors. Debug the following script and make it work correctly:</p>
                                <p>#!/bin/bash<br>set -x</p>
                                <p>backup_file="/home/user/documents/file.txt.bak"<br>source_file="/home/user/documents/file.txt"</p>
                                <p>if [-f "$source_file"]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cp $source_file $backup_file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Backup successful."<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Source file does not exist."<br>fi</p>
                                <p>Fix the errors and run the script in debug mode.</p>

                                <h3>Exercise 7: Error Handling with trap</h3>
                                <p>Write a script that:</p>
                                <ul>
                                    <li><b>Asks the user for a file path.</b></li>
                                    <li><b>If the file does not exist, trap the error and print "File not found. Exiting..." and exit the script.</b></li>
                                </ul>
                                <p>Use trap to handle the error when the file is not found.</p>

                                <h3>Exercise 8: Debugging with set Options</h3>
                                <p>Create a script that:</p>
                                <ul>
                                    <li><b>Uses set -e, set -x, and set -u.</b></li>
                                    <li><b>Prompts the user for their username and checks if their home directory exists.</b></li>
                                </ul>
                                <p>Test the script with and without correct input to see how the set options work.</p>

                                <h3>Exercise 9: Script Optimization Using xargs</h3>
                                <p>Create a script that:</p>
                                <ul>
                                    <li><b>Uses find to locate all .log files in a directory.</b></li>
                                    <li><b>Uses xargs to delete all the found .log files at once, rather than one by one.</b></li>
                                </ul>

                                <h3>Exercise 10: Optimize Loops and Subshells</h3>
                                <p>Write a script that:</p>
                                <ul>
                                    <li><b>Loops over a list of files and moves each file to a new directory.</b></li>
                                    <li><b>Optimize the script to avoid spawning subshells unnecessarily. Instead of using ls to list files, use built-in shell commands to iterate over files.</b></li>
                                </ul>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week4day5')">Day 5</button>
                <div id="week4day5" class="dropdown-content">
                    <div class="day-title">Practical Project</div>
                    <div class="day-info">
                        <p>Project: Setting Up a Web Server (Apache) and a File Server (Samba)</p>
                        <b>Project Overview</b>
                        <ul>
                            <li><b>Web Server (Apache): We'll set up an Apache web server to serve a simple website.</b></li>
                            <li><b>File Server (Samba): We'll configure a Samba file server for file sharing across a network.</b></li>
                        </ul>
                        <p>Each project will include the installation, configuration, and basic management of these services, allowing users to apply their knowledge of permissions, networking, security, and system performance monitoring.</p>

                        <h3>Part 1: Setting Up a Web Server with Apache</h3>
                        <b>Step 1: Install Apache</b>
                        <p>Open the terminal on your Linux server or virtual machine.</p>
                        <p>Update the package list:</p>
                        <p>sudo apt update</p>
                        <p>Install Apache:</p>
                        <ul>
                            <li><b>sudo apt install apache2</b></li>
                        </ul>
                        <p>Start and enable Apache to start on boot:</p>
                        <ul>
                            <li><b>sudo systemctl start apache2</b></li>
                            <li><b>sudo systemctl enable apache2</b></li>
                        </ul>

                        <b>Step 2: Configure the Web Server</b>
                        <p> Open the Apache configuration file:</p>
                        <ul>
                            <li><b>sudo nano /etc/apache2/sites-available/000-default.conf</b></li>
                        </ul>
                        <p>Modify the DocumentRoot to point to the directory where your website files will be stored. For example:</p>
                        <ul>
                            <li><b>DocumentRoot /var/www/html/mywebsite</b></li>
                        </ul>
                        <p>Save and exit the file (Ctrl+X, then Y to save).</p>

                        <b>Step 3: Create Your Website</b>
                        <p>Create the directory for your website:</p>
                        <ul>
                            <li><b>sudo mkdir -p /var/www/html/mywebsite</b></li>
                            <li><b> sudo nano /var/www/html/mywebsite/index.html</b></li>
                        </ul>
                        <p>Add some simple HTML content, you can find examples over the web and pase in to a file.</p>
                        <p>Save and exit the file.</p>

                        <b>Step 4: Adjust Permissions</b>
                        <p>Set the correct ownership and permissions for the web files:</p>
                        <ul>
                            <li><b>sudo chown -R www-data:www-data /var/www/html/mywebsite</b></li>
                            <li><b>sudo chmod -R 755 /var/www/html/mywebsite</b></li>
                        </ul>

                        <b>Step 5: Test the Web Server</b>
                        <p>Restart Apache to apply the changes:</p>
                        <ul>
                            <li><b>Restart Apache to apply the changes:</b></li>
                        </ul>
                        <p>Open a web browser and type in the IP address of your server. You should see the web page you just created!</p>
                        <p>If the server is running locally, you can open http://localhost or http://your-server-ip-address. You can use ip addr or ifconfig to find your ip.</p>

                        <b>Step 6: Basic Security Practices</b>
                        <p>Enable the UFW firewall (if not enabled):</p>
                        <ul>
                            <li><b>sudo ufw enable</b></li>
                        </ul>
                        <p>Allow HTTP and HTTPS traffic through the firewall:</p>
                        <ul>
                            <li><b>sudo ufw allow 'Apache Full'</b></li>
                        </ul>

                        <h3>Part 2: Setting Up a File Server with Samba</h3>
                        <b>Step 1: Install Samba</b>
                        <p>Install the Samba package:</p>
                        <ul>
                            <li><b>sudo apt install samba</b></li>
                        </ul>

                        <b>Step 2: Create a Shared Directory</b>
                        <p>Create a directory that will be shared across the network:</p>
                        <ul>
                            <li><b>sudo mkdir -p /srv/samba/share</b></li>
                        </ul>
                        <p>Set the appropriate permissions for the directory:</p>
                        <ul>
                            <li><b>sudo chmod 2775 /srv/samba/share</b></li>
                            <li><b>sudo chown nobody:nogroup /srv/samba/share</b></li>
                        </ul>

                        <b>Step 3: Configure Samba</b>
                        <p>Open the Samba configuration file:</p>
                        <ul>
                            <li><b>sudo nano /etc/samba/smb.conf</b></li>
                        </ul>
                        <p>Scroll to the bottom of the file and add the following configuration for your shared folder:</p>
                        <p>[SharedFolder]<br>path = /srv/samba/share<br>browseable = yes<br>read only = no<br>guest ok = yes</p>
                        <p>Save and exit the file.</p>

                        <b>Step 4: Restart Samba</b>
                        <p>Restart the Samba service to apply the changes:</p>
                        <ul>
                            <li><b>sudo systemctl restart smbd</b></li>
                        </ul>

                        <b>Step 5: Access the File Server</b>
                        <p>On a Windows or Linux machine, open the file manager and try to access the server using its IP address.<br>On Windows, you can open \\your-server-ip-address\SharedFolder in File Explorer.<br>On Linux, you can open the file manager and use the smb://your-server-ip-address/SharedFolder URL to access the shared folder.</p>

                        <b>Part 3: Hands-on Lab Exercises</b>
                        <p>Web Server (Apache) Exercises:</p>
                        <p>Create a Custom Virtual Host:</p>
                        <ul>
                            <li><b>Configure Apache to serve a second website with a different domain (use localhost aliases).</b></li>
                            <li><b>Modify the /etc/hosts file to access the website via http://mynewwebsite.local.</b></li>
                        </ul>
                        <p>Add a New Web Page:</p>
                        <ul>
                            <li><b>Create a new directory under /var/www/html/yourwebsite/ and add a second HTML file (e.g., about.html).</b></li>
                            <li><b>Link the new page to the home page and ensure both pages are accessible via the browser.</b></li>
                        </ul>
                        <p>Configure HTTPS with a Self-signed Certificate:</p>
                        <ul>
                            <li><b>Generate a self-signed SSL certificate using openssl and configure Apache to serve your website over HTTPS.</b></li>
                        </ul>
                        <p>Enable Directory Listing:</p>
                        <ul>
                            <li><b>Configure Apache to enable directory listing for a specific folder. Access it through the browser and navigate the directory contents.</b></li>
                        </ul>

                        <b>File Server (Samba) Exercises:</b>
                        <p>Create a Password-protected Share:</p>
                        <ul>
                            <li><b>Modify the Samba configuration to create a share that requires a username and password for access.</b></li>
                            <li><b>Use smbpasswd to create a Samba user and test the login from another machine.</b></li>
                        </ul>
                        <p>Create Multiple Shared Folders:</p>
                        <ul>
                            <li><b>Set up two more shared directories with different permissions (one read-only and the other read-write). Test the functionality from a client machine.</b></li>
                        </ul>
                        <p>Monitor Samba Activity:</p>
                        <ul>
                            <li><b>Use Samba logs to monitor file access and user activity on the shared directories.</b></li>
                        </ul>

                        <b>Part 4: Monitoring and Security</b>
                        <p>System Monitoring Tasks:</p>
                        <p>Monitor Apache Performance:</p>
                        <ul>
                            <li><b>Use the top or htop command to monitor the CPU and memory usage of Apache processes.</b></li>
                            <li><b>Configure Apache logging to track access and errors (/var/log/apache2/access.log and /var/log/apache2/error.log).</b></li>
                        </ul>
                        <p>Monitor Samba Activity:</p>
                        <ul>
                            <li><b>Use tail to track Samba logs (/var/log/samba/log.smbd) and watch for connection attempts and file access activity.</b></li>
                        </ul>
                        <p>Basic Security Tasks:</p>
                        <p>Secure the Samba Share with User Authentication:</p>
                        <ul>
                            <li><b>Configure user-based access control for the Samba share and allow access to specific users only.</b></li>
                            <li><b>Test the setup by creating multiple users and granting different permissions to the shared folders.</b></li>
                        </ul>
                        <p>Firewall Configuration:</p>
                        <ul>
                            <li><b>Use ufw to allow Samba traffic only from trusted IP addresses.</b></li>
                            <li><b>Restrict access to the Samba file server from external networks using IP filtering.</b></li>
                        </ul>
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week4day5exercises')">Exercises</button>
                            <div id="week4day5exercises" class="dropdown-content">
                                <h3>Exercise 1: Create a Custom Virtual Host</h3>
                                <p>Step-by-Step Answer:</p>
                                <p>Create a New Virtual Host Configuration File:</p>
                                <p>Copy the default Apache virtual host configuration to a new file:</p>
                                <ul>
                                    <li><b>sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/mynewwebsite.conf</b></li>
                                </ul>
                                <p>Edit the New Virtual Host File:</p>
                                <p>Open the new configuration file:</p>
                                <ul>
                                    <li><b>sudo nano /etc/apache2/sites-available/mynewwebsite.conf</b></li>
                                </ul>
                                <p>Change the DocumentRoot to point to a new directory:</p>
                                <ul>
                                    <li><b>DocumentRoot /var/www/html/mynewwebsite</b></li>
                                    <li><b>ServerName mynewwebsite.local</b></li>
                                </ul>
                                <p>Save and exit the file.</p>
                                <p>Create the Directory for the New Website:</p>
                                <ul>
                                    <li><b>sudo mkdir /var/www/html/mynewwebsite</b></li>
                                </ul>
                                <p>Create a Simple index.html File:</p>
                                <p>Inside the new directory, create the index.html:</p>
                                <ul>
                                    <li><b>sudo nano /var/www/html/mynewwebsite/index.html</b></li>
                                </ul>
                                <p>Add some simple content:</p>
                                <p>Update /etc/hosts to Map the Domain:</p>
                                <p>Open the /etc/hosts file to add a domain mapping:</p>
                                <ul>
                                    <li><b>sudo nano /etc/hosts</b></li>
                                </ul>
                                <p>Add the following line:</p>
                                <p>127.0.0.1 mynewwebsite.local</p>
                                <p>Enable the Virtual Host:</p>
                                <p>Enable the new site:</p>
                                <ul>
                                    <li><b>sudo a2ensite mynewwebsite.conf</b></li>
                                </ul>
                                <p>Disable the default site if necessary:</p>
                                <ul>
                                    <li><b>sudo a2dissite 000-default.conf</b></li>
                                </ul>
                                <p>Reload Apache:</p>
                                <ul>
                                    <li><b>sudo systemctl reload apache2</b></li>
                                </ul>
                                <p>Test the Website:<br>Open a web browser and go to http://mynewwebsite.local. You should see your new site!</p>

                                <h3>Exercise 2: Add a New Web Page</h3>
                                <p>Step-by-Step Answer:</p>
                                <p>Create a New Directory for the Second Page:</p>
                                <ul>
                                    <li><b>sudo mkdir /var/www/html/mywebsite/about</b></li>
                                </ul>
                                <p>Create the about.html File:</p>
                                <ul>
                                    <li><b>sudo nano /var/www/html/mywebsite/about/about.html</b></li>
                                </ul>
                                <p>Add some content about a new page:</p>
                                <p>Link the about.html to the Home Page:</p>
                                <p>Open the index.html file in the main directory:</p>
                                <ul>
                                    <li><b>sudo nano /var/www/html/mywebsite/index.html</b></li>
                                </ul>
                                <p>Add a link to the new page:</p>
                                <p> href="/about/about.html">About Us</p>
                                <p>you may need too add a tags to the code above</p>
                                <p>Test the New Page:<br>Open a browser and go to http://localhost or your server's IP address. You should see the link to the "About Us" page. Click it to ensure the second page is working.</p>

                                <h3>Exercise 3: Configure HTTPS with a Self-signed Certificate</h3>
                                <p>Step-by-Step Answer:</p>
                                <p>Generate a Self-signed SSL Certificate:</p>
                                <p>Create a directory to store the SSL certificate:</p>
                                <ul>
                                    <li><b>sudo mkdir /etc/apache2/ssl</b></li>
                                </ul>
                                <p>Generate the certificate and key:</p>
                                <ul>
                                    <li><b>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/apache2/ssl/apache.key -out /etc/apache2/ssl/apache.crt</b></li>
                                </ul>
                                <p> Follow the prompts and fill in the required information.</p>
                                <p>Enable SSL Module in Apache:</p>
                                <ul>
                                    <li><b>sudo a2enmod ssl</b></li>
                                </ul>
                                <p>Edit the Virtual Host to Use HTTPS:</p>
                                <p>Open your virtual host configuration file:</p>
                                <ul>
                                    <li><b>sudo nano /etc/apache2/sites-available/mynewwebsite.conf</b></li>
                                </ul>
                                <p>Add the following inside the file, replacing the existing VirtualHost block:</p>
                                <p>VirtualHost *:443<br>DocumentRoot /var/www/html/mynewwebsite<br>ServerName mynewwebsite.local<br>SSLEngine on<br>SSLCertificateFile /etc/apache2/ssl/apache.crt<br>SSLCertificateKeyFile /etc/apache2/ssl/apache.key<br>/VirtualHost</p>
                                <p>Enable the SSL Site:</p>
                                <ul>
                                    <li><b>sudo a2ensite mynewwebsite.conf</b></li>
                                </ul>
                                <p>Restart Apache:</p>
                                <p>sudo systemctl restart apache2</p>
                                <p>Test HTTPS:</p>
                                <ul>
                                    <li><b>Open a web browser and go to https://mynewwebsite.local. You should see the site secured with your self-signed SSL certificate.</b></li>
                                </ul>

                                <h3>Exercise 4: Enable Directory Listing</h3>
                                <p>Add the Following to Enable Directory Listing:</p>
                                <p>Add the following Directory block:</p>
                                <p>Directory /var/www/html/mywebsite<br>Options Indexes FollowSymLinks<br>AllowOverride None<br>Require all granted<br>/Directory</p>
                                <p>Save and Exit the File.</p>

                                <p>Restart Apache:</p>
                                <ul>
                                    <li><b>sudo systemctl restart apache2</b></li>
                                </ul>
                                <p>Test Directory Listing:</p>
                                <ul>
                                    <li><b> Add some files in the /var/www/html/mywebsite/ directory and open the URL in a browser (http://localhost/yourdirectory/). You should see the files listed in the browser.</b></li>
                                </ul>

                                <b>File Server (Samba) Exercises:</b>
                                <b>Exercise 1: Create a Password-Protected Share</b>
                                <p>Step-by-Step Answer:</p>
                                <p>Add a Samba User:</p>
                                <ul>
                                    <li><b>sudo smbpasswd -a username</b></li>
                                </ul>
                                <p> You will be prompted to enter a password for the Samba user.</p>
                                <p>Edit the Samba Configuration File:</p>
                                <ul>
                                    <li><b>sudo nano /etc/samba/smb.conf</b></li>
                                </ul>
                                <p>Add the Following Share Block:</p>
                                <p>Add the following at the end of the file:</p>
                                <p>[ProtectedShare]<br>path = /srv/samba/protected<br>valid users = username<br>guest ok = no<br>read only = no</p>
                                <p>Save and exit the file.</p>
                                <p>Create the Shared Directory:</p>
                                <ul>
                                    <li><b>sudo mkdir -p /srv/samba/protected</b></li>
                                    <li><b>sudo chown username:username /srv/samba/protected</b></li>
                                </ul>
                                <p>Restart Samba:</p>
                                <ul>
                                    <li><b>sudo systemctl restart smbd</b></li>
                                </ul>
                                <p>Access the Share:</p>
                                <ul>
                                    <li><b>From another machine, access the share by going to \\your-server-ip-address\ProtectedShare. You will be prompted for the username and password.</b></li>
                                </ul>
                                
                                <b>Exercise 2: Create Multiple Shared Folders</b>
                                <p>Step-by-Step Answer:</p>
                                <p>Create Multiple Shared Directories:</p>
                                <ul>
                                    <li><b>sudo mkdir -p /srv/samba/public</b></li>
                                    <li><b>sudo mkdir -p /srv/samba/private</b></li>
                                    <li><b>sudo chown nobody:nogroup /srv/samba/public</b></li>
                                    <li><b>sudo chown username:username /srv/samba/private</b></li>
                                </ul>
                                <p>Configure Samba for Both Folders:</p>
                                <p>Open the Samba configuration file:</p>
                                <ul>
                                    <li><b>sudo nano /etc/samba/smb.conf</b></li>
                                </ul>
                                <p>Add the following blocks:</p>
                                <ul>
                                    <li><b>[PublicShare]</b></li>
                                    <li><b>path = /srv/samba/public</b></li>
                                    <li><b>guest ok = yes</b></li>
                                    <li><b>read only = yes</b></li>
                                </ul>
                                <ul>
                                    <li><b>[PrivateShare]</b></li>
                                    <li><b>path = /srv/samba/private</b></li>
                                    <li><b>valid users = username</b></li>
                                    <li><b>guest ok = no</b></li>
                                    <li><b>read only = no</b></li>
                                </ul>
                                <p>Restart Samba:</p>
                                <ul>
                                    <li><b>sudo systemctl restart smbd</b></li>
                                </ul>
                                <p>Test the Shares:</p>
                                <p>From another machine, connect to both shares (\\your-server-ip-address\PublicShare and \\your-server-ip-address\PrivateShare) to ensure they work as expected.</p>

                                <b>Exercise 3: Monitor Samba Activity</b>
                                <p>Step-by-Step Answer:</p>
                                <p>Check Samba Log Files:</p>
                                <p>Use tail to monitor Samba logs in real-time:</p>
                                <ul>
                                    <li><b> sudo tail -f /var/log/samba/log.smbd</b></li>
                                </ul>
                                <p>Access the Samba Share from a Client:</p>
                                <p>Perform some file access activities (e.g., copy a file to the shared folder).</p>
                                <p>Watch the log file and observe the entries for each access.</p>

                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="dropdown">
                <button onclick="toggleDropdown('week4review')">Week Review</button>
                <div id="week4review" class="dropdown-content">
                    <div class="day-title">Week Four Review: Security, Backup, Automation, and Advanced Scripting</div>
                    <div class="day-info">
                        <p>In week four, we expanded our focus to critical areas of system security, backup and recovery, task automation, advanced shell scripting, and hands-on project work. Here’s a recap of each area.</p>

                        <h3>1. Basic Security Concepts</h3>
                        <p>Security is essential in Linux, ensuring that systems are protected from unauthorized access, data breaches, and attacks.</p>
                        <p>Firewalls:</p>
                        <ul>
                            <li><b>UFW (Uncomplicated Firewall): A simplified tool to manage firewall rules. Example: ufw allow 22 allows SSH access.</b></li>
                            <li><b>iptables: A more advanced tool that offers fine-grained control over network traffic.</b></li>
                        </ul>
                        <p><b>User and Permission Management: Regularly updating permissions and using secure passwords can help prevent unauthorized access.</b></p>
                        <p>Security Best Practices:</p>
                        <ul>
                            <li><b>Regularly update software to patch vulnerabilities.</b></li>
                            <li><b>Use secure SSH configurations (e.g., disabling root login).</b></li>
                            <li><b>Apply the principle of least privilege, granting only necessary permissions to users and processes.</b></li>
                        </ul>
                        <p>Implementing basic security concepts and firewall rules helps protect systems from potential threats and ensures secure access control.</p>

                        <h3>2. Backup and Recovery</h3>
                        <p>A good backup strategy is essential to prevent data loss and facilitate system recovery in case of hardware failure, accidental deletion, or other issues.</p>
                        <p>Backup Tools:</p>
                        <ul>
                            <li><b>rsync: A powerful tool for copying and synchronizing files and directories across locations.</b></li>
                            <li><b>tar: Archives files into compressed formats (like .tar.gz), often used for creating backups.</b></li>
                        </ul>
                        <p>Creating Backups:</p>
                        <ul>
                            <li><b>For example, rsync -av /source/ /destination/ backs up files from a source to a destination.</b></li>
                            <li><b>tar -czvf backup.tar.gz /path/to/directory creates a compressed backup of a directory.</b></li>
                        </ul>
                        <p>Restoring Backups:</p>
                        <ul>
                            <li><b>Use tar -xzvf backup.tar.gz -C /restore/path to restore a compressed backup.</b></li>
                            <li><b>rsync can also synchronize files back to their original locations.</b></li>
                        </ul>
                        <p>Regular backups and knowledge of restoration procedures ensure data availability and quick recovery from incidents.</p>

                        <h3>3. Automating Tasks</h3>
                        <p>Automating repetitive tasks increases efficiency and ensures consistency in system management.</p>
                        <p>cron:</p>
                        <ul>
                            <li><b>Used for scheduling regular tasks.</b></li>
                            <li><b>Crontab syntax includes minute, hour, day, month, and day-of-week fields to define when a job runs. Example: 0 2 * * * /path/to/script.sh runs a script daily at 2 AM.</b></li>
                        </ul>
                        <p>anacron:</p>
                        <ul>
                            <li><b>Similar to cron, but suited for periodic tasks on systems not always running (like laptops). Useful for daily, weekly, and monthly jobs.</b></li>
                            <li><b>Requires configuration files in /etc/anacrontab.</b></li>
                        </ul>
                        <p>Task automation with cron and anacron helps maintain system health, perform regular maintenance, and free up time for administrators.</p>

                        <h3>4. Advanced Shell Scripting</h3>
                        <p>?This week, we moved beyond basic scripting to explore more complex shell scripting techniques, which enable custom solutions for administrative tasks.</p>
                        <p>Advanced Syntax and Logic:</p>
                        <ul>
                            <li><b>Functions: Organize code and reuse blocks of logic, improving readability and maintenance.</b></li>
                            <li><b>Arrays: Store multiple values in a single variable, useful for handling data.</b></li>
                            <li><b>Error Handling: Using conditionals and exit statuses to handle errors improves reliability.</b></li>
                        </ul>
                        <p>Script Debugging:</p>
                        <ul>
                            <li><b>Using set -x enables debugging by printing each command before it runs.</b></li>
                            <li><b>Checking exit statuses and using trap to catch errors can prevent scripts from failing unexpectedly.</b></li>
                        </ul>
                        <p>Advanced scripting provides the flexibility to automate complex tasks, enhance scripts’ reliability, and build tools tailored to system requirements.</p>

                        <h3>5. Practical Projects</h3>
                        <p>To reinforce these skills, we worked on practical projects that combine learned concepts and provide hands-on experience with system management.</p>
                        <ul>
                            <li><b>Web Server Setup: Installing and configuring a basic web server with nginx or apache to serve a simple webpage.</b></li>
                            <li><b>File Server: Setting up an FTP or Samba file server to facilitate file sharing across networks.</b></li>
                            <li><b>Custom Scripts: Writing custom shell scripts to automate tasks like user creation, system monitoring, or log analysis.</b></li>
                        </ul>
                        <p>Practical projects provide real-world applications of Linux administration skills, allowing users to implement and test what they’ve learned in realistic scenarios.</p>
                    </div>
                </div>
            </div>
            
            <div class="dropdown">
                <button onclick="toggleDropdown('week4quiz')">Quiz</button>
                <div id="week4quiz" class="dropdown-content">
                    <div class="day-title">Week 4 Quiz: Security and Advanced Administration</div>
                    <div class="day-info">
                        <p>Below is a 10-question multiple-choice quiz for Week 4, covering topics like basic security, backup and recovery, task automation, advanced scripting, and practical projects. Each question includes 4 options, followed by the correct answers for self-assessment.</p>
                        <h3>1. Which command is used to configure a simple firewall in Linux?</h3>
                        <p>a) ufw<br>b) iptables<br>c) firewall-cmd<br>d) All of the above</p>

                        <h3>2. What does the chmod 700 filename command do?</h3>
                        <p>a) Gives full permissions to the owner, and no permissions to others<br>b) Gives read and write permissions to everyone<br>c) Removes execute permissions from all users<br>d) Makes the file executable only for the owner</p>

                        <h3>3. What is the purpose of the /etc/sudoers file?</h3>
                        <p>a) To store encrypted passwords<br>b) To configure which users and groups have sudo privileges<br>c) To list installed packages<br>d) To configure system-wide firewall rules</p>

                        <h3>4. Which command is used to create a backup archive in Linux?</h3>
                        <p>a) cp<br>b) tar<br>c) rsync<br>d) mv</p>

                        <h3>5. What is the difference between cron and anacron?</h3>
                        <p>a) cron is for one-time tasks, while anacron runs tasks repeatedly.<br>b) There is no difference between cron and anacron.<br>c) cron only works for root users, while anacron works for all users.<br>cron can run tasks at specific times, but anacron is used for systems that may be offline during the scheduled time.</p>

                        <h3>6. Which of the following is an advantage of automating tasks using shell scripts?</h3>
                        <p>a) Improves manual monitoring<br>b) Makes the system more secure by default<br>c) Reduces repetitive tasks and human error<br>d) Provides graphical user interfaces for task management</p>

                        <h3>7. Which command would you use to encrypt a file using OpenSSL?</h3>
                        <p>a) openssl enc<br>b) openssl genrsa<br>c) openssl x509<br>d) openssl req</p>

                        <h3>8. What is a common use of the rsync command?</h3>
                        <p>a) Scheduling tasks<br>b) Synchronizing files between systems or directories<br>c) Configuring firewall rules<br>d) Viewing system logs</p>

                        <h3>9. What does the set -x command do in a shell script?</h3>
                        <p>a) Terminates the script immediately<br>b) Silences error messages in the script<br>c) Enables debugging by showing each command as it is executed<br>d) Creates a backup of the script</p>

                        <h3>10. Which type of security practice is recommended for running backups?</h3>
                        <p>a) Store backup files only on the primary disk of the system.<br>b) Ensure backups are encrypted and stored in multiple locations.<br>c) Disable user permissions for accessing backups.<br>d) Use only physical backup methods like DVDs.</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week4answers')">Quiz Answers</button>
                <div id="week4answers" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz Answers</div>
                    <div class="day-info">
                        <h3>1. Which command is used to configure a simple firewall in Linux?</h3>
                        <p>Answer: d) All of the above</p>

                        <h3>2. What does the chmod 700 filename command do?</h3>
                        <p>Answer: a) Gives full permissions to the owner, and no permissions to others</p>

                        <h3>3. What is the purpose of the /etc/sudoers file?</h3>
                        <p>Answer: b) To configure which users and groups have sudo privileges</p>

                        <h3>4. Which command is used to create a backup archive in Linux?</h3>
                        <p>Answer: b) tar</p>

                        <h3>5. What is the difference between cron and anacron?</h3>
                        <p>Answer: d) cron can run tasks at specific times, but anacron is used for systems that may be offline during the scheduled time.</p>

                        <h3>6. Which of the following is an advantage of automating tasks using shell scripts?</h3>
                        <p>Answer: c) Reduces repetitive tasks and human error</p>

                        <h3>7. Which command would you use to encrypt a file using OpenSSL?</h3>
                        <p>Answer: a) openssl enc</p>

                        <h3>8. What is a common use of the rsync command?</h3>
                        <p>Answer: b) Synchronizing files between systems or directories</p>

                        <h3>9. What does the set -x command do in a shell script?</h3>
                        <p>Answer: c) Enables debugging by showing each command as it is executed</p>

                        <h3>10. Which type of security practice is recommended for running backups?</h3>
                        <p>Answer: b) Ensure backups are encrypted and stored in multiple locations.</p>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Additional weeks can follow the same structure -->
     <!-- Week 5 -->
     <div class="dropdown">
        <button onclick="toggleDropdown('week5')">Week 5</button>
        <div id="week5" class="dropdown-content">
            <!-- Days -->
            <div class="dropdown">
                <button onclick="toggleDropdown('week5day1')">Day 1</button>
                <div id="week5day1" class="dropdown-content">
                    <div class="day-title">Linux in the Cloud</div>
                    <div class="day-info">
                        <h3>Introduction to Cloud Services</h3>
                        <p>Cloud services allow businesses and individuals to access computing resources (like servers, storage, databases, networking, and software) over the internet. This model provides scalability, flexibility, cost savings, and enhanced performance compared to traditional on-premise infrastructure. Cloud service providers offer a variety of services, including infrastructure, platforms, and software, each catering to different needs.</p>
                        <p>Let's take a look at the three major cloud providers: Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP), as well as some additional players in the cloud space.</p>

                        <h3>1. Microsoft Azure</h3>
                        <p>Azure is Microsoft's cloud computing platform, offering a wide array of services similar to AWS. It integrates seamlessly with Microsoft's products (like Windows Server, Active Directory, Office 365, and SQL Server), making it a popular choice for enterprises heavily reliant on the Microsoft ecosystem. Key Services:</p>
                        <ul>
                            <li><b>Azure Virtual Machines (VMs): Offers scalable computing power, including support for Windows and Linux VMs.</b></li>
                            <li><b>Azure App Services: A fully managed platform for building and hosting web apps and mobile backends.</b></li>
                            <li><b>Azure Kubernetes Service (AKS): Managed Kubernetes clusters for containerized workloads.</b></li>
                            <li><b>Azure Functions: Serverless computing for running event-driven code without managing servers.</b></li>
                            <li><b>Azure Storage: Scalable cloud storage for unstructured data, including blob storage, queues, and tables.</b></li>
                            <li><b>Azure Active Directory (AAD): Identity and access management for secure single sign-on (SSO), multi-factor authentication, etc.</b></li>
                            <li><b>Azure DevOps: Tools for CI/CD, version control (Git), and project management.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Excellent integration with Microsoft products.</b></li>
                            <li><b>Strong presence in hybrid cloud and enterprise environments.</b></li>
                            <li><b>Comprehensive security and compliance offerings.</b></li>
                        </ul>

                        <h3>2. Google Cloud Platform (GCP)</h3>
                        <p>Google Cloud Platform (GCP) is Google's cloud offering. It's particularly well-suited for data-driven and machine learning workloads, thanks to its powerful tools and infrastructure, including the same infrastructure that powers Google Search, Gmail, and YouTube.
                        Key Services:</p>
                        <ul>
                            <li><b>Compute Engine: Google’s infrastructure-as-a-service (IaaS) offering for running VMs.</b></li>
                            <li><b>Google Kubernetes Engine (GKE): Managed Kubernetes service, recognized for its high performance.</b></li>
                            <li><b>Cloud Functions: Serverless computing for running event-driven code.</b></li>
                            <li><b>BigQuery: A fully managed, serverless, and highly scalable data warehouse for running fast SQL queries on large datasets.</b></li>
                            <li><b>Cloud Storage: Highly durable and scalable object storage.</b></li>
                            <li><b>Cloud AI and Machine Learning: Includes pre-trained models, AutoML, and TensorFlow for custom AI development.</b></li>
                            <li><b>Google Cloud Spanner: A globally distributed, horizontally scalable database.</b></li>
                            <li><b>Firebase: Platform for building mobile and web apps with tools for real-time databases, hosting, authentication, and more.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Leading-edge machine learning and data analytics capabilities.</b></li>
                            <li><b>Strong Kubernetes and container offerings.</b></li>
                            <li><b>Competitive pricing for networking services.</b></li>
                            <li><b>Integration with Google’s services like Gmail, Maps, and YouTube.</b></li>
                        </ul>

                        <h3>3. Amazon Web Services (AWS)</h3>
                        <p>AWS is the largest and most comprehensive cloud provider, offering over 200 services. It is widely used by startups, enterprises, and government agencies due to its vast array of services and global infrastructure.
                        Key Services:</p>
                        <ul>
                            <li><b>EC2 (Elastic Compute Cloud): Virtual machines with customizable configurations.</b></li>
                            <li><b>S3 (Simple Storage Service): Scalable object storage with industry-leading durability.</b></li>
                            <li><b>Lambda: Serverless computing for running code in response to events.</b></li>
                            <li><b>RDS (Relational Database Service): Managed databases like MySQL, PostgreSQL, Oracle, and SQL Server.</b></li>
                            <li><b>DynamoDB: NoSQL database service for low-latency workloads.</b></li>
                            <li><b>Elastic Beanstalk: Platform as a service (PaaS) for deploying web apps.</b></li>
                            <li><b>AWS Fargate: Serverless compute engine for containers.</b></li>
                            <li><b>CloudFront: Content delivery network (CDN) for fast content distribution.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Extensive service offerings and global reach.</b></li>
                            <li><b>Strong security and compliance framework.</b></li>
                            <li><b>Powerful networking and content delivery tools.</b></li>
                            <li><b>Broad ecosystem of partners and third-party integrations.</b></li>
                        </ul>
                        
                        <h3>4. IBM Cloud</h3>
                        <p>IBM Cloud provides a mix of IaaS, PaaS, and SaaS services, with an emphasis on enterprise solutions, AI, and hybrid cloud.
                        Key Services:</p>
                        <ul>
                            <li><b>IBM Cloud Virtual Servers: Scalable, secure virtual machines.</b></li>
                            <li><b>IBM Watson: AI services for natural language processing, machine learning, and deep learning.</b></li>
                            <li><b>IBM Cloud Kubernetes Service: Managed Kubernetes for running containerized applications.</b></li>
                            <li><b>Cloud Object Storage: High-durability, scalable storage.</b></li>
                            <li><b>IBM Cloud Functions: Event-driven, serverless computing.</b></li>
                            <li><b>Blockchain as a Service: Tools for building and managing blockchain networks.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Deep AI and machine learning offerings with IBM Watson.</b></li>
                            <li><b>Strong in hybrid and multi-cloud environments.</b></li>
                            <li><b>Security and enterprise-focused solutions.</b></li>
                        </ul>

                        <h3>5. Oracle Cloud</h3>
                        <p>Oracle Cloud focuses heavily on enterprise solutions, databases, and ERP systems. It’s a popular choice for companies using Oracle’s database and application suites.
                        Key Services:</p>
                        <ul>
                            <li><b>Oracle Cloud Infrastructure (OCI): High-performance computing with a focus on enterprise workloads.</b></li>
                            <li><b>Autonomous Database: Fully managed database service with self-tuning and scaling capabilities.</b></li>
                            <li><b>Oracle Analytics Cloud: Tools for analyzing and visualizing data.</b></li>
                            <li><b>Oracle Cloud VMware Solution: Supports running VMware-based environments natively on Oracle Cloud.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Tailored for enterprise and large-scale workloads.</b></li>
                            <li><b>Strong in database and ERP systems.</b></li>
                            <li><b>Cost-effective for Oracle-centric businesses.</b></li>
                        </ul>

                        <h3>6. Alibaba Cloud</h3>
                        <p>Alibaba Cloud is a leading cloud provider in China and across Asia, with a growing presence globally. It is known for its scalability and affordability.
                        Key Services:</p>
                        <ul>
                            <li><b>Elastic Compute Service (ECS): Virtual servers for scalable compute.</b></li>
                            <li><b>Object Storage Service (OSS): Secure and scalable cloud storage.</b></li>
                            <li><b>MaxCompute: Big data platform for processing massive datasets.</b></li>
                            <li><b>AI and Machine Learning: Tools for building AI models and analytics.</b></li>
                            <li><b>Alibaba Cloud CDN: Content delivery network for fast data distribution.</b></li>
                            <li><b>Alibaba Cloud RDS: Managed databases like MySQL, PostgreSQL, and SQL Server.</b></li>
                        </ul>
                        <p>Strengths:</p>
                        <ul>
                            <li><b>Dominant presence in Asia and growing globally.</b></li>
                            <li><b>Competitive pricing.</b></li>
                            <li><b>Strong e-commerce and data processing tools (leveraging Alibaba’s expertise).</b></li>
                        </ul>

                        <h3>7. Other Cloud Providers:</h3>
                        <p>DigitalOcean: Known for its simplicity and ease of use, DigitalOcean is popular among developers and small businesses for quick deployments of virtual machines and managed Kubernetes.</p>
                        <p>Linode: Another developer-focused cloud provider that offers affordable and simple cloud infrastructure solutions, especially for small businesses and startups.</p>
                        <p>Vultr: Similar to DigitalOcean and Linode, Vultr offers affordable and scalable compute resources. It is a favorite for hosting websites and lightweight applications.</p>
                        <p>Heroku: A PaaS service for deploying and managing applications, especially popular for developers who want to focus on coding without managing infrastructure. It is based on AWS but abstracts much of the complexity.</p>

                        <h3>Cloud Service Models:</h3>
                        <p>Infrastructure as a Service (IaaS): Provides virtualized computing resources like virtual machines, storage, and networking. (e.g., AWS EC2, Azure Virtual Machines, Google Compute Engine)</p>
                        <p>Platform as a Service (PaaS): Provides a platform allowing customers to develop, run, and manage applications without the complexity of building and maintaining infrastructure. (e.g., Heroku, AWS Elastic Beanstalk, Google App Engine)</p>
                        <p>Software as a Service (SaaS): Delivers software applications over the internet on a subscription basis. (e.g., Microsoft 365, Google Workspace, Salesforce)</p>
                        <p>Each cloud provider offers unique advantages tailored to different use cases. AWS is known for its broad ecosystem and flexibility, Azure for its integration with Microsoft products and enterprise tools, GCP for its strength in data and machine learning, while other providers like IBM Cloud, Oracle Cloud, and Alibaba Cloud focus on specific enterprise solutions.</p>
                        <p>Selecting a cloud provider depends on your organization’s requirements, including compute power, security, machine learning capabilities, or ease of integration with existing tools. Many businesses opt for a multi-cloud strategy, leveraging the strengths of different providers to optimize performance, cost, and capabilities.</p>

                        <h3>Advantages of Linux in the Cloud</h3>
                        <p>Cost Efficiency:<br>Linux is an open-source operating system, meaning there are no licensing fees associated with its use. When running Linux in the cloud, this can lead to significant cost savings compared to proprietary systems, especially at scale. Cloud service providers often offer lower-cost Linux-based virtual machines (VMs).</p>
                        <p>Customization and Flexibility:<br>Linux offers a high degree of flexibility for customization, allowing users to modify the operating system to fit specific workloads or project needs. This flexibility is ideal for cloud environments, where businesses can tailor their systems to match specific application needs, from web servers to large-scale databases.</p>
                        <p>Security:<br>Linux has a strong reputation for being secure, with regular updates and a robust community that actively patches vulnerabilities. Cloud environments benefit from Linux's security features, as the OS is less prone to malware and can be more easily hardened through customized security configurations.</p>
                        <p>Scalability:<br>Linux is highly scalable and can handle large amounts of traffic and processing power, making it well-suited for cloud environments. Many cloud-native technologies, such as Kubernetes and Docker, rely on Linux-based containers and microservices architectures, which makes Linux the natural fit for scalable cloud applications.</p>
                        <p>Wide Range of Tools and Compatibility:<br>Linux supports a broad range of cloud-native tools, including automation tools, CI/CD pipelines, and monitoring systems. The OS is well-integrated into cloud services, and most cloud providers offer Linux distributions such as Ubuntu, CentOS, Debian, and Red Hat, making it compatible with nearly any type of cloud infrastructure.</p>
                        <p>Strong Community Support:<br>Linux has a vast, active user base and development community. This open-source ecosystem ensures access to a large pool of resources, forums, guides, and troubleshooting support for Linux in the cloud. Users can also benefit from contributions and innovations from the community.</p>

                        <h3>Disadvantages of Linux in the Cloud</h3>
                        <p>Learning Curve:<br>Linux can be challenging for users who are new to the platform. Its command-line interface (CLI), file system structure, and user management are different from more familiar operating systems like Windows. This learning curve can be a barrier for organizations and users who need more time to train or onboard staff.</p>
                        <p>Compatibility Issues:<br>While Linux offers vast compatibility with cloud-native tools and services, it may not be compatible with some legacy software applications that were designed specifically for Windows or other operating systems. In some cases, organizations may need to find alternatives or workarounds, which can be time-consuming.</p>
                        <p>Limited Support for Proprietary Software:<br>Many proprietary software applications and enterprise solutions are optimized for Windows, and while Linux has its own open-source alternatives, compatibility issues can arise. Organizations relying on specific proprietary software may face challenges running it on Linux without using compatibility layers like Wine or virtualization, which can introduce complexity and performance overhead.</p>
                        <p>Management Overhead:<br>Linux often requires more manual configuration and system management than other operating systems. While cloud environments can help automate some of these tasks, administrators may still need to spend more time managing configurations, security patches, and system updates, especially in large-scale deployments.</p>
                        <p>Support and Documentation Differences:<br>While Linux has a large community, enterprise-level support may not be as comprehensive or immediately available compared to proprietary systems like Windows Server. For organizations that require high levels of dedicated support and service level agreements (SLAs), choosing the right Linux distribution with proper commercial backing (e.g., Red Hat) may be necessary, potentially adding costs.</p>
                        <p>Hardware Compatibility:<br>While Linux runs well on most cloud infrastructures, it can sometimes encounter hardware compatibility issues, particularly on specialized or older cloud hardware configurations. This is less of an issue in public clouds but may still be relevant in private cloud or hybrid cloud deployments using custom hardware.</p>

                        <h3>Using AWS</h3>
                        <p>Please bear in mind depending on the options you pick and the type that has pasted it may look a little different then what i have down below, but it is usally still pretty close and can guide you to what you need to do.</p>
                        <b>Step 1: Log into AWS Management Console</b>
                        <p> Go to the AWS Management Console and log in.<br>In the search bar, type EC2 and select EC2 to open the EC2 Dashboard.</p>
                        <b>Step 2: Launch a New Instance</b>
                        <p>In the EC2 Dashboard, click Launch Instance.</p>
                        <p>On the "Launch an instance" page, provide the following details:<br>Name and Tags: Optionally, give your instance a name, such as MyLinuxVM.<br>Application and OS Images (Amazon Machine Image): Choose an Amazon Machine Image (AMI). Common Linux distributions are available, such as:</p>
                        <ul>
                            <li><b>Amazon Linux (optimized for AWS)</b></li>
                            <li><b>Ubuntu Server (e.g., Ubuntu Server 20.04 LTS)</b></li>
                            <li><b>Red Hat Enterprise Linux</b></li>
                        </ul>
                        <p>Instance Type: Select an instance type, such as t2.micro (part of the AWS Free Tier) or t3.micro for general-purpose use.<br>Key Pair (login): Select an existing key pair if you already have one, or create a new key pair by clicking Create a new key pair. Download and save this key file (.pem) securely, as you’ll need it to SSH into the instance.<br>Network settings: Ensure SSH (port 22) is enabled. If you plan to run a web server, you may also enable HTTP (port 80) and HTTPS (port 443) here.</p>
                        
                        <b>Step 3: Configure Storage</b>
                        <p> In the Configure Storage section, select the storage options:<br>By default, an 8 GiB root volume is created with General Purpose SSD (gp2) storage. You can increase the size or change the storage type if needed.</p>
                        <p>If you need additional storage, you can add new volumes here as well.</p>
                        <b>Step 4: Configure Advanced Settings (Optional)</b>
                        <p>In the Advanced Details section, you can set additional configuration options like instance roles, user data, and shutdown behavior. This is optional, so you can skip this for a basic setup.</p>
                        <b>Step 5: Review and Launch</b>
                        <p>After configuring the settings, review your instance configuration to ensure everything is set up correctly.<br>Click Launch Instance. AWS will now create the instance, which usually takes a few seconds.</p>
                        <b>Step 6: Connect to Your Linux VM via SSH</b>
                        <ul>
                            <li><b>Once the instance is launched, go to the EC2 Dashboard and click Instances in the left sidebar.</b></li>
                            <li><b>Find your instance in the list. Note the Public IPv4 address or Public DNS (IPv4) of your instance—this is how you’ll connect to it.</b></li>
                            <li><b>Open a terminal on your local machine and use SSH to connect:</b></li>
                            <li><b>bash</b></li>
                            <li><b>ssh -i /path/to/your-key.pem ec2-user@<Public-IP-or-DNS></b></li>
                            <li><b> Replace /path/to/your-key.pem with the path to your key file, and <Public-IP-or-DNS> with your instance’s public IP or DNS.</b></li>
                            <li><b>When prompted, type yes to continue connecting.</b></li>
                        </ul>
                        <b>Step 7: Install Software (Optional)</b>
                        <p>Once connected, you can start installing and configuring software. For example, to update the package manager and install Nginx, you would run:</p>
                        <ul>
                            <li><b>bash</b></li>
                        </ul>
                        <p>sudo yum update -y   # for Amazon Linux<br>sudo yum install nginx -y</p>
                        <p>If you’re using Ubuntu, you would use sudo apt update and sudo apt install instead.</p>
                        <b>Step 8: Stop or Terminate the VM (When Done)</b>
                        <p>When finished, you can either stop the instance to retain data but not run up charges or terminate it to delete it completely.</p>
                        <p>Go to the EC2 Dashboard.</p>
                        <ul>
                            <li><b>Select your instance, click Instance state at the top, and choose Stop or Terminate.</b></li>
                            <li><b>Stop: Shuts down the VM, keeping its configuration and storage. You can start it again later.</b></li>
                            <li><b>Terminate: Completely deletes the instance and its storage (unless configured otherwise).</b></li>
                        </ul>
                        <p>Here’s a recap of the steps to create a Linux VM on AWS:</p>
                        <ul>
                            <li><b>Log into AWS and navigate to EC2.</b></li>
                            <li><b>Launch a new instance and configure settings (select AMI, instance type, key pair, and network settings).</b></li>
                            <li><b>Connect via SSH to access the VM.</b></li>
                            <li><b>Install software as needed.</b></li>
                            <li><b>Stop or terminate the instance when done.</b></li>
                        </ul>
                        <p>AWS EC2 offers a flexible, pay-as-you-go model and many configuration options. Let me know if you need further help or have any specific requirements!</p>

                        <h3>Using Microsoft Azure</h3>
                        <b>Step 1: Log into Azure Portal</b>
                        <p>Go to the Azure Portal.<br>Sign in with your credentials.</p>
                        <b>Step 2: Create a New Virtual Machine</b>
                        <ul>
                            <li><b>In the Azure Portal Dashboard, click on Create a resource (the "+" sign) in the upper left corner.</b></li>
                            <li><b>In the "Search the Marketplace" box, type Virtual Machine, and click on Virtual Machine under the Compute section.</b></li>
                            <li><b>On the next screen, click Create to begin setting up your VM.</b></li>
                        </ul>
                        <b>Step 3: Configure the Virtual Machine Basics</b>
                        <ul>
                            <li><b>Subscription: Select the appropriate subscription for billing purposes.</b></li>
                            <li><b>Resource Group: Create a new resource group (for example, LinuxVM-RG) or select an existing one. Resource groups help organize your resources.</b></li>
                            <li><b>Virtual Machine Name: Give your VM a name, such as MyLinuxVM.</b></li>
                            <li><b>Region: Select a region close to you or one that meets your requirements. Popular options are "East US", "West Europe", etc.</b></li>
                            <li><b>Availability Options: Choose the option that suits your needs. For this basic setup, select No infrastructure redundancy required.</b></li>
                            <li><b>Security Type: Standard </b></li>
                        </ul>
                        <p>Image: Select the Linux distribution you want to use. You can choose from distributions like:</p>
                        <ul>
                            <li><b>Ubuntu Server 20.04 LTS (popular choice)</b></li>
                            <li><b>Red Hat Enterprise Linux</b></li>
                            <li><b>CentOS</b></li>
                            <li><b>Debian For this guide, we'll use Ubuntu Server 20.04 LTS.</b></li>
                        </ul>
                        <p>Size: Select a VM size. For testing purposes, a lower-tier instance like Standard_B1s or Standard_B2s is sufficient. You can adjust this depending on your needs.</p>
                        <p>Authentication Type: Select SSH public key or password</p>
                        <ul>
                            <li><b>In the "Username" field, enter a username (e.g., azureuser).</b></li>
                            <li><b>In the "password" field, enter a password</b></li>
                        </ul>
                        <p>SSH:</p>
                        <ul>
                            <li><b>Username: eg. azureuser</b></li>
                            <li><b>Generate key pair</b></li>
                            <li><b>Key pair name: ubuntu_key</b></li>
                        </ul>
                        <p>Inbound port rules: Select Allow selected ports and check SSH (22). This allows you to SSH into the VM.</p>

                        <b>Step 4: Configure Disks (Optional)</b>
                        <p>Under the Disks tab, choose the type of disk you want for your VM:</p>
                        <ul>
                            <li><b>Standard HDD: Cost-effective, good for light workloads.</b></li>
                            <li><b>Standard SSD: Mid-tier option.</b></li>
                            <li><b>Premium SSD: High performance, but more expensive.</b></li>
                        </ul>
                        <p>For this setup, you can choose Standard SSD or Standard HDD.</p>
                        <p>You can attach additional disks if needed, but for a simple VM, the default OS disk is sufficient.</p>

                        <b>Step 5: Networking</b>
                        <p>On the Networking tab, configure network settings:</p>
                        <ul>
                            <li><b>Virtual Network: Choose an existing virtual network or create a new one (the default settings are usually fine for most use cases).</b></li>
                            <li><b>Subnet: You can use the default subnet provided, or create a new one.</b></li>
                            <li><b>Public IP: A public IP will be created for your VM automatically (default option).</b></li>
                            <li><b>NIC network security group (NSG): Choose Basic and make sure Allow selected ports is selected (SSH port 22).</b></li>
                        </ul>
                        <p>Leave the rest of the networking settings as default unless you need custom settings.</p>
                        <b>Step 6: Management, Monitoring, and Tags (Optional)</b>
                        <ul>
                            <li><b>On the Management tab, you can configure auto-shutdown, monitoring, and backups.</b></li>
                            <li><b>Enable auto-shutdown: Optionally set this to automatically shut down the VM at a specific time each day.</b></li>
                            <li><b>Monitoring: Azure provides monitoring through Boot diagnostics. Keep this enabled for troubleshooting purposes.</b></li>
                        </ul>
                        <p>Tags (Optional): Tags help organize resources by grouping them logically (e.g., env=dev, owner=teamA). You can skip this for now.</p>
                        <b>Step 7: Review and Create</b>
                        <ul>
                            <li><b>Review the configuration to ensure everything is correct.</b></li>
                            <li><b>Click Create.</b></li>
                            <li><b>Azure will now deploy your Linux VM. This may take a few minutes.</b></li>
                            <li><b>Go to resources, this will take you to your vm detail page</b></li>
                        </ul>
                        <b>Step 8: Connect to Your VM via SSH</b>
                        <p>Once the deployment is complete:</p>
                        <ul>
                            <li><b>Navigate to the Virtual Machines section on the Azure portal and find the VM you just created.</b></li>
                            <li><b>Click on your VM (e.g., MyLinuxVM).</b></li>
                            <li><b>In the Overview section, find the Public IP address of your VM.</b></li>
                            <li><b>Open a terminal on your local machine and use SSH to connect to the VM:</b></li>
                            <li><b>bash</b></li>
                            <li><b>ssh azureuser@<Public-IP-Address></b></li>
                            <li><b>You should now be logged into your Linux VM.</b></li>
                        </ul>
                        <b>Step 9: Install Software (Optional)</b>
                        <p>Once connected to your Linux VM, you can start installing software and configuring it based on your requirements.</p>
                        <p>For example, to update the package manager and install Apache, you would run:</p>
                        <ul>
                            <li><b>bash</b></li>
                            <li><b>sudo apt update</b></li>
                            <li><b>sudo apt install apache2 -y</b></li>
                        </ul>
                        <b>Step 10: Stop or Delete the VM (When Done)</b>
                        <p>When you're finished with the VM, remember to either stop or delete it to avoid incurring costs:</p>
                        <ul>
                            <li><b>Go to the Virtual Machines section in the Azure portal.</b></li>
                            <li><b>Select your VM, and choose either Stop (to shut down but keep the VM resources) or Delete (to remove it completely).</b></li>
                        </ul>
                        <P>You've now successfully created and connected to a Linux VM on Microsoft Azure! Here's a recap of the main steps:</P>
                        <ul>
                            <li><b>Log into the Azure Portal.</b></li>
                            <li><b>Create a Linux VM, configure settings (like region, image, size, and SSH authentication).</b></li>
                            <li><b>Launch the VM.</b></li>
                            <li><b>Use SSH to connect to the VM and begin using it.</b></li>
                        </ul>
                        <p>This is a basic VM setup, but Azure also provides advanced features like auto-scaling, networking customization, and integrations with services like Azure Active Directory, storage, and more.</p>

                        <h3>Using Google Cloud</h3>
                        <b>Step 1: Log into Google Cloud Console</b>
                        <ul>
                            <li><b>Go to the Google Cloud Console and sign in with your Google account.</b></li>
                            <li><b> If this is your first time, you might need to create a project. Simply give your project a name (e.g., my-linux-vm-project), and click Create.</b></li>
                        </ul>
                        <b>Step 2: Create a New VM Instance</b>
                        <ul>
                            <li><b>If this is your first time using Compute Engine, you will need to enable the Compute Engine API. Click Enable and wait a few seconds for it to be set up.</b></li>
                            <li><b>In the Google Cloud Console, navigate to the Compute Engine service. You can find it by clicking the hamburger menu (☰) in the top-left corner, then selecting Compute Engine > VM Instances.</b></li>
                            <li><b>Once you’re in the VM Instances page, click Create Instance at the top of the page.</b></li>
                        </ul>
                        <b>Step 3: Configure the Virtual Machine</b>
                        <ul>
                            <li><b>Name: Give your instance a meaningful name, such as my-linux-vm.</b></li>
                            <li><b>Region and Zone: Choose a region and zone close to you. This can impact performance and cost. Popular choices include us-central1, europe-west1, etc.</b></li>
                            <li><b>Machine Family: Choose a machine family. By default, GCP selects E2 (General-purpose) for cost efficiency. If you need more power, you can switch to N1, N2, or N2D for higher performance. For a basic setup, E2 is good.</b></li>
                            <li><b>Machine Type: Select the size of the VM. For basic purposes, you can choose E2-micro (1 vCPU, 0.6 GB memory) or E2-small. You can always resize it later.</b></li>
                        </ul>
                        <p>Boot Disk:</p>
                        <p>Operating System: Select a Linux distribution. Common choices include:</p>
                        <ul>
                            <li><b>Ubuntu (e.g., Ubuntu 20.04 LTS)</b></li>
                            <li><b>Debian</b></li>
                            <li><b>CentOS</b></li>
                            <li><b>Boot disk type: Choose either Standard Persistent Disk (cost-effective) or SSD Persistent Disk (better performance).</b></li>
                            <li><b>Disk Size: 10 GB is usually sufficient for a basic setup.</b></li>
                        </ul>
                        <p>Identity and API: This determines level of access for users. You can leave this as default for basic set up.</p>
                        <p>Firewall Rules:</p>
                        <ul>
                            <li><b>Make sure to check Allow HTTP traffic and Allow HTTPS traffic if you plan to serve web traffic later on.</b></li>
                            <li><b>For SSH access, ensure the default firewall settings are enabled, allowing SSH (port 22).</b></li>
                        </ul>
                        <p>Step 4: SSH Key Setup</p>
                        <p>Authentication: By default, Google Cloud uses its built-in SSH key management, but you can manually provide an SSH key if you want. There should be a SSH button top left, click this and it will ssh in for you.</p>
                        <b>Step 5: Review and Create the VM</b>
                        <ul>
                            <li><b>After configuring all the necessary options, click Create at the bottom.</b></li>
                            <li><b>Google Cloud will now provision your virtual machine, which should take less than a minute.</b></li>
                        </ul>
                        <b>Step 6: Access Your Linux VM via SSH</b>
                        <p>Once the VM is created, you can access it via SSH in multiple ways.<br>Option 1: Use Google Cloud Console SSH</p>
                        <p>In the VM Instances dashboard, you’ll see your new VM listed.<br>Click the SSH button next to your VM’s name, and a browser-based SSH terminal will open. You’ll be logged into the VM automatically.</p>
                        <b>Option 2: Use Your Local Terminal and SSH Key</b>
                        <ul>
                            <li><b>In the VM details, you’ll find the External IP address of the VM.</b></li>
                            <li><b>Open a terminal on your local machine and use the following SSH command:</b></li>
                            <li><b>bash</b></li>
                            <li><b>ssh -i /path/to/your/private-key username@ External-IP</b></li>
                            <li><b>Replace /path/to/your/private-key with the path to your private key (e.g., ~/.ssh/id_rsa), and <External-IP> with the actual public IP address of your VM.</b></li>
                            <li><b>You’ll now be connected to your Linux VM.</b></li>
                        </ul>
                        <b>Step 7: Install Software and Configure the VM (Optional)</b>
                        <p>Once connected, you can start configuring your VM and installing software. For example, to update the package manager and install Nginx (a web server), you would run:</p>
                        <ul>
                            <li><b>bash</b></li>
                            <li><b>sudo apt update</b></li>
                            <li><b>sudo apt install nginx -y</b></li>
                        </ul>
                        <p>You can install any software package based on your use case, such as Apache, Docker, Python, etc.</p>

                        <b>Step 8: Stop or Delete the VM (When Done)</b>
                        <ul>
                            <li><b>When you’re finished using the VM, you can either stop it or delete it to avoid incurring charges.</b></li>
                            <li><b>To stop the VM, go to the VM Instances page, select your VM, and click Stop. This stops the VM but retains the disk and configuration.</b></li>
                            <li><b>To delete the VM entirely, select it from the VM Instances page, click Delete, and confirm the deletion. This will remove the VM and its associated resources.</b></li>
                        </ul>
                        <p>You’ve successfully created a Linux virtual machine on Google Cloud Platform. Here’s a recap of the steps:</p>
                        <ul>
                            <li><b>Log into the Google Cloud Console.</b></li>
                            <li><b>Navigate to Compute Engine > VM Instances and click Create Instance.</b></li>
                            <li><b>Configure the VM (name, region, machine type, boot disk, and firewall rules).</b></li>
                            <li><b>Optionally, add an SSH key.</b></li>
                            <li><b>Review the settings and create the VM.</b></li>
                            <li><b>Access the VM using SSH (through the browser or local terminal).</b></li>
                            <li><b>Install software or configure the VM as needed.</b></li>
                            <li><b>Stop or delete the VM when done.</b></li>
                        </ul>
                        <p>Google Cloud provides a flexible and scalable platform for hosting your Linux-based workloads. If you need to scale up or down, GCP makes it easy to adjust the resources allocated to your VM.</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week5day2')">Day 2</button>
                <div id="week5day2" class="dropdown-content">
                    <div class="day-title">Introduction to Docker and Containerization</div>
                    <div class="day-info">
                        <p>What is Docker? Docker is a platform that enables developers to create, deploy, and run applications in containers. A container packages an application and all its dependencies into a standardized unit that can run reliably on any computing environment, from a developer’s local machine to large-scale cloud infrastructure.</p>
                        <p>What is Containerization? Containerization is a lightweight form of virtualization where applications are isolated in containers. Unlike traditional virtual machines (VMs), containers share the host system’s operating system, which makes them more efficient, faster to start, and less resource-intensive. Containers run the same across different environments because they encapsulate all the necessary libraries and dependencies for the application.</p>

                        <b>Benefits of Docker and Containerization:</b>
                        <ul>
                            <li><b>Consistency Across Environments: Containers package applications with all dependencies, so they run the same on any environment, from development to production.</b></li>
                            <li><b>Isolation: Each container runs independently, allowing developers to run multiple applications or services on the same host without interference.</b></li>
                            <li><b>Scalability: Containers can easily scale horizontally, which is essential for cloud-native, microservices-based applications.</b></li>
                            <li><b>Efficiency: Containers are lightweight, sharing the OS kernel of the host, and require less memory and storage than traditional VMs.</b></li>
                            <li><b>Speed: Containers start almost instantly, enhancing the speed of deployment and development.</b></li>
                        </ul>
                        <b>Basic Docker Concepts:</b>
                        <ul>
                            <li><b>Images: A Docker image is a read-only template that defines the container’s environment, including the operating system, libraries, and application code.</b></li>
                            <li><b>Containers: A container is a running instance of a Docker image. It includes everything needed to run an application, isolated from other processes.</b></li>
                            <li><b>Dockerfile: A Dockerfile is a text file containing commands to build a Docker image. It specifies the base image, application code, dependencies, and setup commands.</b></li>
                            <li><b>Docker Hub: A repository where Docker images are stored and can be downloaded from. It includes official images like nginx, ubuntu, and mysql.</b></li>
                        </ul>
                        <b>Basic Docker Commands:</b>
                        <ul>
                            <li><b>docker pull <image>: Downloads a Docker image from Docker Hub.</b></li>
                            <li><b>docker run <image>: Starts a container from an image.</b></li>
                            <li><b>docker ps: Lists running containers.</b></li>
                            <li><b>docker stop <container-id>: Stops a running container.</b></li>
                            <li><b>docker build -t <name> .: Builds an image from a Dockerfile.</b></li>
                            <li><b>docker rm <container-id>: Removes a stopped container.</b></li>
                        </ul>
                        
                        <h3>Launch docker container inside AWS run centos and kali linux</h3>
                        <p>If you want to save your installed tools and configurations, you can create an image from your container. Start Detached run docker run -d "container name" to run the container in detached mode (in the background). </p>
                        <b>1. Set Up Your Ubuntu EC2 Instance in AWS</b>
                        <ul>
                            <li><b>Launch an Ubuntu EC2 instance on AWS.</b></li>
                            <li><b>Configure SSH access to connect to the instance.</b></li>
                            <li><b>Ensure security group settings allow SSH access (port 22).</b></li>
                        </ul>
                        <b>2. Connect to Your Ubuntu EC2 Instance</b>
                        <p>From your local machine, use SSH to connect to the instance:</p>
                        <ul>
                            <li><b>ssh -i /path/to/your-key.pem ubuntu@your-ec2-public-ip</b></li>
                        </ul>
                        <p>Once connected, you’ll be in the terminal of your Ubuntu instance. You can also connect from inside AWS terminal.</p>
                        <b>3. Update and Install Docker on Ubuntu</b>
                        <p>If Docker isn’t already installed on your EC2 instance, follow these steps:</p>
                        <p>Update package lists:</p>
                        <ul>
                            <li><b>sudo apt update && sudo apt upgrade -y</b></li>
                        </ul>
                        <p>Install Docker dependencies:</p>
                        <ul>
                            <li><b>sudo apt-get install -y ca-certificates curl gnupg</b></li>
                        </ul>
                        <p>Add Docker’s GPG key:</p>
                        <ul>
                            <li><b>sudo install -m 0755 -d /etc/apt/keyrings</b></li>
                            <li><b>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</b></li>
                            <li><b>sudo chmod a+r /etc/apt/keyrings/docker.gpg</b></li>
                        </ul>
                        <p>Add Docker’s repository:</p>
                        <ul>
                            <li><b>echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</b></li>
                            <li><b>$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null</b></li>
                        </ul>
                        <p>Install Docker:</p>
                        <ul>
                            <li><b>sudo apt update</b></li>
                            <li><b>sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</b></li>
                        </ul>
                        <p>Verify Docker installation:</p>
                        <ul>
                            <li><b>sudo systemctl status docker</b></li>
                        </ul>
                        <p>Test Docker by running:</p>
                        <ul>
                            <li><b>sudo docker --version</b></li>
                            <li><b>sudo docker run hello-world</b></li>
                        </ul>
                        <b>4. Pull the CentOS Image from Docker Hub</b>
                        <p>With Docker installed, pull the CentOS image:</p>
                        <ul>
                            <li><b>sudo docker pull centos</b></li>
                        </ul>
                        <p>This command downloads the CentOS image from Docker Hub, which you can then use to create CentOS containers.</p>
                        <b>5. Run a CentOS Container</b>
                        <p>Create and start a CentOS container, giving it interactive access (-it), which allows you to run commands in the container:</p>
                        <ul>
                            <li><b>sudo docker run -it centos</b></li>
                        </ul>
                        <p>This command:</p>
                        <ul>
                            <li><b>Creates a container based on the CentOS image.</b></li>
                            <li><b>Starts a terminal session in the container, so you can interact with it directly.</b></li>
                        </ul>
                        <b>6. Run Programs Inside the CentOS Container</b>
                        <p>Now, you’re inside the CentOS container, and you can start running commands or programs just as you would on a CentOS machine.</p>
                        <p>For example:</p>
                        <p>Check CentOS version:</p>
                        <ul>
                            <li><b>cat /etc/centos-release</b></li>
                        </ul>
                        <p>Install additional packages (like curl or vim) using yum (CentOS’s package manager):</p>
                        <ul>
                            <li><b>yum update -y</b></li>
                            <li><b>yum install curl -y</b></li>
                        </ul>
                        <b>7. Exit the CentOS Container</b>
                        <p>When you’re done, exit the container by typing:</p>
                        <ul>
                            <li><b>exit</b></li>
                        </ul>
                        <p>This stops the container and returns you to the Ubuntu host shell.</p>
                        <b>8. (Optional) Start the Container Again</b>
                        <p>To restart the container you previously created, first list your Docker containers to find the container ID:</p>
                        <ul>
                            <li><b>sudo docker ps -a</b></li>
                        </ul>
                        <p>Then start the container:</p>
                        <ul>
                            <li><b>sudo docker start -i container_id</b></li>
                        </ul>
                        <p>This allows you to pick up where you left off in the CentOS environment.</p>
                        <p>You now have a CentOS environment running in a Docker container on your Ubuntu AWS instance! You can use it for development, testing, or running CentOS-specific applications.</p>
                        <b>1. Pull the Official Kali Linux Docker Image</b>
                        <p>Kali Linux offers an official Docker image on Docker Hub. To get it, use the following command:</p>
                        <ul>
                            <li><b>docker pull kalilinux/kali-rolling</b></li>
                        </ul>
                        <p>This command pulls the latest Kali Linux Docker image with the rolling release version.</p>
                        <b>2. Run the Kali Linux Container</b>
                        <p>Once the image is downloaded, create and start a container from it:</p>
                        <ul>
                            <li><b>docker run -it kalilinux/kali-rolling</b></li>
                        </ul>
                        <p>-it: Runs the container interactively and allocates a pseudo-TTY, allowing you to interact with it directly.<br>kalilinux/kali-rolling: Specifies the Kali Linux Docker image.</p>
                        <p>This will open a shell in your Kali Linux container where you can start using it.</p>

                        <b>3. Update Kali Linux (Optional)</b>
                        <p>Inside the Kali container, it’s good practice to update the package list and upgrade packages for the latest tools and fixes:</p>
                        <ul>
                            <li><b>apt update && apt upgrade -y</b></li>
                        </ul>

                        <b>4. Install Kali Tools as Needed</b>
                        <p>Kali Linux in Docker starts as a minimal installation. To install specific tools, use apt install inside the container. For example:</p>
                        <ul>
                            <li><b>apt install nmap</b></li>
                        </ul>
                        <p>You can install any Kali tools available in the repositories as needed.</p>

                        <b>5. Exit the Container</b>
                        <p>When you’re done, type exit to close the session. This stops the container.</p>
                        <p>Additional Tips</p>
                        <p>Save Container State: If you want to save your installed tools and configurations, you can create an image from your container.<br>Start Detached: Run docker run -d kalilinux/kali-rolling to run the container in detached mode (in the background).</p>
                        <p>Running Kali Linux in Docker is a great way to use Kali tools without a full installation, ideal for quick, contained security testing setups.</p>

                        <b>1. Start the Container with a Name</b>
                        <p>For example, if you want to start a Kali Linux container and name it kali-container, run:</p>
                        <ul>
                            <li><b>docker run -it --name kali-container kalilinux/kali-rolling</b></li>
                        </ul>
                        <p>Now, the container is running with the name kali-container.</p>

                        <b>2. Reconnect to the Container by Name</b>
                        <p>If the container is still running, you can attach to it using:</p>
                        <ul>
                            <li><b>docker attach kali-container</b></li>
                        </ul>
                        <p>This command will reattach you to the container’s main process (if it's still running interactively).</p>

                        <b>3. Start and Connect to a Stopped Container by Name</b>
                        <p>If the container has stopped and you want to restart it and attach to it, use:</p>
                        <ul>
                            <li><b>docker start -i kali-container</b></li>
                        </ul>
                        <p>The -i option allows you to interact with the container as it runs.</p>

                        <b>4. Use docker exec to Run Commands in the Container by Name</b>
                        <p>If you want to open a new terminal session in the container, or the container is running in the background, you can use docker exec:</p>
                        <ul>
                            <li><b>docker exec -it kali-container /bin/bash</b></li>
                        </ul>
                        <p>This command starts a new Bash session inside the container without stopping or restarting it.</p>

                        <h3>Basic Usage of Virtualization Tools: VirtualBox and KVM</h3>

                        <b>1. VirtualBox</b>
                        <p>Overview:</p>
                        <p>VirtualBox is an open-source virtualization software developed by Oracle. It allows users to run multiple operating systems as virtual machines on a single physical host machine. It’s widely used for testing, development, and training, supporting a range of guest OSes including Windows, Linux, and macOS.</p>
                        <p>Features of VirtualBox:</p>
                        <ul>
                            <li><b>Snapshots: Take snapshots of a VM at different stages, which can be reverted to if needed.</b></li>
                            <li><b>Shared Folders: Share folders between the host and the guest VM.</b></li>
                            <li><b>Network Configuration: Supports various network modes (NAT, Bridged, Host-Only) for customizing network connectivity.</b></li>
                            <li><b>Portability: VM configurations can be exported and run on other VirtualBox installations.</b></li>
                        </ul>
                        <p>Basic VirtualBox Workflow:</p>
                        <p>Install VirtualBox: Download from VirtualBox’s official website.</p>
                        <p>Create a New Virtual Machine:</p>
                        <ul>
                            <li><b>Choose the operating system and allocate resources (CPU, RAM, disk).</b></li>
                            <li><b>Attach an ISO file to install the OS on the virtual machine.</b></li>
                        </ul>
                        <p>Run and Manage the VM:</p>
                        <ul>
                            <li><b>Start the VM, install the OS, and manage VM settings.</b></li>
                        </ul>
                        <p>Use Snapshots: Before making changes, take a snapshot to easily revert if needed.</p>
                        <p>Advantages of VirtualBox:</p>
                        <ul>
                            <li><b>Cross-platform: Works on Windows, macOS, and Linux.</b></li>
                            <li><b>User-Friendly: Has an easy-to-navigate GUI, making it accessible to beginners.</b></li>
                            <li><b>Cost-Free: VirtualBox is free and open-source, suitable for testing without licensing costs.</b></li>
                        </ul>
                        <b>2. KVM (Kernel-based Virtual Machine)</b>
                        <p>Overview:</p>
                        <p>KVM (Kernel-based Virtual Machine) is a virtualization technology built into the Linux kernel, transforming it into a hypervisor. It allows Linux to host multiple virtual machines with excellent performance and stability, and is ideal for Linux servers.</p>
                        <p>Features of KVM:</p>
                        <ul>
                            <li><b>High Performance: Since it’s part of the Linux kernel, it achieves near-native performance for VMs.</b></li>
                            <li><b>Resource Management: VMs can be fine-tuned for CPU, memory, and storage requirements.</b></li>
                            <li><b>Scalability: Can handle numerous VMs on a single host, depending on available resources.</b></li>
                            <li><b>Security: Supports SELinux and sVirt for strong VM isolation.</b></li>
                        </ul>
                        <p>Basic KVM Workflow:</p>
                        <p>Install KVM and Related Tools:</p>
                        <ul>
                            <li><b>Install KVM, libvirt, and virt-manager on a Linux distribution to manage VMs.</b></li>
                        </ul>
                        <p>Set Up Virtual Machines:</p>
                        <ul>
                            <li><b>Use virt-manager for a GUI or virsh commands for CLI management.</b></li>
                            <li><b>Allocate CPU, memory, and disk space for each VM.</b></li>
                        </ul>
                        <p>Network and Storage Configuration:</p>
                        <ul>
                            <li><b>Configure networking (e.g., NAT, bridge) for VMs to connect to the internet or each other.</b></li>
                        </ul>
                        <p>Start, Stop, and Manage VMs:</p>
                        <ul>
                            <li><b>Use virt-manager to start and stop VMs, configure hardware, or use snapshots.</b></li>
                        </ul>
                        <b>Advantages of KVM:</b>
                        <ul>
                            <li><b>Native to Linux: KVM integrates directly into the Linux kernel, making it highly efficient for Linux environments.</b></li>
                            <li><b>Flexible Management: Can be managed via command line or GUI (e.g., virt-manager), allowing administrators various control options.</b></li>
                            <li><b>nterprise-ready: Provides high security, excellent performance, and is widely used in enterprise and cloud environments.</b></li>
                        </ul>

                        <b>Laymen's for KVM</b>
                        <p><b>What is KVM?</b></p>
                        <p>KVM (Kernel-based Virtual Machine) is a tool that lets you turn a Linux computer into a hypervisor, which is basically a host machine that can run multiple virtual computers (called virtual machines or VMs) on it. With KVM, each VM acts like a separate computer, complete with its own operating system, apps, and settings, all running on one physical computer.</p>

                        <b>How KVM Works</b>
                        <p>KVM works by converting your Linux computer’s kernel (the core part of the OS that communicates with hardware) into a tool that can manage multiple virtual environments. This means each VM you create can operate independently, as if it were a separate computer. Since KVM is built directly into the Linux kernel, it’s very fast and efficient.</p>

                        <b>What Makes KVM Different from Other Virtualization Tools?</b>
                        <p>KVM is unique because it is part of the Linux kernel. Other virtualization tools, like VirtualBox, work on top of the operating system as an application, while KVM is directly integrated into Linux. This integration makes KVM a powerful and efficient choice if you're already running a Linux server or workstation and want to run VMs on it.</p>

                        <b>Example of Using KVM</b>
                        <p>Imagine you’re a developer working on multiple projects. Some projects require different environments, like a specific version of Linux, Windows, or even a different Linux distribution. With KVM:</p>
                        <ul>
                            <li><b>You could set up a Linux VM to test a web app on a particular Linux distribution.</b></li>
                            <li><b>Simultaneously, you might run a Windows VM for testing a Windows-only application.</b></li>
                        </ul>
                        <p>Each VM has its own operating system and can run as if it were an independent machine, even though they’re all running on the same physical computer.</p>

                        <b>Advantages of Using KVM</b>
                        <ul>
                            <li><b>High Performance: Since it’s integrated with the Linux kernel, KVM offers near-native performance, meaning VMs run almost as fast as if they were on a separate physical machine.</b></li>
                            <li><b>Hesource Management: KVM allows you to allocate specific resources (CPU, memory, disk space) to each VM, so you have control over how much each one uses.</b></li>
                            <li><b>Security and Isolation: With KVM, each VM is isolated, which means that if one VM crashes or is attacked, it won’t affect the others or the host machine.</b></li>
                            <li><b>Scalability: You can create and run multiple VMs on a single server, depending on your hardware’s capabilities, making KVM useful in server environments.</b></li>
                        </ul>

                        <b>When to Use KVM</b>
                        <p>KVM is ideal if:</p>
                        <ul>
                            <li><b>You’re using a Linux server and need to host multiple virtual machines.</b></li>
                            <li><b>You want to maximize performance and make use of Linux’s built-in resources.</b></li>
                            <li><b>You need a powerful, enterprise-grade solution for handling multiple virtual machines on a Linux server.</b></li>
                        </ul>

                        <b>Hypervisors</b>
                        <p>A hypervisor is a piece of software, firmware, or hardware that enables you to create and manage virtual machines (VMs) on a single physical computer. It allows multiple VMs to share the same physical hardware resources, like CPU, memory, and storage, while keeping them separated from each other. Each VM behaves as if it’s a separate, standalone computer, with its own operating system and applications.</p>

                        <b>How a Hypervisor Works</b>
                        <p>The hypervisor sits between the physical hardware and the virtual machines. It acts as a traffic controller, allocating resources (like CPU time, memory, and disk space) to each VM as needed. Because the VMs are isolated, they can run different operating systems and applications without interfering with one another.</p>

                        <b>Types of Hypervisors</b>
                        <p>There are two main types of hypervisors:</p>
                        <p>Type 1 (Bare-Metal) Hypervisors: These hypervisors run directly on the computer’s hardware, without an underlying operating system. This setup is often used in data centers and enterprise environments because it offers high performance and stability.</p>
                        <p>Examples: VMware ESXi, Microsoft Hyper-V, Xen</p>
                        <p>Type 2 (Hosted) Hypervisors: These hypervisors run on top of an existing operating system, like an application. This setup is more common for desktop users who want to run multiple OS environments for development, testing, or general use.</p>
                        <p>Examples: VirtualBox, VMware Workstation, Parallels</p>

                        <b>What the Hypervisor Does</b>
                        <ul>
                            <li><b>Isolation: Keeps each VM separated so that issues or changes in one VM don’t affect others.</b></li>
                            <li><b>Resource Management: Allocates CPU, memory, and other resources to each VM as needed.</b></li>
                            <li><b>Portability: Makes it easy to move VMs between different computers or servers, since the virtual machine’s environment is self-contained.</b></li>
                        </ul>

                        <b>Why Use a Hypervisor?</b>
                        <p>Hypervisors are incredibly useful for tasks like:</p>
                        <ul>
                            <li><b>Server Consolidation: Running multiple servers (VMs) on a single physical machine to save space and costs.</b></li>
                            <li><b>Testing and Development: Creating different environments for testing software on multiple OSes without needing separate hardware.</b></li>
                            <li><b>Cloud Computing: Hypervisors are at the heart of cloud platforms, enabling providers to offer virtualized servers (virtual machines) to their customers.</b></li>
                        </ul>
                        <p>A hypervisor allows a single computer to host multiple, isolated virtual environments, making it essential for virtualization, cloud computing, and efficient use of computing resources.</p>

                        <b>Comparison of Docker and Virtualization (VirtualBox/KVM)</b>
                        <p><b>Feature</b><br>Isolation<br>Resource Usage<br>Use Case<br>Boot Time<br>Compatibility<br>Security</p>
                        <p><b>Docker</b><br>Process-level isolation<br>Lightweight, shares OS kernel<br>Microservices, cloud-native applications<br>Very fast (seconds)<br>Works best with Linux apps<br>Good but shared kernel</p>
                        <p><b>VirtualBox/KVM</b><br>Full OS-level isolation<br>More resource-intensive, full OS<br>Full OS testing, isolated environments<br>Slower (minutes)<br>Full OS compatibility<br>Stronger isolation per VM</p>

                        <p>Both Docker and virtualization solutions like VirtualBox or KVM are essential tools in modern IT. Docker is ideal for microservices, CI/CD pipelines, and cloud-native applications where quick scaling and portability are priorities. Virtualization tools are better suited for testing, OS isolation, and environments where a fully independent OS is needed.</p>

                        <b>laymen's terms for Docker and VMs</b>
                        <p>Imagine you have a powerful computer, and you want to run multiple applications or operating systems on it, maybe for different projects. There are two main ways to do this: containerization (using something like Docker) and virtualization (using tools like VirtualBox or KVM). Think of these as ways to organize and separate your applications or systems to keep them from interfering with each other.</p>

                        <b>Containers (Docker)</b>
                        <p>Containers are like small, self-contained “rooms” in your computer where you can put an application and all the things it needs to work. Each container has everything it needs, like its specific files, libraries, and tools, so it doesn’t have to rely on anything outside of it. But, all these rooms share the same walls and structure — meaning, they share your computer’s core, or kernel, which is the “brain” of your operating system. This makes containers very lightweight; they don’t need their own separate operating system because they use your computer’s core resources.</p>
                        <p>Example: Let’s say you’re building a website that needs specific software to run. You can set up a container with just that software and your website files. If you want to create a second container for another project, you can do that too, without worrying about messing up the first one. Both containers will run on the same system but act like separate mini-environments.</p>
                        <p>Avantages: Containers start very quickly and take up less space on your computer. If you want to move your application to another computer, you just move the container without changing anything. It’ll run the same way on any machine.</p>

                        <b>Virtual Machines (Virtualization with VirtualBox or KVM)</b>
                        <p>Virtual machines (VMs), on the other hand, are like having multiple separate “computers” inside your one physical computer. Each virtual machine has its own full operating system (like a mini version of Windows or Linux) and is completely isolated from others. This is great if you need to run different operating systems, test software, or keep things very separate from each other.</p>
                        <p>Virtualization tools like VirtualBox or KVM create these virtual machines. They simulate everything a computer needs — from the processor to memory to storage — for each VM, making each one act like a separate computer. This is more resource-intensive because each VM is running its own operating system on top of the host system.</p>
                        <p>Example: Say you’re developing software that needs to work on both Linux and Windows. You can set up a Linux VM and a Windows VM, both on the same physical computer. Each VM will operate independently, so you can test the software in both environments without needing separate physical machines.</p>
                        <p>Advantages: VMs provide stronger separation since each one runs a full OS. This is useful when you need total separation between systems, especially when running programs or applications that need different operating systems or specific configurations.</p>

                        <b>Comparison of Containers and VMs</b>
                        <p>Speed: Containers (like Docker) start up in seconds because they don’t need to load a full OS. VMs take longer since they’re booting up a whole operating system.</p>
                        <p>Resource Use: Containers share resources with the host OS, so they use less memory and storage. VMs are like mini-computers with their own OS, so they use more resources.</p>
                        <p>Isolation: VMs are more isolated from each other because they don’t share the OS. This can be more secure but slower. Containers are more connected to the host OS, making them fast but with slightly less isolation.</p>

                        <b>When to Use Each One</b>
                        <p>Containers: If you’re building or running specific applications (like web apps or microservices) that don’t need their own full OS, containers are faster and easier. They’re great for modern cloud applications that need to be quickly scalable and portable.</p>
                        <p>Virtual Machines: If you need to run different operating systems or keep things highly separate (like for testing software on Windows and Linux), VMs are a better choice. They work well for tasks where complete isolation and OS-specific environments are necessary.</p>
                        <p>In short, containers are lightweight, flexible mini-environments, ideal for applications that need to run anywhere quickly. Virtual machines, meanwhile, are like full computers within a computer, providing strong isolation but with more overhead.</p>

                        
                        <b>Set up a VM with Virtualbox</b>

                        <p>Requirements:</p>
                        <ul>
                            <li><b>Download and install VirtualBox from the official website.</b></li>
                            <li><b>Have an ISO file of the operating system (like Ubuntu, Windows, etc.) you want to install on the VM.</b></li>
                        </ul>
                        <p>Steps to Set Up a Virtual Machine in VirtualBox</p>
                        <b>1. Open VirtualBox</b>
                        <ul>
                            <li><b>Launch the VirtualBox application on your computer.</b></li>
                        </ul>
                        <b>2. Create a New Virtual Machine</b>
                        <ul>
                            <li><b>Click on the "New" button in the VirtualBox window to start creating a new VM.</b></li>
                            <li><b>Give your VM a name (like “Ubuntu Test VM”).</b></li>
                        </ul>
                        <p>Choose the Type and Version:</p>
                        <ul>
                            <li><b>For example, if you’re installing Ubuntu, select “Linux” as the Type and “Ubuntu (64-bit)” as the Version.</b></li>
                        </ul>
                        <p>Click Next to continue.</p>

                        <b>3. Allocate Memory (RAM)</b>
                        <ul>
                            <li><b>Decide how much RAM to allocate to the VM.</b></li>
                            <li><b>For Ubuntu, 2 GB (2048 MB) is usually enough, but you can adjust it based on your system’s available memory.</b></li>
                            <li><b>Click Next.</b></li>
                        </ul>

                        <b>4. Create a Virtual Hard Disk</b>
                        <p>Choose "Create a virtual hard disk now" and click Create.</p>
                        <p>Select the type of hard disk:</p>
                        <ul>
                            <li><b>Choose VDI (VirtualBox Disk Image), which is standard for VirtualBox.</b></li>
                        </ul>
                        <p>Storage on physical hard disk:</p>
                        <ul>
                            <li><b>Choose Dynamically allocated (it will only use space as needed).</b></li>
                            <li><b>Click Next.</b></li>
                        </ul>
                        
                        <b>5. Set Hard Disk Size</b>
                        <ul>
                            <li><b>Set the maximum disk size for your VM (20 GB is typically sufficient for a Linux VM).</b></li>
                            <li><b>Choose where to save the VM’s virtual hard disk file.</b></li>
                            <li><b>Click Create.</b></li>
                        </ul>

                        <b>6. Attach the ISO File (OS Installation)</b>
                        <ul>
                            <li><b>Go back to the VirtualBox main window and select your VM.</b></li>
                            <li><b>Click on Settings → Storage.</b></li>
                            <li><b>Under Controller: IDE, click the Empty CD icon.</b></li>
                            <li><b>On the right, click the CD icon next to “Optical Drive” and choose Choose a disk file… to locate your OS ISO file.</b></li>
                            <li><b>Select your ISO file and click OK.</b></li>
                        </ul>
                        
                        <b>7.Start the VM</b>
                        <ul>
                            <li><b>With the VM selected, click Start to power it on.</b></li>
                            <li><b>The VM will boot from the ISO file, taking you to the OS installer.</b></li>
                        </ul>

                        <b>8. Install the Operating System</b>
                        <p>Follow the OS installer’s instructions.</p>
                        <p>For example, if you’re installing Ubuntu:</p>
                        <ul>
                            <li><b>Choose Install Ubuntu.</b></li>
                            <li><b>Go through the setup steps like choosing language, keyboard layout, and time zone.</b></li>
                            <li><b>When prompted, select Erase disk and install Ubuntu (this only affects the VM’s virtual disk, not your real hard drive).</b></li>
                            <li><b>Complete the installation by creating a user account and password.</b></li>
                            <li><b>The VM will prompt you to restart once installation is complete.</b></li>
                        </ul>
                        
                        <b>9. tart Using Your VM</b>
                        <ul>
                            <li><b>Now, each time you start this VM, it will load your newly installed OS.</b></li>
                            <li><b>You can shut down, restart, or even pause the VM as needed from VirtualBox.</b></li>
                        </ul>
                        <p>Your VM is Now Ready!</p>
                        <p>Your virtual machine should be fully set up, running its own isolated operating system within VirtualBox. You can explore the OS, install software, and use it just like a separate computer.</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week5day3')">Day 3</button>
                <div id="week5day3" class="dropdown-content">
                    <div class="day-title">Customizing the Shell</div>
                    <div class="day-info">
                        <h3>1. .bashrc (Bash Configuration File)</h3>
                        <p>The .bashrc file is a hidden configuration file located in the user’s home directory (~/.bashrc). It’s specific to the Bash shell and is loaded every time you start a new Bash session. This file lets you customize the shell by defining variables, aliases, functions, prompt appearance, and more.
                        Common Customizations in .bashrc:</p>
                        <ul>
                            <li><b>Aliases: Shortcuts for longer commands (e.g., alias ll='ls -lah')</b></li>
                            <li><b>Environment Variables: Set variables like $PATH for custom directories</b></li>
                            <li><b>Prompt Customization: Adjust how your command prompt looks (e.g., show username, directory, etc.)</b></li>
                            <li><b>Functions: Define reusable functions for complex or repeated tasks</b></li>
                            <li><b>History Settings: Customize command history behavior, like limiting the number of stored commands</b></li>
                        </ul>
                        <p>To apply changes, either restart the terminal or source the file:</p>
                        <ul>
                            <li><b>source ~/.bashrc</b></li>
                        </ul>

                        <h3>2. .zshrc (Zsh Configuration File)</h3>
                        <p>Similar to .bashrc, .zshrc is a configuration file for the Zsh shell, located in the user’s home directory (~/.zshrc). It’s loaded every time a new Zsh session starts. Zsh is highly customizable and includes advanced features like better tab completion and path expansion.
                        Common Customizations in .zshrc:</p>
                        <ul>
                            <li><b>Aliases and Functions: Works similarly to .bashrc</b></li>
                            <li><b>Zsh-Specific Options: Like setopt autocd (automatically change directories)</b></li>
                            <li><b>Prompt Customization: Enhanced prompt options through tools like Oh-My-Zsh (e.g., themes, icons)</b></li>
                            <li><b>Plugins: Zsh supports plugins (e.g., for git, syntax highlighting, and autosuggestions)</b></li>
                        </ul>
                        <p>Apply changes with:</p>
                        <ul>
                            <li><b>source ~/.zshrc</b></li>
                        </ul>

                        <h3>3. Oh-My-Zsh</h3>
                        <p>Oh-My-Zsh is a popular open-source framework for managing Zsh configurations. It provides themes, plugins, and other tools to enhance the Zsh experience, making it easy to configure and customize.</p>
                        <p>Key Features of Oh-My-Zsh:</p>
                        <ul>
                            <li><b>Themes: Change the look of your prompt easily. For example, agnoster and powerlevel10k are popular themes.</b></li>
                            <li><b>Plugins: Enhance your shell with additional commands and completions. For example, git for Git commands, zsh-autosuggestions, and zsh-syntax-highlighting.</b></li>
                            <li><b>Easy Configuration: Customizations, themes, and plugins are managed in .zshrc.</b></li>
                        </ul>

                        <p>Installing Oh-My-Zsh:</p>
                        <p>To install Oh-My-Zsh, you need curl or wget:</p>
                        <p>sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"<br>sh -c "$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)"</p>
                        <p>Or</p>
                        <p>sudo apt install zsh</p>
                        <p>you may need to run chsh -s $(which zsh). Then log out and back in.<br>After installation, you can enable themes and plugins by editing .zshrc.</p>

                        <b>Creating Aliases</b>
                        <p>Aliases are shortcuts for commonly used commands. Instead of typing a long command, you create a short alias that you can use in its place. Example Aliases:</p>
                        <p>In .bashrc or .zshrc:</p>
                        <ul>
                            <li><b>alias ll='ls -lah'     # List all files in a detailed view</b></li>
                            <li><b>alias gs='git status'  # Shortcut for 'git status'</b></li>
                            <li><b>alias rm='rm -i'       # Confirm before deleting files</b></li>
                        </ul>
                        <p>Temporary Aliases (only for the current session):</p>
                        <ul>
                            <li><b>alias myip='curl ifconfig.me'</b></li>
                            <li><b>source ~/.bashrc  # or ~/.zshrc for Zsh</b></li>
                        </ul>

                        <b>Creating Functions</b>
                        <p>Functions allow you to create more complex or multi-step commands and reuse them. Unlike aliases, functions can take arguments, making them more flexible. Example Functions:</p>
                        <p>Greeting Function:</p>
                        <p>greet() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Hello, $1!"<br>}</p>
                        <p>Usage: greet "Alice" --> Outputs: "Hello, Alice!"</p>
                        <p>Backup Function:</p>
                        <p>backup() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cp -r "$1" "$1.bak"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Backup of $1 created as $1.bak"<br>}</p>
                        <p>Usage: backup myfile.txt</p>
                        <p>To make functions persistent, add them to .bashrc or .zshrc and reload the file.</p>
                        <p>Tips for Effective Shell Customization</p>
                        <ul>
                            <li><b>Backup Configuration Files: Always back up .bashrc or .zshrc before making extensive changes.</b></li>
                            <li><b>Experiment with Themes: Try different Zsh themes with Oh-My-Zsh to find a look and feel you prefer.</b></li>
                            <li><b>Use Plugins Wisely: Only add plugins you’ll use regularly to keep your shell efficient.</b></li>
                            <li><b>Set Up Aliases for Frequent Tasks: Save time by creating aliases for commands you use daily.</b></li>
                            <li><b>Write Functions for Repetitive Tasks: If you find yourself repeating multi-step commands, write a function.</b></li>
                        </ul>
                        <p>Customizing your shell environment is a powerful way to boost productivity and streamline your workflow. Aliases, functions, and advanced customization options help you tailor the terminal to your preferences and daily tasks.</p>

                        
                        
                        <div class="dropdown">
                            <button onclick="toggleDropdown('week5day3exercises')">Exercises</button>
                            <div id="week5day3exercises" class="dropdown-content">
                                <h3>Exercise 1: Customize the Shell Prompt in .bashrc</h3>
                                <p>Open the .bashrc file in your home directory:</p>
                                <ul>
                                    <li><b>nano ~/.bashrc</b></li>
                                </ul>
                                <p>Change the prompt to display the username, hostname, and the current directory by modifying the PS1 variable in .bashrc. Add this line at the end:</p>
                                <ul>
                                    <li><b>export PS1="\u@\h:\w\$ "</b></li>
                                </ul>
                                <p>Save the file and reload .bashrc:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                </ul>
                                <p>Verify that your prompt displays in the new format (e.g., user@hostname:/current/directory$).</p>
                                
                                <h3>Exercise 2: Create an Alias for Common Commands</h3>
                                <p>In .bashrc, create an alias to simplify listing files with details. Add:</p>
                                <ul>
                                    <li><b>alias ll='ls -la --color=auto'</b></li>
                                </ul>
                                <p>Create another alias to confirm before deleting files:</p>
                                <ul>
                                    <li><b>alias rm='rm -i'</b></li>
                                </ul>
                                <p>Save the file, reload .bashrc, and test the new aliases:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                </ul>
                                <p>ll  # Check if this lists files in long format<br>rm file.txt  # See if it prompts for confirmation before deleting</p>

                                <h3>Exercise 3: Write a Simple Greeting Function</h3>
                                <p>In .bashrc or .zshrc, write a function called greet that takes a name as input and outputs a greeting message.</p>
                                <p>greet() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Hello, $1! Welcome to the system."<br>}</p>
                                <p>Reload the configuration file:</p>
                                <ul>
                                    <li><b>source ~/.bashrc  # or source ~/.zshrc</b></li>
                                </ul>
                                <p>Test the function:</p>
                                <ul>
                                    <li><b>greet Alice # Output should be: "Hello, Alice! Welcome to the system."</b></li>
                                </ul>

                                <h3>Exercise 4: Create a Backup Function</h3>
                                <p>Add a function in .bashrc or .zshrc called backup to make a backup copy of a file with a .bak extension:</p>
                                <p>backup() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cp "$1" "$1.bak"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo "Backup of $1 created as $1.bak"<br>}</p>
                                <p>Reload the configuration file:</p>
                                <ul>
                                    <li><b>source ~/.bashrc  # or source ~/.zshrc</b></li>
                                </ul>
                                <p>Test the function:</p>
                                <ul>
                                    <li><b>touch testfile.txt</b></li>
                                    <li><b>backup testfile.txt</b></li>
                                    <li><b>ls # Verify that "testfile.txt.bak" was created</b></li>
                                </ul>

                                <h3>Exercise 5: Add Color to the Command Prompt (Advanced)</h3>
                                <p>Open .bashrc and set the prompt to display with colors. Add this to your PS1 line:</p>
                                <ul>
                                    <li><b>export PS1="\[\e[32m\]\u@\h:\[\e[34m\]\w\[\e[0m\]\$ "</b></li>
                                </ul>
                                <p>This will display the username and hostname in green and the directory in blue.</p>
                                <p>Save the file, reload .bashrc, and check the new colorful prompt:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                </ul>

                                <h3>Exercise 6: Use Oh-My-Zsh and Install Plugins (if using Zsh)</h3>
                                <p>Install Oh-My-Zsh following the installation instructions on the Oh-My-Zsh website.</p>
                                <p>Open the .zshrc file and add plugins, for example:</p>
                                <ul>
                                    <li><b>plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</b></li>
                                </ul>
                                <p>Apply the new plugins by reloading .zshrc:</p>
                                <ul>
                                    <li><b>source ~/.zshrc</b></li>
                                </ul>
                                <p>Explore the new features provided by the plugins (e.g., syntax highlighting, autosuggestions).</p>

                                <h3>Exercise 7: Set up a Scheduled Greeting with cron</h3>
                                <p>Edit the crontab file:</p>
                                <ul>
                                    <li><b>crontab -e</b></li>
                                </ul>
                                <p>Add a cron job to display a greeting message at a specific time, for example, every day at 9 AM:</p>
                                <ul>
                                    <li><b>0 9 * * * echo "Good morning! Remember to check your tasks for the day."</b></li>
                                </ul>
                                <p>Save and exit. The message will appear in the system logs at the specified time.</p>

                                <h3>Exercise 8: Customize the PATH Variable</h3>
                                <p>Add a custom directory to your $PATH by editing .bashrc:</p>
                                <ul>
                                    <li><b>export PATH=$PATH:$HOME/my_scripts</b></li>
                                </ul>
                                <p>Create a directory called my_scripts and add a simple script inside:</p>
                                <ul>
                                    <li><b>mkdir ~/my_scripts</b></li>
                                    <li><b>echo -e '#!/bin/bash\necho "This is a custom script"' > ~/my_scripts/myscript.sh</b></li>
                                    <li><b>chmod +x ~/my_scripts/myscript.sh</b></li>
                                </ul>
                                <p>Reload .bashrc and test the script:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                    <li><b>myscript.sh  # Output: "This is a custom script"</b></li>
                                </ul>

                                <h3>Exercise 9: Create a Function to Show Disk Usage Summary</h3>
                                <p>diskusage() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;df -h --total | grep 'total'<br>}</p>
                                <p>Reload .bashrc and test the function:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                    <li><b>diskusage  # Should output total disk usage information</b></li>
                                </ul>

                                <h3>Exercise 10: Make a Custom Command Log with Aliases and history</h3>
                                <p>Add an alias in .bashrc to show the last 5 commands you ran:</p>
                                <ul>
                                    <li><b>alias recent='history | tail -n 5'</b></li>
                                </ul>
                                <p>Reload .bashrc and try the alias:</p>
                                <ul>
                                    <li><b>source ~/.bashrc</b></li>
                                    <li><b>recent  # Displays the last 5 commands</b></li>
                                </ul>
                                <p>Modify the alias to save the command history to a log file:</p>
                                <ul>
                                    <li><b>alias recentlog='history | tail -n 5 >> ~/command_log.txt'</b></li>
                                </ul>
                    
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week5day4')">Day 4</button>
                <div id="week5day4" class="dropdown-content">
                    <div class="day-title">Introduction to DevOps Tools</div>
                    <div class="day-info">
                        <p>DevOps is a set of practices that combines software development (Dev) and IT operations (Ops) to enhance collaboration, automate processes, and improve the delivery pipeline's efficiency. Key to DevOps are tools and methodologies like Continuous Integration (CI), Continuous Delivery/Continuous Deployment (CD), and configuration management, which work together to streamline software development, testing, and deployment. Here’s a high-level overview of some foundational DevOps concepts and tools.</p>
                        <h3>1. Continuous Integration (CI) and Continuous Delivery/Deployment (CD)</h3>
                        <p>Continuous Integration (CI): This practice involves frequently merging code changes into a shared repository. Automated tests run each time code is committed, which helps catch issues early, ensuring the codebase remains stable.</p>
                        <p>Continuous Delivery (CD): Expands on CI by automating the release of code changes to testing and production environments. With CD, the software is always ready for deployment, but a human may initiate it.</p>
                        <p>Continuous Deployment: Similar to Continuous Delivery but goes one step further by automating the deployment process as well. Code changes are automatically pushed to production without human intervention.</p>
                        <p>CI/CD practices reduce the risk of code conflicts, speed up releases, and ensure high-quality code reaches end-users faster.</p>

                        <h3>2. DevOps Tools Overview</h3>
                        <p>Various tools help facilitate DevOps practices, each serving a specific role in the software development and deployment lifecycle. Here’s an introduction to some widely used tools in DevOps:</p>
                        <b>Ansible</b>
                        <p>Ansible is an open-source tool primarily used for configuration management, application deployment, and automation. It allows you to define system configurations in simple text files (called playbooks) written in YAML, making it easy to read and write.</p>
                        <p>Key features:</p>
                        <ul>
                            <li><b>Agentless: Ansible doesn’t require a client on each machine it manages, using SSH for communication.</b></li>
                            <li><b>Idempotent: Ensures that playbooks produce the same result, no matter how many times they’re applied.</b></li>
                            <li><b>Scalable: Manages configurations across hundreds or thousands of servers.</b></li>
                        </ul>
                        <p>Use case: Ansible can be used to set up a web server cluster, configure firewall rules, or automate repetitive tasks like user creation and package installations across multiple systems.</p>

                        <b>Jenkins</b>
                        <p>Jenkins is a popular, open-source automation server used to implement CI/CD pipelines. Jenkins allows developers to build, test, and deploy code automatically based on triggers like code commits or pull requests.</p>
                        <p>Key features:</p>
                        <ul>
                            <li><b>Plugins: With over 1,000 plugins, Jenkins can integrate with most DevOps tools and services, extending its capabilities for version control, testing, notifications, and more.</b></li>
                            <li><b>Pipeline as Code: Jenkins allows you to define CI/CD pipelines as code (Jenkinsfile), providing flexibility to automate complex workflows.</b></li>
                            <li><b>Scalability: Jenkins supports distributed builds, enabling tasks to run across multiple machines.</b></li>
                        </ul>
                        <p>Use case: Jenkins can automatically test code pushed to a repository, create builds for different environments (like development or staging), and deploy applications to servers or containers.</p>

                        <b>Kubernetes</b>
                        <p>Kubernetes (K8s) is an open-source container orchestration platform used to manage, scale, and deploy containerized applications. Originally developed by Google, Kubernetes helps automate the deployment and management of applications across a cluster of servers.</p>
                        <p>Key features:</p>
                        <ul>
                            <li><b>Container Orchestration: Automatically manages the lifecycle of containers, handling deployments, rollouts, scaling, and self-healing.</b></li>
                            <li><b>Service Discovery and Load Balancing: Automatically routes traffic to the correct container instances.</b></li>
                            <li><b>Storage Orchestration: Provides mechanisms for persistent storage, allowing stateful applications to run reliably.</b></li>
                            <li><b>Autoscaling: Kubernetes adjusts the number of running containers based on demand, ensuring efficient resource utilization.</b></li>
                        </ul>
                        <p>Use case: Kubernetes can manage a microservices architecture, where each service runs in its own container. Kubernetes would handle service discovery, scaling, and load balancing, ensuring seamless communication and performance across the entire application.</p>

                        <h3>3. Putting It All Together: CI/CD Pipeline with DevOps Tools</h3>
                        <p>A typical DevOps workflow using these tools might look like this:</p>
                        <p>Code Changes: Developers push code changes to a Git repository.</p>
                        <p>Continuous Integration with Jenkins:</p>
                        <p>Jenkins detects the changes, runs automated tests, and, if successful, builds the code into a deployable package.
                        If any tests fail, Jenkins notifies the developer to fix the issues.</p>
                        <p>Configuration Management with Ansible:</p>
                        <p>Ansible sets up the necessary server environment or configures the cloud infrastructure, preparing it for the application.
                        Deployment to Kubernetes:</p>
                        <p>Jenkins deploys the application package to a Kubernetes cluster.</p>
                        <p>Kubernetes orchestrates the deployment, scaling containers as needed and balancing the load across multiple instances.</p>
                        <p>Monitoring and Logging:<br>Other DevOps tools (like Prometheus or ELK Stack) track performance and log errors, providing insights for continuous improvement.</p>

                        <h3>Benefits of Using DevOps Tools</h3>
                        <ul>
                            <li><b>Improved Collaboration: Developers and operations teams work closely with shared tools and processes, reducing communication gaps.</b></li>
                            <li><b>Faster Deployment Cycles: Automated testing, deployment, and scaling make releasing code faster and more reliable.</b></li>
                            <li><b>Enhanced Reliability: By catching bugs early, automating error-prone tasks, and providing self-healing infrastructure, DevOps tools improve software reliability.</b></li>
                            <li><b>Scalability: Kubernetes and Ansible handle scaling across large clusters, making it easy to adapt as demand grows.</b></li>
                        </ul>
                        <p>DevOps tools like Ansible, Jenkins, and Kubernetes bring together the best practices of development and operations, enabling organizations to achieve faster, more reliable, and scalable software delivery. Understanding these tools and how they fit into CI/CD pipelines is essential for modern software engineering and infrastructure management.</p>
                    </div>
                </div>
            

            <div class="dropdown">
                <button onclick="toggleDropdown('week5review')">Week Review</button>
                <div id="week5review" class="dropdown-content">
                    <div class="day-title">Week Five Review: Cloud Computing, Containers, Customization, and DevOps Foundations</div>
                    <div class="day-info">
                        <p>In week five, we took our Linux skills into modern infrastructure management by exploring Linux in the cloud, containers and virtualization, shell customization, and DevOps tools. Here’s a breakdown of each section and the main concepts covered.</p>

                        <h3>1. Linux in the Cloud</h3>
                        <p>With Linux being the backbone of many cloud environments, understanding how it operates in the cloud provides flexibility and scalability for managing applications and infrastructure.</p>
                        <p>Advantages:</p>
                        <ul>
                            <li><b>Scalability: Easily adjust resources based on demand, adding or reducing compute power as needed.</b></li>
                            <li><b> Cost Efficiency: Pay-as-you-go pricing for on-demand resources and significant savings on infrastructure.</b></li>
                            <li><b>Reliability and Redundancy: Cloud providers often have built-in redundancy, ensuring high availability.</b></li>
                        </ul>
                        <p>Disadvantages:</p>
                        <ul>
                            <li><b>Dependency on Providers: Users are tied to provider-specific tools and configurations.</b></li>
                            <li><b>Security Concerns: Shared environments may require more robust security measures.</b></li>
                            <li><b>Data Transfer Costs: Moving data between local and cloud environments can incur additional costs.</b></li>
                        </ul>
                        <p>Linux in the cloud offers a powerful way to deploy and manage applications at scale but comes with trade-offs regarding security and data management.</p>

                        <h3>2. Containers and Virtualization</h3>
                        <p>Containers and virtualization allow multiple environments to operate on a single system, each with its isolated resources, which is critical for developing, testing, and deploying applications.</p>
                        <p>Docker and Containerization:</p>
                        <ul>
                            <li><b>Containers package applications with their dependencies, providing consistent environments across various platforms.</b></li>
                            <li><b>Docker is a popular containerization tool, making it easy to create, deploy, and manage containers.</b></li>
                            <li><b>Benefits: Fast, resource-efficient, and simplifies deployment.</b></li>
                            <li><b>Basic Commands: docker run to start a container, docker ps to list running containers, docker stop to stop containers.</b></li>
                        </ul>
                        <p>Virtualization and Hypervisors:</p>
                        <ul>
                            <li><b>Hypervisors (e.g., VirtualBox, KVM) allow multiple virtual machines (VMs) to run on a single physical host.</b></li>
                            <li><b>Virtual Machines simulate an entire OS, including the kernel, and are useful for testing different environments or OS versions.</b></li>
                            <li><b>VirtualBox and KVM are common tools for creating and managing VMs on Linux.</b></li>
                        </ul>
                        <p>Containers are lightweight and ideal for applications, while VMs provide more isolation and are useful for running different OS environments.</p>

                        <h3>3. Customizing the Shell</h3>
                        <p>Shell customization improves the user experience and productivity by making frequently used commands more accessible and creating personalized workflows.</p>
                        <p>.bashrc and .zshrc:</p>
                        <ul>
                            <li><b>These are configuration files for the Bash and Zsh shells, respectively, and are run every time a new terminal session is started.</b></li>
                            <li><b>Used to set environment variables, aliases, functions, and shell behavior.</b></li>
                        </ul>
                        <p>Creating Aliases and Functions:</p>
                        <ul>
                            <li><b>Aliases: Shortcuts for frequently used commands, e.g., alias ll='ls -la'.</b></li>
                            <li><b>Functions: Allow more complex command sequences to be grouped into one reusable command.</b></li>
                        </ul>
                        <p>Using zsh and oh-my-zsh:</p>
                        <ul>
                            <li><b>Zsh is an alternative to Bash, offering powerful features like better autocompletion and plugins.</b></li>
                            <li><b>oh-my-zsh is a framework for managing Zsh configurations and provides themes and plugins to enhance functionality.</b></li>
                        </ul>
                        <p>Customizing the shell with aliases, functions, and configurations boosts productivity by reducing repetitive typing and organizing workflows.</p>

                        <h3>4. Introduction to DevOps Tools</h3>
                        <p>DevOps tools bridge the gap between development and operations, supporting automation, continuous integration, and deployment.</p>
                        <p>Overview of CI/CD (Continuous Integration/Continuous Deployment):</p>
                        <ul>
                            <li><b>CI/CD automates testing and deploying code changes, enabling faster and more reliable updates.</b></li>
                            <li><b>CI (Continuous Integration) tests code changes automatically.</b></li>
                            <li><b>CD (Continuous Deployment) pushes validated changes to production without manual intervention.</b></li>
                        </ul>
                        <p>DevOps Tools:</p>
                        <ul>
                            <li><b>Ansible: An automation tool used to configure systems, deploy software, and manage infrastructure.</b></li>
                            <li><b>Jenkins: A CI/CD tool that automates testing and deployment, making it easier to integrate code changes frequently.</b></li>
                            <li><b>Kubernetes: An orchestration tool for managing and scaling containerized applications across clusters.</b></li>
                        </ul>
                        <p>DevOps tools enable automation and improve deployment efficiency, making it easier to maintain reliable and scalable systems in complex environments.</p>
                    </div>
                </div>
            </div>
            
            <div class="dropdown">
                <button onclick="toggleDropdown('week5quiz')">Quiz</button>
                <div id="week5quiz" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz</div>
                    <div class="day-info">
                        <h3>1. What is the primary benefit of running Linux in the cloud?</h3>
                        <p>a) Improved graphical user interface<br>b) Enhanced gaming performance<br>c) Ability to scale resources easily and on-demand<br>d) Exclusive software only available in the cloud</p>

                        <h3>2. What is Docker used for?</h3>
                        <p>a) Running virtual machines<br>b) Customizing the shell environment<br>c) Managing cloud resources<br>d) Creating lightweight, portable containers for applications</p>

                        <h3>3. What is a hypervisor?</h3>
                        <p>a) Software or hardware that creates and manages virtual machines<br>b) A tool for customizing the shell<br>c) A file system specifically for virtual disks<br>d) A Linux distribution optimized for cloud environments</p>

                        <h3>4. Which of the following is a plugin manager for zsh?</h3>
                        <p>a) oh-my-zsh<br>b) apt<br>c) pip<br>d) vim-plug</p>

                        <h3>5. What is the purpose of Kubernetes in a DevOps environment?</h3>
                        <p>a) Automating code compilation<br>b) Monitoring system performance<br>c) Creating lightweight virtual machines<br>d) Managing and orchestrating containers across multiple hosts</p>

                        <h3>6. Which command is used to list all running containers in Docker?</h3>
                        <p>a) docker ps<br>b) docker ls<br>c) docker list<br>d) docker show</p>

                        <h3>7. What does the .bashrc file do?</h3>
                        <p>a) Configures firewall rules for the user<br>b) Executes commands or sets environment variables when a new shell session starts<br>c) Stores backup scripts<br>d) Automatically installs software updates</p>

                        <h3>8. What is the main difference between VirtualBox and Docker?</h3>
                        <p>a) VirtualBox uses containers, while Docker uses virtual machines.<br>b) VirtualBox is free, while Docker is not.<br>c) Docker uses containers, while VirtualBox creates full virtual machines.<br>d) Docker is for Windows only, while VirtualBox is for Linux.</p>

                        <h3>9. In cloud environments, what does the term "auto-scaling" refer to?</h3>
                        <p>a) Automatically updating the operating system<br>b) Upgrading the software without manual intervention<br>c) Automatically creating backups<br>d) Adjusting the number of resources based on demand</p>

                        <h3>10. Which tool is commonly used for automating configuration management in DevOps?</h3>
                        <p>a) Jenkins<br>b) Ansible<br>c) Kubernetes<br>d) Docker</p>
                    </div>
                </div>
            </div>
            <div class="dropdown">
                <button onclick="toggleDropdown('week5answers')">Quiz Answers</button>
                <div id="week5answers" class="dropdown-content">
                    <div class="day-title">Week 2 Quiz Answers</div>
                    <div class="day-info">
                        <h3>1. What is the primary benefit of running Linux in the cloud?</h3>
                        <p>c) Ability to scale resources easily and on-demand</p>

                        <h3>2. What is Docker used for?</h3>
                        <p>d) Creating lightweight, portable containers for applications</p>

                        <h3>3. What is a hypervisor?</h3>
                        <p>a) Software or hardware that creates and manages virtual machines</p>

                        <h3>4. Which of the following is a plugin manager for zsh?</h3>
                        <p>a) oh-my-zsh</p>

                        <h3>5. What is the purpose of Kubernetes in a DevOps environment?</h3>
                        <p>d) Managing and orchestrating containers across multiple hosts</p>

                        <h3>6. Which command is used to list all running containers in Docker?</h3>
                        <p>a) docker ps</p>
                        
                        <h3>7. What does the .bashrc file do?</h3>
                        <p>b) Executes commands or sets environment variables when a new shell session starts</p>

                        <h3>8. What is the main difference between VirtualBox and Docker?</h3>
                        <p>c) Docker uses containers, while VirtualBox creates full virtual machines.</p>

                        <h3>9. In cloud environments, what does the term "auto-scaling" refer to?</h3>
                        <p>d) Adjusting the number of resources based on demand</p>

                        <h3>10. Which tool is commonly used for automating configuration management in DevOps?</h3>
                        <p>b) Ansible</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>
<script>
    function toggleDropdown(id) {
        const element = document.getElementById(id);
        element.style.display = element.style.display === 'block' ? 'none' : 'block';
    }

    document.addEventListener("DOMContentLoaded", () => {
            const splashScreen = document.getElementById("splash-screen");
            const enterButton = document.getElementById("enter-course-btn");

            enterButton.addEventListener("click", () => {
                splashScreen.style.transform = "translateY(-100%)";
                splashScreen.style.opacity = "0";
                setTimeout(() => splashScreen.style.display = "none", 1000); // Remove from DOM after animation
            });
        });
</script>